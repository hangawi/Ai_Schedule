import { useState, useEffect, useCallback, useRef } from 'react';
import { generateAIPrompt, parseAIResponse, speak } from '../utils';
import { GoogleGenerativeAI } from '@google/generative-ai';

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:5000';

export const useVoiceRecognition = (
   isLoggedIn,
   isVoiceRecognitionEnabled,
   eventActions,
   areEventActionsReady,
   setEventAddedKey,
) => {
   const [isListening, setIsListening] = useState(false);
   const [modalText, setModalText] = useState('');
   const recognitionRef = useRef(null);
   const [listeningMode, setListeningMode] = useState('hotword'); // 'hotword' or 'command'
   const lastTranscriptRef = useRef('');
   const [micVolume, setMicVolume] = useState(0); // VU meter
   const audioContextRef = useRef(null);
   const analyserRef = useRef(null);
   const sourceRef = useRef(null);
   const animationFrameId = useRef(null);
   const restartingRef = useRef(false);

   /** üé§ Ïò§ÎîîÏò§ Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨ */
   const cleanupAudioResources = useCallback(() => {
      if (animationFrameId.current) cancelAnimationFrame(animationFrameId.current);
      if (sourceRef.current) sourceRef.current.disconnect();
      if (audioContextRef.current && audioContextRef.current.state !== 'closed') {
         audioContextRef.current.close();
         audioContextRef.current = null;
      }
   }, []);

   /** üé§ ÏùåÏÑ± Î™ÖÎ†π Ï≤òÎ¶¨ */
   const processVoiceCommand = useCallback(
      async command => {
         if (!isLoggedIn || !isVoiceRecognitionEnabled) return;

         if (!command) {
            speak('ÎÑ§, Î¨¥ÏóáÏùÑ ÎèÑÏôÄÎìúÎ¶¥ÍπåÏöî?');
            return;
         }

         setModalText(command);

         try {
            const API_KEY = process.env.REACT_APP_GEMINI_API_KEY;
            if (!API_KEY) {
               alert('Gemini API KeyÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. .env ÌååÏùºÏóê REACT_APP_GEMINI_API_KEYÎ•º ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî.');
               return;
            }

            const genAI = new GoogleGenerativeAI(API_KEY);
            const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

            const prompt = generateAIPrompt(command);
            const result = await model.generateContent(prompt);
            const response = await result.response;
            const text = response.text();
            const eventData = parseAIResponse(text);

            if (!eventData.startDateTime) {
               speak('Ïñ∏Ï†ú ÏùºÏ†ïÏùÑ Ïû°ÏùÑÍπåÏöî?');
               return;
            }

            if (!eventActions) {
               console.error('Event actions not available yet.');
               speak('ÏïÑÏßÅ ÏùºÏ†ï Í∏∞Îä•ÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
               return;
            }

            /** üìÖ ÏùºÏ†ï Ï∂îÍ∞Ä */
            if (eventData.intent === 'add_event') {
               const token = localStorage.getItem('token');
               const controller = new AbortController();
               const timeoutId = setTimeout(() => controller.abort(), 15000);

               const apiResponse = await fetch(`${API_BASE_URL}/api/calendar/events/google`, {
                  method: 'POST',
                  headers: {
                     'Content-Type': 'application/json',
                     'x-auth-token': token,
                  },
                  body: JSON.stringify(eventData),
                  signal: controller.signal,
               });

               clearTimeout(timeoutId);

               if (!apiResponse.ok) {
                  const errorData = await apiResponse.json();
                  throw new Error(errorData.msg || 'Failed to add event to Google Calendar');
               }

               speak('ÏùºÏ†ïÏùÑ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÌñàÏäµÎãàÎã§.');
               setEventAddedKey(prevKey => prevKey + 1);
               setModalText('');
            } else if (eventData.intent === 'delete_event' || eventData.intent === 'delete_range') {
               /** üóëÔ∏è ÏùºÏ†ï ÏÇ≠Ï†ú */
               const token = localStorage.getItem('token');
               const controller = new AbortController();
               const timeoutId = setTimeout(() => controller.abort(), 15000);

               try {
                  const threeMonthsAgo = new Date();
                  threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
                  const oneYearLater = new Date();
                  oneYearLater.setFullYear(oneYearLater.getFullYear() + 1);

                  const eventsResponse = await fetch(
                     `${API_BASE_URL}/api/calendar/events?timeMin=${threeMonthsAgo.toISOString()}&timeMax=${oneYearLater.toISOString()}`,
                     {
                        headers: { 'x-auth-token': token },
                        signal: controller.signal,
                     },
                  );

                  if (!eventsResponse.ok) throw new Error('ÏùºÏ†ï Î™©Î°ùÏùÑ Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.');
                  const events = await eventsResponse.json();

                  let matchingEvents;
                  if (eventData.intent === 'delete_range') {
                     const startDate = new Date(eventData.startDateTime);
                     const endDate = new Date(eventData.endDateTime);
                     matchingEvents = events.filter(event => {
                        const eventDate = new Date(event.start.dateTime || event.start.date);
                        const inRange = eventDate >= startDate && eventDate <= endDate;
                        const scheduleKeywords = [
                           'ÏùºÏ†ï',
                           'ÏïΩÏÜç',
                           'ÎØ∏ÌåÖ',
                           'ÌöåÏùò',
                           'Î™®ÏûÑ',
                           'Ï†ÑÏ≤¥',
                           'Ï†ÑÎ∂Ä',
                           'Î™®Îì†',
                           'Î™®Îëê',
                        ];
                        const isGeneralSchedule = !eventData.title || scheduleKeywords.includes(eventData.title);
                        const titleMatch =
                           isGeneralSchedule || event.summary?.toLowerCase().includes(eventData.title.toLowerCase());
                        return inRange && titleMatch;
                     });
                  } else {
                     const targetDate = new Date(eventData.startDateTime).toDateString();
                     matchingEvents = events.filter(event => {
                        const eventDate = new Date(event.start.dateTime || event.start.date).toDateString();
                        const dateMatch = eventDate === targetDate;
                        const scheduleKeywords = [
                           'ÏùºÏ†ï',
                           'ÏïΩÏÜç',
                           'ÎØ∏ÌåÖ',
                           'ÌöåÏùò',
                           'Î™®ÏûÑ',
                           'Ï†ÑÏ≤¥',
                           'Ï†ÑÎ∂Ä',
                           'Î™®Îì†',
                           'Î™®Îëê',
                        ];
                        const isGeneralSchedule = !eventData.title || scheduleKeywords.includes(eventData.title);
                        const titleMatch =
                           isGeneralSchedule || event.summary?.toLowerCase().includes(eventData.title.toLowerCase());
                        return dateMatch && titleMatch;
                     });
                  }

                  if (matchingEvents.length === 0) {
                     speak('Ìï¥Îãπ ÏùºÏ†ïÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏñ¥Ïöî.');
                     return;
                  }

                  const deleteAllKeywords = ['Ï†ÑÎ∂Ä', 'Î™®Îì†', 'Î™®Îëê', 'Îã§', 'Ï†ÑÏ≤¥'];
                  const shouldDeleteAll = deleteAllKeywords.some(keyword => command.includes(keyword));

                  if (matchingEvents.length > 1 && !shouldDeleteAll) {
                     speak(
                        `${matchingEvents.length}Í∞úÏùò ÏùºÏ†ïÏù¥ ÏûàÏñ¥Ïöî. "Ï†ÑÎ∂Ä ÏÇ≠Ï†ú"ÎùºÍ≥† ÌïòÏãúÍ±∞ÎÇò Îçî Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú ÎßêÏîÄÌï¥ Ï£ºÏÑ∏Ïöî.`,
                     );
                     return;
                  }

                  if (matchingEvents.length > 1 && shouldDeleteAll) {
                     let deletedCount = 0;
                     for (const event of matchingEvents) {
                        try {
                           const deleteResponse = await fetch(`${API_BASE_URL}/api/calendar/events/${event.id}`, {
                              method: 'DELETE',
                              headers: { 'x-auth-token': token },
                              signal: controller.signal,
                           });
                           if (deleteResponse.ok) deletedCount++;
                        } catch (error) {
                           console.error('Í∞úÎ≥Ñ ÏùºÏ†ï ÏÇ≠Ï†ú Ïò§Î•ò:', error);
                        }
                     }
                     clearTimeout(timeoutId);
                     speak(`${deletedCount}Í∞úÏùò ÏùºÏ†ïÏùÑ ÏÇ≠Ï†úÌñàÏñ¥Ïöî!`);
                     setEventAddedKey(prevKey => prevKey + 1);
                     setModalText('');
                     return;
                  }

                  const eventToDelete = matchingEvents[0];
                  const deleteResponse = await fetch(`${API_BASE_URL}/api/calendar/events/${eventToDelete.id}`, {
                     method: 'DELETE',
                     headers: { 'x-auth-token': token },
                     signal: controller.signal,
                  });

                  clearTimeout(timeoutId);

                  if (!deleteResponse.ok) throw new Error('ÏùºÏ†ï ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');

                  if (!eventData.response) speak(`${eventToDelete.summary || 'ÏùºÏ†ï'}ÏùÑ ÏÇ≠Ï†úÌñàÏñ¥Ïöî!`);
                  setEventAddedKey(prevKey => prevKey + 1);
                  setModalText('');
               } catch (error) {
                  clearTimeout(timeoutId);
                  console.error('ÏùºÏ†ï ÏÇ≠Ï†ú Ïò§Î•ò:', error);
                  speak(`ÏùºÏ†ï ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏñ¥Ïöî. ${error.message}`);
               }
            } else if (eventData.intent === 'update_event') {
               /** üõ† ÏùºÏ†ï ÏàòÏ†ï (ÎØ∏ÏßÄÏõê) */
               speak('ÏùºÏ†ï ÏóÖÎç∞Ïù¥Ìä∏ Í∏∞Îä•ÏùÄ ÏïÑÏßÅ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
            } else {
               speak('Ïïå Ïàò ÏóÜÎäî Î™ÖÎ†πÏûÖÎãàÎã§.');
            }

            setModalText('');
         } catch (error) {
            if (error.name === 'AbortError') {
               speak('ÏöîÏ≤≠ ÏãúÍ∞ÑÏù¥ Ï¥àÍ≥ºÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
            } else {
               speak(`ÏùåÏÑ± ÏùºÏ†ï Ï∂îÍ∞ÄÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. ${error.message}`);
            }
            setModalText('');
         }
      },
      [isLoggedIn, eventActions, isVoiceRecognitionEnabled, setEventAddedKey],
   );

   /** üé§ ÏùåÏÑ± Ïù∏Ïãù useEffect */
   useEffect(() => {
      if (!isLoggedIn || !areEventActionsReady || !isVoiceRecognitionEnabled) {
         if (recognitionRef.current) recognitionRef.current.stop();
         if (animationFrameId.current) cancelAnimationFrame(animationFrameId.current);
         return;
      }

      /** üîä ÎßàÏù¥ÌÅ¨ Î∂ÑÏÑù */
      const setupAudioAnalysis = async () => {
         try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
            analyserRef.current = audioContextRef.current.createAnalyser();
            sourceRef.current = audioContextRef.current.createMediaStreamSource(stream);
            sourceRef.current.connect(analyserRef.current);
            analyserRef.current.fftSize = 256;
            const bufferLength = analyserRef.current.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            const draw = () => {
               animationFrameId.current = requestAnimationFrame(draw);
               if (!analyserRef.current) return;
               analyserRef.current.getByteFrequencyData(dataArray);
               const average = dataArray.reduce((a, b) => a + b, 0) / bufferLength;
               setMicVolume(average / 128);
            };
            draw();
         } catch (err) {
            console.error('ÎßàÏù¥ÌÅ¨ Ï†ëÍ∑º Ïò§Î•ò:', err);
         }
      };

      if (!recognitionRef.current) {
         recognitionRef.current = new window.webkitSpeechRecognition();
         recognitionRef.current.continuous = true;
         recognitionRef.current.interimResults = true;
         recognitionRef.current.lang = 'ko-KR';
         recognitionRef.current.maxAlternatives = 5;
      }

      const recognition = recognitionRef.current;

      recognition.onstart = () => setIsListening(true);

      recognition.onresult = event => {
         let currentTranscript = '';
         let isFinal = false;
         for (let i = event.resultIndex; i < event.results.length; ++i) {
            let bestAlternative = event.results[i][0];
            for (let j = 1; j < event.results[i].length; j++) {
               if (event.results[i][j].confidence > bestAlternative.confidence) {
                  bestAlternative = event.results[i][j];
               }
            }
            const transcript = bestAlternative.transcript;

            if (event.results[i].isFinal) {
               currentTranscript += transcript;
               isFinal = true;
            } else {
               currentTranscript += transcript;
            }
         }

         if (listeningMode === 'command') {
            setModalText(typeof currentTranscript === 'string' ? currentTranscript.trim() : '');
         }

         if (isFinal) {
            const command = currentTranscript.trim();
            if (listeningMode === 'hotword') {
               const HOTWORDS = ['ÌÅêÎ∏åÏïº', 'ÎπÑÏÑúÏïº', 'ÏûêÎπÑÏä§', 'ÌÅêÎ∏å', 'ÎπÑÏÑú'];
               if (HOTWORDS.some(h => command.toLowerCase().includes(h.toLowerCase()))) {
                  speak('ÎÑ§, ÎßêÏîÄÌïòÏÑ∏Ïöî.');
                  setModalText('ÎÑ§, ÎßêÏîÄÌïòÏÑ∏Ïöî...');
                  setListeningMode('command');
               }
            } else if (listeningMode === 'command') {
               if (command) {
                  processVoiceCommand(command);
                  setListeningMode('hotword');
               }
            }
         }
      };

      recognition.onerror = event => {
         console.error('ÏùåÏÑ± Ïù∏Ïãù Ïò§Î•ò:', event.error);
         if (event.error === 'no-speech') {
            if (listeningMode === 'command') {
               setModalText('ÏùåÏÑ± ÏûÖÎ†• ÏóÜÏùå. Îã§Ïãú ÎßêÏîÄÌï¥Ï£ºÏÑ∏Ïöî...');
               setTimeout(() => setModalText(''), 1500);
            }
            setListeningMode('hotword');
         } else {
            recognition.abort();
            setModalText(`Ïò§Î•ò: ${event.error}`);
            setTimeout(() => setModalText(''), 1500);
         }
      };

      /** ÏûêÎèô Ïû¨ÏãúÏûë */
      recognition.onend = () => {
         if (!restartingRef.current) {
            restartingRef.current = true;
            setTimeout(() => {
               try {
                  cleanupAudioResources();
                  recognition.start();
                  setupAudioAnalysis();
               } catch (e) {
                  console.error('Recognition restart failed', e);
               } finally {
                  restartingRef.current = false;
               }
            }, 500);
         }
      };

      try {
         recognition.start();
         setupAudioAnalysis();
      } catch (e) {
         console.log('Recognition already started.');
      }

      return () => {
         recognition.stop();
         cleanupAudioResources();
      };
   }, [
      isLoggedIn,
      areEventActionsReady,
      isVoiceRecognitionEnabled,
      processVoiceCommand,
      listeningMode,
      cleanupAudioResources,
   ]);

   return { isListening, modalText, setModalText, micVolume };
};
