import React, { useState, useCallback, useEffect } from 'react';
import { userService } from '../../services/userService';
import { coordinationService } from '../../services/coordinationService';
import CalendarView from '../calendar/CalendarView';
import DetailTimeGrid from '../calendar/DetailTimeGrid';
import PersonalTimeManager from '../schedule/PersonalTimeManager';
import PersonalInfoEdit from '../profile/PersonalInfoEdit';
import CustomAlertModal from '../modals/CustomAlertModal';
import { Edit, Save, XCircle, Trash2, User, CalendarDays } from 'lucide-react';

const ProfileTab = ({ onEditingChange }) => {
  const [viewMode, setViewMode] = useState('info'); // 'info' 또는 'schedule'
  const [defaultSchedule, setDefaultSchedule] = useState([]);
  const [scheduleExceptions, setScheduleExceptions] = useState([]);
  const [personalTimes, setPersonalTimes] = useState([]);
  const [isEditing, setIsEditing] = useState(false);

  // 편집 모드일 때 현재 상태를 window에 저장하여 챗봇이 사용할 수 있도록 함
  useEffect(() => {
    if (isEditing) {
      window.__profileEditingState = {
        defaultSchedule,
        scheduleExceptions,
        personalTimes
      };
    } else {
      // 편집 모드 종료 시 삭제
      delete window.__profileEditingState;
    }
  }, [isEditing, defaultSchedule, scheduleExceptions, personalTimes]);
  const [selectedDate, setSelectedDate] = useState(null);
  const [showDetailGrid, setShowDetailGrid] = useState(false);
  
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [customAlert, setCustomAlert] = useState({ show: false, message: '', title: '' });

  // 편집 모드 진입 시 초기 상태 저장 (취소 시 복원용)
  const [initialState, setInitialState] = useState({
    defaultSchedule: [],
    scheduleExceptions: [],
    personalTimes: []
  });

  const showAlert = useCallback((message, title = '알림') => {
    setCustomAlert({ show: true, message, title });
  }, []);

  const closeAlert = useCallback(() => {
    setCustomAlert({ show: false, message: '', title: '' });
  }, []);

  // 방장인 방들의 설정을 업데이트하는 함수
  const updateOwnerRoomsSettings = async (ownerScheduleData) => {
    try {
      console.log('🔍 ProfileTab - 방장 방 설정 업데이트 시작:', {
        hasDefaultSchedule: !!(ownerScheduleData.defaultSchedule),
        defaultScheduleCount: ownerScheduleData.defaultSchedule?.length || 0,
        hasScheduleExceptions: !!(ownerScheduleData.scheduleExceptions),
        scheduleExceptionsCount: ownerScheduleData.scheduleExceptions?.length || 0,
        hasPersonalTimes: !!(ownerScheduleData.personalTimes),
        personalTimesCount: ownerScheduleData.personalTimes?.length || 0,
        personalTimesData: ownerScheduleData.personalTimes
      });

      // 내가 방장인 방 목록 가져오기
      const myRooms = await coordinationService.fetchMyRooms();
      console.log('🔍 ProfileTab - fetchMyRooms 결과:', myRooms);

      // myRooms 구조: {owned: Array, joined: Array}
      const ownedRooms = myRooms?.owned || [];
      const ownerRooms = ownedRooms; // owned 배열이 이미 방장인 방들

      console.log(`🔍 방장인 방 개수: ${ownerRooms.length}`);

      // 요일 매핑 (0: 일, 1: 월, ..., 6: 토)
      const dayOfWeekMap = {
        0: '일요일', 1: '월요일', 2: '화요일', 3: '수요일', 4: '목요일', 5: '금요일', 6: '토요일'
      };

      for (const room of ownerRooms) {
        try {
          // 기존 방 세부정보 가져오기
          const roomData = await coordinationService.fetchRoomDetails(room._id);
          const existingSettings = roomData.settings || { roomExceptions: [] };

          // 기존의 방장 연동 예외들 제거 (isSynced: true인 것들)
          const nonSyncedExceptions = existingSettings.roomExceptions.filter(ex => !ex.isSynced);

          // 새로운 방장 시간표 예외들 생성 (불가능한 시간만 포함)
          const syncedExceptions = [];

          // defaultSchedule(가능한 시간)은 roomExceptions에 추가하지 않음
          // roomExceptions는 금지 시간이므로

          // scheduleExceptions을 날짜/제목별로 그룹화하여 병합 처리
          const exceptionGroups = {};
          (ownerScheduleData.scheduleExceptions || []).forEach(exception => {
            const startDate = new Date(exception.startTime);
            const dateKey = startDate.toLocaleDateString('ko-KR'); // 2025. 9. 30. 형태
            const title = exception.title || '일정';
            const groupKey = `${dateKey}-${title}`;

            if (!exceptionGroups[groupKey]) {
              exceptionGroups[groupKey] = {
                title: title,
                date: dateKey,
                exceptions: []
              };
            }
            exceptionGroups[groupKey].exceptions.push(exception);
          });

          // 각 그룹별로 시간대를 병합하여 roomException 생성
          Object.values(exceptionGroups).forEach(group => {
            // 시간순으로 정렬
            group.exceptions.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));

            // 연속된 시간대들을 병합
            const mergedTimeRanges = [];
            let currentRange = null;

            group.exceptions.forEach(exception => {
              const startDate = new Date(exception.startTime);
              const endDate = new Date(exception.endTime);

              if (!currentRange) {
                currentRange = {
                  startTime: startDate,
                  endTime: endDate,
                  originalException: exception
                };
              } else {
                // 현재 범위의 끝과 다음 예외의 시작이 연결되는지 확인
                if (currentRange.endTime.getTime() === startDate.getTime()) {
                  // 연속되므로 끝시간을 확장
                  currentRange.endTime = endDate;
                } else {
                  // 연속되지 않으므로 현재 범위를 저장하고 새로운 범위 시작
                  mergedTimeRanges.push(currentRange);
                  currentRange = {
                    startTime: startDate,
                    endTime: endDate,
                    originalException: exception
                  };
                }
              }
            });

            if (currentRange) {
              mergedTimeRanges.push(currentRange);
            }

            // 병합된 시간대들을 roomException으로 변환
            mergedTimeRanges.forEach(range => {
              const startTimeStr = range.startTime.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
              const endTimeStr = range.endTime.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });

              syncedExceptions.push({
                type: 'date_specific',
                name: `${group.title} (${group.date} ${startTimeStr}~${endTimeStr}) (방장)`,
                startTime: startTimeStr,
                endTime: endTimeStr,
                startDate: range.startTime.toISOString(),
                endDate: range.endTime.toISOString(),
                isSynced: true
              });
            });
          });

          // personalTimes을 roomExceptions으로 변환
          (ownerScheduleData.personalTimes || []).forEach(personalTime => {
            // 반복 개인시간인 경우에만 처리
            if (personalTime.isRecurring !== false && personalTime.days && personalTime.days.length > 0) {
              personalTime.days.forEach(dayOfWeek => {
                // 데이터베이스 요일 시스템을 JavaScript 요일 시스템으로 변환
                const jsDay = dayOfWeek === 7 ? 0 : dayOfWeek;

                // 시간을 분으로 변환하여 자정 넘나드는지 확인
                const [startHour, startMin] = personalTime.startTime.split(':').map(Number);
                const [endHour, endMin] = personalTime.endTime.split(':').map(Number);
                const startMinutes = startHour * 60 + startMin;
                const endMinutes = endHour * 60 + endMin;

                if (endMinutes <= startMinutes) {
                  // 자정을 넘나드는 시간 (예: 23:00~07:00)
                  console.log(`🔍 ProfileTab - 자정 넘나드는 개인시간 분할: ${personalTime.startTime}~${personalTime.endTime}`);

                  // 밤 부분 (예: 23:00~23:50)
                  syncedExceptions.push({
                    type: 'daily_recurring',
                    name: `${personalTime.title || '개인시간'} (방장)`,
                    dayOfWeek: jsDay,
                    startTime: personalTime.startTime,
                    endTime: '23:50',
                    isPersonalTime: true,
                    isSynced: true
                  });

                  // 아침 부분 (예: 00:00~07:00)
                  syncedExceptions.push({
                    type: 'daily_recurring',
                    name: `${personalTime.title || '개인시간'} (방장)`,
                    dayOfWeek: jsDay,
                    startTime: '00:00',
                    endTime: personalTime.endTime,
                    isPersonalTime: true,
                    isSynced: true
                  });
                } else {
                  // 일반적인 하루 내 시간
                  syncedExceptions.push({
                    type: 'daily_recurring',
                    name: `${personalTime.title || '개인시간'} (방장)`,
                    dayOfWeek: jsDay,
                    startTime: personalTime.startTime,
                    endTime: personalTime.endTime,
                    isPersonalTime: true,
                    isSynced: true
                  });
                }
              });
            }
          });

          // 업데이트된 설정으로 방 업데이트
          const updatedSettings = {
            ...existingSettings,
            roomExceptions: [...nonSyncedExceptions, ...syncedExceptions]
          };

          console.log(`🔍 방 "${room.name}" 업데이트 시도 - syncedExceptions:`, {
            count: syncedExceptions.length,
            exceptions: syncedExceptions.map(ex => ({ name: ex.name, type: ex.type, dayOfWeek: ex.dayOfWeek }))
          });

          await coordinationService.updateRoom(room._id, {
            settings: updatedSettings
          });

          console.log(`✅ 방 "${room.name}" 설정이 업데이트되었습니다. (${syncedExceptions.length}개의 방장 시간표 예외 추가)`);

        } catch (roomErr) {
          console.error(`방 "${room.name}" 업데이트 실패:`, roomErr);
        }
      }

      if (ownerRooms.length > 0) {
        console.log(`총 ${ownerRooms.length}개의 방장 방 설정이 업데이트되었습니다.`);
      }

    } catch (err) {
      console.error('방장 방 설정 업데이트 중 오류:', err);
    }
  };

  const fetchSchedule = useCallback(async () => {
    try {
      setIsLoading(true);
      const data = await userService.getUserSchedule();


      setDefaultSchedule(data.defaultSchedule || []);
      setScheduleExceptions(data.scheduleExceptions || []);
      setPersonalTimes(data.personalTimes || []);

      setError(null);
    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchSchedule();
  }, [fetchSchedule]);

  // 편집 상태가 변경될 때 부모 컴포넌트에 알림
  useEffect(() => {
    if (onEditingChange) {
      onEditingChange(isEditing);
    }
  }, [isEditing, onEditingChange]);

  // calendarUpdate 이벤트 수신하여 스케줄 새로고침
  useEffect(() => {
    const handleCalendarUpdate = async (event) => {
      console.log('📅 [ProfileTab] calendarUpdate 이벤트 수신:', event.detail);

      // 범위 삭제인 경우
      if (event.detail && event.detail.type === 'delete_range') {
        console.log('🗑️ [ProfileTab] 범위 삭제 감지, 전체 새로고침');
        fetchSchedule();
        return;
      }

      // 반복 일정 추가인 경우
      if (event.detail && event.detail.isRecurring && event.detail.context === 'profile') {
        console.log('🔁 [ProfileTab] 반복 일정 추가 감지, 전체 새로고침');
        fetchSchedule();
        return;
      }

      // 챗봇에서 추가한 일정인 경우
      if (event.detail && event.detail.type === 'add' && event.detail.chatResponse && event.detail.data) {


        // 편집 모드이고 초기화 상태인 경우, 서버 응답의 기존 데이터를 무시하고
        // 챗봇이 방금 추가한 항목만 추가
        if (isEditing && wasCleared) {

          const { chatResponse } = event.detail;
          
          // 챗봇이 추가한 새 항목은 scheduleExceptions에 추가 (불가능한 시간)
          if (chatResponse.startDateTime && chatResponse.endDateTime) {
            const startDateTime = new Date(chatResponse.startDateTime);
            const endDateTime = new Date(chatResponse.endDateTime);
            
            const koreaDateTime = new Date(startDateTime.toLocaleString("en-US", {timeZone: "Asia/Seoul"}));
            const localYear = koreaDateTime.getFullYear();
            const localMonth = String(koreaDateTime.getMonth() + 1).padStart(2, '0');
            const localDay = String(koreaDateTime.getDate()).padStart(2, '0');
            const localDate = `${localYear}-${localMonth}-${localDay}`;
            
            // 챗봇으로 추가한 일정은 personalTimes(개인시간)에 추가
            const newPersonalTime = {
              id: `temp_${Date.now()}`,
              title: chatResponse.title || '챗봇 일정',
              type: 'event',
              startTime: `${String(startDateTime.getHours()).padStart(2, '0')}:${String(startDateTime.getMinutes()).padStart(2, '0')}`,
              endTime: `${String(endDateTime.getHours()).padStart(2, '0')}:${String(endDateTime.getMinutes()).padStart(2, '0')}`,
              days: [],
              isRecurring: false,
              specificDate: localDate,
              color: '#ef4444' // 빨간색
            };
            
            // personalTimes에 새 항목만 추가 (서버 데이터 무시)
            setPersonalTimes(prev => [...prev, newPersonalTime]);
          }
        } else {
          // 일반적인 경우: 서버 응답 데이터로 직접 업데이트
          const { data } = event.detail;
          
          if (data.personalTimes) {
            setPersonalTimes([...data.personalTimes]);
          }
          
          if (data.scheduleExceptions) {
            setScheduleExceptions(data.scheduleExceptions);
          }
          
          if (data.defaultSchedule) {
            setDefaultSchedule(data.defaultSchedule);
          }
        }
      } else if (!isEditing) {
        // 편집 모드가 아니고 일반 이벤트인 경우 전체 새로고침

        fetchSchedule();
      }
    };

    window.addEventListener('calendarUpdate', handleCalendarUpdate);
    return () => {
      window.removeEventListener('calendarUpdate', handleCalendarUpdate);
    };
  }, [fetchSchedule, isEditing]);


  // 편집 모드 진입 추적
  const [editingStarted, setEditingStarted] = useState(false);
  const [justCancelled, setJustCancelled] = useState(false);
  const [wasCleared, setWasCleared] = useState(false);

  useEffect(() => {
    if (isEditing && !editingStarted) {
      setEditingStarted(true);
    } else if (!isEditing) {
      setEditingStarted(false);
    }
  }, [isEditing]);

  const handleSave = async () => {
    // defaultSchedule은 그대로 저장 (specificDate 포함)
    const scheduleToSave = defaultSchedule.map(s => ({
      dayOfWeek: s.dayOfWeek,
      startTime: s.startTime,
      endTime: s.endTime,
      priority: s.priority || 2,
      specificDate: s.specificDate
    }));

    // scheduleExceptions도 그대로 저장
    const exceptionsToSave = scheduleExceptions.map(
      ({ title, startTime, endTime, isHoliday, isAllDay, _id, specificDate, priority }) =>
      ({ title, startTime, endTime, isHoliday, isAllDay, _id, specificDate, priority })
    );

    const personalTimesToSave = personalTimes.map(
      ({ title, type, startTime, endTime, days, isRecurring, id, specificDate, color }) => {
        return { title, type, startTime, endTime, days, isRecurring, id, specificDate, color };
      }
    );

    try {
        console.log('💾 [저장] defaultSchedule:', scheduleToSave.length, '개 | exceptions:', exceptionsToSave.length, '개');

        await userService.updateUserSchedule({
          defaultSchedule: scheduleToSave,
          scheduleExceptions: exceptionsToSave,
          personalTimes: personalTimesToSave
        });
        showAlert('기본 시간표, 예외 일정 및 개인 시간이 저장되었습니다!', '저장 완료');
        setIsEditing(false);

        // 저장 후 서버에서 최신 데이터 동기화
        const freshData = await userService.getUserSchedule();

        console.log('🔍 [ProfileTab] 서버에서 받은 최신 데이터:', {
          defaultScheduleCount: freshData.defaultSchedule?.length || 0,
          defaultScheduleSample: freshData.defaultSchedule?.slice(0, 3),
          defaultScheduleWithSpecificDate: freshData.defaultSchedule?.filter(s => s.specificDate).slice(0, 3),
          exceptionsCount: freshData.scheduleExceptions?.length || 0,
          personalTimesCount: freshData.personalTimes?.length || 0,
          personalTimesSample: freshData.personalTimes?.slice(0, 2)
        });

        // UI 깜박임 방지: 데이터가 실제로 변경된 경우만 상태 업데이트
        if (JSON.stringify(freshData.defaultSchedule || []) !== JSON.stringify(defaultSchedule)) {
          setDefaultSchedule(freshData.defaultSchedule || []);
        }
        if (JSON.stringify(freshData.scheduleExceptions || []) !== JSON.stringify(scheduleExceptions)) {
          setScheduleExceptions(freshData.scheduleExceptions || []);
        }
        if (JSON.stringify(freshData.personalTimes || []) !== JSON.stringify(personalTimes)) {
          setPersonalTimes(freshData.personalTimes || []);
        }

        // CalendarView 강제 리렌더링
        window.dispatchEvent(new Event('calendarUpdate'));

        // 방장 방 자동 동기화는 제거 - 수동 동기화 버튼으로만 가능
    } catch (err) {
        setError(err.message);
        showAlert('저장에 실패했습니다: ' + err.message, '오류');
    }
  };

  const handleCancel = async () => {
    // 편집 모드 진입 시 저장된 초기 상태로 복원
    setDefaultSchedule([...initialState.defaultSchedule]);
    setScheduleExceptions([...initialState.scheduleExceptions]);
    setPersonalTimes([...initialState.personalTimes]);

    try {
      // 서버에도 초기 상태로 복원
      const exceptionsToRestore = initialState.scheduleExceptions.map(
        ({ title, startTime, endTime, isHoliday, isAllDay, _id, specificDate, priority }) =>
        ({ title, startTime, endTime, isHoliday, isAllDay, _id, specificDate, priority })
      );
      const personalTimesToRestore = initialState.personalTimes.map(
        ({ title, type, startTime, endTime, days, isRecurring, id, specificDate, color }) => {
          return { title, type, startTime, endTime, days, isRecurring, id, specificDate, color };
        }
      );

      await userService.updateUserSchedule({
        defaultSchedule: initialState.defaultSchedule,
        scheduleExceptions: exceptionsToRestore,
        personalTimes: personalTimesToRestore
      });
    } catch (err) {
      // 서버 복원 실패해도 UI는 복원된 상태로 유지
    }

    setIsEditing(false);
    setWasCleared(false); // 초기화 상태도 리셋
    setJustCancelled(true);

    // 일정 시간 후 취소 상태 해제
    setTimeout(() => {
      setJustCancelled(false);
    }, 1000);
  };

  const handleRemoveException = (exceptionId) => {
    if (!isEditing) return;
    setScheduleExceptions(prev => prev.filter(ex => ex._id !== exceptionId));
  };

  const handleDateClick = (date) => {
    setSelectedDate(date);
    setShowDetailGrid(true);
  };

  const autoSave = async () => {
    // 편집 모드이거나 방금 취소한 상태일 때는 자동 저장하지 않음
    if (isEditing || justCancelled) {
      return;
    }

    try {
      // defaultSchedule은 그대로 저장 (specificDate 포함)
      const scheduleToSave = defaultSchedule.map(s => ({
        dayOfWeek: s.dayOfWeek,
        startTime: s.startTime,
        endTime: s.endTime,
        priority: s.priority || 2,
        specificDate: s.specificDate
      }));

      const exceptionsToSave = scheduleExceptions.map(
        ({ title, startTime, endTime, isHoliday, isAllDay, _id, specificDate, priority }) =>
        ({ title, startTime, endTime, isHoliday, isAllDay, _id, specificDate, priority })
      );

      const personalTimesToSave = personalTimes.map(
        ({ title, type, startTime, endTime, days, isRecurring, id, specificDate, color }) => {
          return { title, type, startTime, endTime, days, isRecurring, id, specificDate, color };
        }
      );

      console.log('💾 [자동저장] defaultSchedule:', scheduleToSave.length, '개 | exceptions:', exceptionsToSave.length, '개');

      await userService.updateUserSchedule({
        defaultSchedule: scheduleToSave,
        scheduleExceptions: exceptionsToSave,
        personalTimes: personalTimesToSave
      });

    } catch (err) {
      console.error('🔍 [ProfileTab] autoSave 실패:', err);
    }
  };

  const handleCloseDetailGrid = () => {
    setShowDetailGrid(false);
    setSelectedDate(null);
  };

  if (isLoading) {
    return <div>로딩 중...</div>;
  }

  if (error) {
    return <div className="text-red-500">오류: {error}</div>;
  }

