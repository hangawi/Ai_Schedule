# AI 일정 조율 시스템 - 코드 점검 보고서
**작성일:** 2026-01-27
**점검 범위:** 전체 AI 일정 분석 및 제안 관리 시스템

---

## 1. 핵심 설계 철학

### ✅ LLM 중심 설계 (하드코딩 최소화)
- **날짜 계산**: LLM이 "금요일", "다음주 월요일" 등을 직접 계산
- **시간 해석**: LLM이 맥락으로 "6시 밥" → 18:00 판단
- **합의 감지**: LLM이 대화 흐름으로 자연스럽게 판단
- **프롬프트 언어**: 한국어로 작성하여 문화적 맥락 전달 강화

### ✅ Few-Shot Learning 활용
- 10가지 실제 대화 예시 제공
- 패턴 학습을 통한 자연스러운 이해
- 긍정/부정 사례 모두 포함

---

## 2. 파일별 점검 결과

### 📄 server/prompts/scheduleAnalysis.js
**상태:** ✅ 완전히 재작성 완료

**주요 개선사항:**
- 영어 → 한국어로 전환
- 하드코딩 규칙 제거
- LLM 자율 판단 강화
- 10가지 Few-shot 예시 추가

**프롬프트 구조:**
```
1. 역할 정의: "한국어 그룹 채팅 일정 판단 전문 AI"
2. 현재 컨텍스트: 오늘 날짜 (YYYY년 M월 D일, 요일)
3. 분석 대화: {실제 채팅 내용}
4. 합의 판단 기준: 자연어로 설명
5. 한국어 시간 표현 이해: 맥락 중심
6. 10가지 예시: 다양한 상황 커버
7. 출력 형식: JSON
8. 최종 지시: LLM에게 신뢰와 자율성 부여
```

**핵심 원칙:**
```javascript
// ❌ 하드코딩 (이전 방식)
if (dayOfWeek === '금요일' && currentDay <= fridayOfWeek) {
  return thisWeekFriday;
} else {
  return nextWeekFriday;
}

// ✅ LLM 판단 (현재 방식)
"금요일" → LLM이 오늘 날짜 기준으로 가장 가까운 금요일 계산
"6시 밥" → LLM이 맥락상 저녁 18:00로 판단
```

---

### 📄 server/services/aiScheduleService.js
**상태:** ✅ 적절함 (형식 검증 유지)

**검증 로직:**
```javascript
// ✅ 필수 안전장치 (유지)
1. 날짜 형식 검증: /^\d{4}-\d{2}-\d{2}$/ (YYYY-MM-DD)
2. 시간 형식 검증: /^\d{2}:\d{2}$/ (HH:MM)
3. 과거 날짜 경고: console.warn (거부 안 함)
```

**왜 유지해야 하나?**
- LLM이 가끔 실수할 수 있음 (JSON 형식 오류)
- 형식 검증 ≠ 하드코딩 (안전장치)
- 실제 날짜/시간 계산은 LLM이 함

**프로세스:**
```
1. 대화 20개 불러오기
2. LLM에게 프롬프트 전송
3. JSON 파싱
4. 형식 검증 (안전장치)
5. ScheduleSuggestion DB 저장
6. Socket으로 클라이언트에 전송
```

---

### 📄 server/services/preferenceService.js
**상태:** ✅ 적절함 (비즈니스 로직)

**충돌 체크 로직:**
```javascript
// ✅ 비즈니스 로직 (하드코딩 아님)
1. Room.timeSlots 확인 (확정된 그룹 일정)
2. personalTimes.specificDate 확인 (개인 약속)
3. 시간 겹침 계산: isTimeOverlap()
```

**제외되는 것:**
- ❌ defaultSchedule (선호시간) - 친구 약속에서는 무의미
- ❌ scheduleExceptions (예외사항)
- ❌ 반복 일정 (isRecurring=true)

**시간 겹침 계산:**
```javascript
function isTimeOverlap(start1, end1, start2, end2) {
  const s1 = timeToMinutes(start1);  // "09:00" → 540분
  const e1 = timeToMinutes(end1);
  const s2 = timeToMinutes(start2);
  const e2 = timeToMinutes(end2);

  // 겹치지 않는 경우의 부정 = 겹치는 경우
  return !(e1 <= s2 || e2 <= s1);
}
```

---

### 📄 server/controllers/chatController.js
**상태:** ✅ 적절함 (API 로직)

**주요 API:**
```javascript
// 1. 제안 조회
GET /api/chat/:roomId/suggestions?status=future|today|past

// 2. 제안 수락
POST /api/chat/:roomId/suggestions/:suggestionId/accept
→ personalTimes에 추가
→ suggestion.acceptByUser(userId)
→ Socket 'suggestion-updated' 이벤트

// 3. 제안 거절
POST /api/chat/:roomId/suggestions/:suggestionId/reject
→ RejectedSuggestion 저장 (중복 제안 방지)
→ Socket 'suggestion-updated' 이벤트
```

**Socket 이벤트 구조:**
```javascript
{
  suggestionId: "...",
  userId: "...",
  status: "accepted" | "rejected",
  memberResponses: [...] // 실시간 업데이트용
}
```

---

### 📄 client/src/components/chat/SuggestionModal.js
**상태:** ✅ 적절함 (UI 로직)

**기능:**
- 3개 탭: 미래/오늘/지난 약속
- 멤버별 응답 상태 표시
- 개인별 참석/불참 버튼
- 실시간 업데이트 (Socket.io)

**Socket 구독:**
```javascript
socket.on('suggestion-updated', (data) => {
  // suggestionId 찾아서 memberResponses 업데이트
  setSuggestions(prev => {
    const updated = { ...prev };
    // 해당 제안 찾아서 실시간 반영
    return updated;
  });
});
```

---

### 📄 server/models/ScheduleSuggestion.js
**상태:** ✅ 적절함 (DB 모델)

**스키마 구조:**
```javascript
{
  room: ObjectId,
  summary: String,     // "밥약속", "회의" 등
  date: String,        // "2026-01-31"
  startTime: String,   // "18:00"
  endTime: String,     // "19:00"
  location: String,

  memberResponses: [{
    user: ObjectId,
    status: "pending" | "accepted" | "rejected",
    respondedAt: Date,
    personalTimeId: Number  // 수락 시 추가된 일정 ID
  }],

  status: "future" | "today" | "past",  // 자동 업데이트
  suggestedAt: Date,
  aiResponse: Mixed  // 원본 LLM 응답 (디버깅용)
}
```

**주요 메서드:**
```javascript
.updateStatus()              // 시간 경과 시 자동 상태 변경
.getUserResponse(userId)     // 특정 사용자 응답 조회
.acceptByUser(userId, ptId)  // 사용자 수락
.rejectByUser(userId)        // 사용자 거절
.getResponseStats()          // 응답 통계
```

---

## 3. 전체 플로우

### 📊 일정 제안 생성 플로우
```
[사용자 채팅]
    ↓
[chatController.sendMessage]
    ↓ (비동기)
[aiScheduleService.analyzeConversation]
    ↓
[최근 20개 메시지 조회]
    ↓
[Gemini API 호출 - 한국어 프롬프트]
    ↓
[LLM 분석 결과]
    ↓
[형식 검증 (안전장치)]
    ↓
[ScheduleSuggestion DB 저장]
    ↓
[Socket 'schedule-suggestion' 이벤트]
    ↓
[클라이언트 제안 카드 표시]
```

### 📊 개인별 응답 플로우
```
[사용자가 [참석] 클릭]
    ↓
[SuggestionModal.handleAccept]
    ↓
[POST /api/chat/:roomId/suggestions/:id/accept]
    ↓
[chatController.acceptSuggestion]
    ↓
[user.personalTimes에 일정 추가]
    ↓
[suggestion.acceptByUser(userId, ptId)]
    ↓
[시스템 메시지 생성: "✅ OOO님이 수락"]
    ↓
[Socket 'suggestion-updated' 이벤트]
    ↓
[모든 클라이언트 실시간 업데이트]
```

---

## 4. LLM vs 하드코딩 비교

| 항목 | 이전 (하드코딩) | 현재 (LLM 판단) |
|------|----------------|----------------|
| 날짜 계산 | JS로 thisWeek/nextWeek 계산 | LLM이 자연어로 판단 |
| 시간 해석 | if문으로 "6시" = 18:00 규칙 | LLM이 맥락으로 판단 |
| 합의 감지 | 특정 키워드 매칭 | LLM이 대화 흐름 이해 |
| 프롬프트 | 영어 + 복잡한 규칙 | 한국어 + 간단한 가이드 |
| 예시 | 7개 | 10개 (다양한 케이스) |

**결과:**
- 🎯 더 자연스러운 이해
- 🎯 엣지 케이스 처리 개선
- 🎯 문화적 맥락 반영
- 🎯 유지보수 용이

---

## 5. 최종 점검 체크리스트

### ✅ 완료된 항목
- [x] LLM 프롬프트 한국어로 전환
- [x] 하드코딩 규칙 제거
- [x] Few-shot learning 예시 10개 추가
- [x] 날짜/시간 계산 LLM에게 위임
- [x] 맥락 기반 시간 해석 (6시 밥 = 18:00)
- [x] 합의 감지 자연어 이해
- [x] 형식 검증 유지 (안전장치)
- [x] 충돌 체크 로직 (비즈니스 로직)
- [x] 실시간 Socket 업데이트
- [x] 개인별 참석/불참 시스템
- [x] DB 모델 및 API 구조

### ⚠️ 주의사항
- 형식 검증은 **안전장치**이므로 유지
- 시간 겹침 계산은 **비즈니스 로직**이므로 유지
- LLM이 실수할 수 있으니 로그 모니터링 필요

### 🔮 향후 개선 가능 항목
1. **LLM 응답 품질 모니터링**
   - 잘못된 날짜 계산 로그 수집
   - 오판 사례 분석 및 프롬프트 개선

2. **프롬프트 A/B 테스팅**
   - 다양한 프롬프트 버전 비교
   - 정확도 측정

3. **다국어 지원**
   - 영어권 사용자용 프롬프트
   - 언어 자동 감지

4. **고급 기능**
   - 시간대(timezone) 지원
   - 반복 일정 제안
   - 선호 시간 힌트 제공 (선택적)

---

## 6. 결론

### 🎉 달성한 목표
1. **하드코딩 최소화**: 날짜/시간 계산을 LLM에게 완전히 위임
2. **자연어 이해 강화**: 한국어 프롬프트로 문화적 맥락 전달
3. **Few-shot Learning**: 10가지 예시로 다양한 상황 커버
4. **안전장치 유지**: 형식 검증으로 LLM 오류 방지
5. **완전한 시스템**: 제안 생성 → 저장 → 응답 → 실시간 업데이트

### 📝 핵심 교훈
> **"LLM을 믿어라. 규칙을 주지 말고 예시를 줘라."**

- LLM은 패턴 인식에 뛰어남
- 하드코딩된 규칙보다 Few-shot 예시가 효과적
- 한국어 프롬프트 = 한국어 대화 분석에 최적
- 안전장치는 필요하지만 핵심 로직은 LLM에게

### ✨ 최종 평가
**시스템 상태: 프로덕션 준비 완료** ✅

모든 핵심 기능이 구현되었고, 하드코딩은 최소화되었으며,
LLM의 자연어 이해 능력을 최대한 활용하는 구조로 설계됨.
