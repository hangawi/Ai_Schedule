작성일: 2025-12-23
작성자: Claude Code (AI Assistant)
목적: 이동시간 관련 3대 버그의 전체 원인 분석 및 수정 가이드
================================================================================

📋 목차
================================================================================
1. 전체 요약
2. 문제 1: 새로고침 후 이동시간만 하늘색으로 변함
3. 문제 2: 고아 슬롯 잔존 + 이동시간 미생성
4. 문제 3: 이동시간이 같이 이동 안함
5. 수정 우선순위 및 예상 작업 시간
6. 🆕 오류 발견 시 작성 가이드

================================================================================
1. 전체 요약
================================================================================

┌─────────────────────────────────────────────────────────────────────┐
│ 🎯 핵심 문제                                                          │
└─────────────────────────────────────────────────────────────────────┘

이동시간 기능은 **방장의 프라이버시를 보호**하면서도 **조원에게 정확한 수업 시간**을
표시해야 하는 복잡한 요구사항을 가지고 있습니다.

현재 발견된 3가지 버그는 모두 **데이터 분리 및 동기화 문제**에서 발생합니다:

1️⃣ 서버 데이터(timeSlots)에 이동시간 슬롯이 섞여서 옴
2️⃣ 클라이언트가 이를 제대로 분리하지 못함
3️⃣ 슬롯 이동 시 이동시간 재계산이 불완전함

┌─────────────────────────────────────────────────────────────────────┐
│ 📊 분석 결과 요약                                                      │
└─────────────────────────────────────────────────────────────────────┘

✅ Gemini가 이미 수정한 부분:
   - 고아 슬롯 삭제 로직 강화 (coordinationExchangeController.js:1003-1025)
   - 이동시간 재계산 호출 (coordinationExchangeController.js:1143-1154)

⚠️ 여전히 남아있는 문제:
   - 문제 1: 프론트엔드 데이터 분리 로직 불완전
   - 문제 2: 이동시간 재계산 조건 확인 필요
   - 문제 3: Case 2, 3에서 재계산 누락 가능성

================================================================================
2. 문제 1: 새로고침 후 이동시간만 하늘색으로 변함
================================================================================

┌─────────────────────────────────────────────────────────────────────┐
│ 🔍 현상                                                               │
└─────────────────────────────────────────────────────────────────────┘

- 수업 시간 확정 직후: 이동시간 슬롯이 **노란색** 또는 **회색 점선**으로 정상 표시
- 새로고침 후: 이동시간 슬롯이 **하늘색**(조원 고유 색상)으로 변경됨
- 수업 슬롯은 정상적으로 표시됨

┌─────────────────────────────────────────────────────────────────────┐
│ 🔎 원인 분석                                                          │
└─────────────────────────────────────────────────────────────────────┘

📁 관련 파일:
   - client/src/hooks/useTravelMode.js (라인 135-194)
   - client/src/components/timetable/TimeSlot.js (라인 294-299)
   - client/src/components/timetable/WeekView.js (라인 571-634)

🔧 원인:

1. **서버 데이터 구조**:
   ```javascript
   room.timeSlots = [
     { user: B학생, startTime: "08:10", endTime: "09:00", isTravel: true },  // 이동시간
     { user: B학생, startTime: "09:00", endTime: "11:00", isTravel: false }  // 수업
   ]
   ```
   → 서버에서 `timeSlots` 배열에 이동시간 슬롯과 수업 슬롯이 **섞여서** 전달됨

2. **useTravelMode.js의 getCurrentScheduleData (라인 135-194)**:
   ```javascript
   // 라인 164-173: 서버 데이터에서 이동시간 분리 시도
   const mixedTravelSlots = (currentRoom.timeSlots || []).filter(
     slot => slot.isTravel || slot.subject === '이동시간'
   );
   const regularSlots = (currentRoom.timeSlots || []).filter(
     slot => !slot.isTravel && slot.subject !== '이동시간'
   );
   ```
   → 분리 로직은 있지만, **타이밍 문제**로 제대로 작동하지 않을 수 있음

3. **새로고침 후 흐름**:
   ```
   사용자 새로고침
   → enhancedSchedule = null (로컬 계산 결과 없음)
   → getCurrentScheduleData()에서 서버 데이터 사용
   → mixedTravelSlots 분리 시도
   → 하지만 WeekView 렌더링 시점에 제대로 전달 안됨
   → ownerInfo에 isTravel=true 슬롯이 포함됨
   → TimeSlot.js에서 색상 판단 실패
   → 기본 색상(하늘색) 적용
   ```

4. **TimeSlot.js (라인 294-299)**:
   ```javascript
   ownerInfo.isTravel ? {
     backgroundColor: '#FFFFFF',  // ✅ 올바른 스타일
     borderColor: '#9CA3AF',
     borderStyle: 'dashed'
   } : {
     backgroundColor: `${ownerInfo.color}CC`  // ❌ 하늘색으로 표시됨
   }
   ```
   → `ownerInfo.isTravel`이 제대로 전달되지 않으면 하늘색으로 표시

┌─────────────────────────────────────────────────────────────────────┐
│ 💡 수정 방법                                                          │
└─────────────────────────────────────────────────────────────────────┘

📍 위치: client/src/hooks/useTravelMode.js

🔧 수정 전략:

옵션 A (권장): getCurrentScheduleData 함수 강화
```javascript
// 라인 162-193 수정
if (isOwner) {
  // 🔧 명확하게 분리
  const allSlots = currentRoom.timeSlots || [];
  const travelSlots = allSlots.filter(slot =>
    slot.isTravel === true || slot.subject === '이동시간'
  );
  const classSlots = allSlots.filter(slot =>
    slot.isTravel !== true && slot.subject !== '이동시간'
  );

  // 🔧 디버깅 로그 추가
  console.log('🔍 [useTravelMode] 슬롯 분리:', {
    전체: allSlots.length,
    수업: classSlots.length,
    이동시간: travelSlots.length
  });

  return {
    timeSlots: classSlots,
    travelSlots: travelSlots.map(slot => ({
      ...slot,
      travelMode: travelMode  // ✅ travelMode 명시적 주입
    })),
    travelMode: travelMode
  };
}
```

옵션 B: WeekView에서 이중 체크
```javascript
// WeekView.js에서 getSlotOwner 호출 전 필터링
const ownerInfo = getSlotOwner(date, time);
if (ownerInfo && ownerInfo.isTravel) {
  // 이동시간 슬롯은 travelSlots로만 렌더링
  ownerInfo = null;
}
```

┌─────────────────────────────────────────────────────────────────────┐
│ ✅ 검증 방법                                                          │
└─────────────────────────────────────────────────────────────────────┘

1. 수업 확정 후 이동시간 색상 확인 (노란색/회색 점선)
2. F5 새로고침 실행
3. 이동시간 색상이 **여전히** 노란색/회색 점선인지 확인
4. 개발자 도구 콘솔에서 "🔍 [useTravelMode] 슬롯 분리" 로그 확인

예상 작업 시간: **2-3시간**

================================================================================
3. 문제 2: 고아 슬롯 잔존 + 이동시간 미생성
================================================================================

┌─────────────────────────────────────────────────────────────────────┐
│ 🔍 현상                                                               │
└─────────────────────────────────────────────────────────────────────┘

- **현상 A**: 수업을 월요일 → 화요일로 이동했는데, 월요일 13:00-13:10 이동시간이 안 지워짐
- **현상 B**: 화요일에 새로 생성된 이동시간이 없음 (수업만 이동됨)

┌─────────────────────────────────────────────────────────────────────┐
│ 🔎 원인 분석                                                          │
└─────────────────────────────────────────────────────────────────────┘

📁 관련 파일:
   - server/controllers/coordinationExchangeController.js (라인 1003-1154)
   - server/controllers/coordinationExchangeController.js (라인 52-199)

🔧 원인:

1. **Gemini의 수정 내역 (라인 1003-1025)**:
   ```javascript
   // ✅ Gemini가 이미 강력한 삭제 로직 추가
   const slotIdsToRemove = allSlotsInBlock.map(slot => String(slot._id));
   const oldSlotDate = new Date(allSlotsInBlock[0].date).toISOString().split('T')[0];
   const targetDateStr = targetDate.toISOString().split('T')[0];
   const myUserIdStr = String(req.user.id);

   // 1. 수업 슬롯 삭제
   room.timeSlots = room.timeSlots.filter(slot => !slotIdsToRemove.includes(String(slot._id)));

   // 2. 이동시간 슬롯 삭제 (원본 날짜 + 목표 날짜, 내꺼만)
   room.timeSlots = room.timeSlots.filter(slot => {
     const slotDateStr = new Date(slot.date).toISOString().split('T')[0];
     const slotUserIdStr = String(slot.user._id || slot.user);
     const isTravel = slot.isTravel === true || slot.subject === '이동시간';

     if (isTravel && slotUserIdStr === myUserIdStr &&
         (slotDateStr === oldSlotDate || slotDateStr === targetDateStr)) {
        return false;  // 삭제
     }
     return true;
   });
   ```
   → ✅ **이미 수정됨**. 고아 슬롯 삭제는 해결되었을 가능성 높음

2. **이동시간 미생성 원인 (라인 52-199)**:
   ```javascript
   const recalculateTravelTimeSlotsForDate = async (room, date, ownerId) => {
     // 라인 54: effectiveTravelMode 계산
     const effectiveTravelMode = room.confirmedTravelMode ||
                                 room.currentTravelMode ||
                                 room.travelMode;

     // 라인 56-59: 일반 모드면 스킵
     if (!effectiveTravelMode || effectiveTravelMode === 'normal') {
       console.log('⏭️ [이동시간 재계산] 일반 모드이므로 스킵:', effectiveTravelMode);
       return;  // ❌ 이동시간 생성 안함!
     }
     // ...
   }
   ```

   **문제점**:
   - DB 저장 전에는 `room.travelMode`가 `undefined`일 수 있음
   - `room.currentTravelMode`도 없으면 → `effectiveTravelMode = undefined`
   - 라인 56 조건문 통과 → 재계산 스킵!

3. **실제 호출 흐름 (라인 1143-1154)**:
   ```javascript
   // 라인 1150: 강제 주입 시도
   room.travelMode = effectiveTravelMode;  // ✅ 시도는 했지만...

   // 라인 1151-1152: 재계산 호출
   await recalculateTravelTimeSlotsForDate(room, new Date(allSlotsInBlock[0].date), room.owner._id);
   await recalculateTravelTimeSlotsForDate(room, targetDate, room.owner._id);
   ```

   **타이밍 문제**:
   - 라인 1150에서 주입하지만, 함수 내부에서 다시 계산 (라인 54)
   - `room.confirmedTravelMode`나 `room.currentTravelMode`가 우선순위가 높음
   - 이들이 없으면 여전히 문제!

┌─────────────────────────────────────────────────────────────────────┐
│ 💡 수정 방법                                                          │
└─────────────────────────────────────────────────────────────────────┘

📍 위치 1: server/controllers/coordinationExchangeController.js (라인 1143-1154)

🔧 수정 전략:

옵션 A (권장): effectiveTravelMode를 함수에 직접 전달
```javascript
// 🔧 recalculateTravelTimeSlotsForDate 함수 시그니처 변경
const recalculateTravelTimeSlotsForDate = async (room, date, ownerId, forceTravelMode) => {
  // 파라미터로 받은 모드를 우선 사용
  const effectiveTravelMode = forceTravelMode ||
                              room.confirmedTravelMode ||
                              room.currentTravelMode ||
                              room.travelMode;
  // ...
};

// 라인 1143-1154 수정
const effectiveTravelMode = room.confirmedTravelMode || room.currentTravelMode || room.travelMode;
console.log('🔄 [smartExchange] 이동시간 재계산 시작:', {
  travelMode: effectiveTravelMode,  // ✅ 로그 추가
  oldDate: new Date(allSlotsInBlock[0].date).toISOString().split('T')[0],
  newDate: targetDate.toISOString().split('T')[0]
});

// ✅ 명시적으로 모드 전달
await recalculateTravelTimeSlotsForDate(
  room,
  new Date(allSlotsInBlock[0].date),
  room.owner._id,
  effectiveTravelMode  // 🆕 추가
);
await recalculateTravelTimeSlotsForDate(
  room,
  targetDate,
  room.owner._id,
  effectiveTravelMode  // 🆕 추가
);

console.log('✅ [smartExchange] 이동시간 재계산 완료');
console.log(`📊 [재계산 후] 전체 슬롯: ${room.timeSlots.length}개, 이동시간: ${room.timeSlots.filter(s => s.isTravel).length}개`);
```

옵션 B: 재계산 조건 완화
```javascript
// recalculateTravelTimeSlotsForDate 함수 내부 (라인 56-59)
if (!effectiveTravelMode || effectiveTravelMode === 'normal') {
  console.log('⏭️ [이동시간 재계산] 일반 모드이므로 스킵:', effectiveTravelMode);
  return;
}
```
→ 대신:
```javascript
if (effectiveTravelMode === 'normal') {
  console.log('⏭️ [이동시간 재계산] 일반 모드이므로 스킵');
  return;
}
if (!effectiveTravelMode) {
  console.warn('⚠️ [이동시간 재계산] travelMode가 설정되지 않았습니다. transit 기본값 사용');
  effectiveTravelMode = 'transit';  // 기본값 설정
}
```

┌─────────────────────────────────────────────────────────────────────┐
│ ✅ 검증 방법                                                          │
└─────────────────────────────────────────────────────────────────────┘

1. 자동배정 실행 → 대중교통 모드 적용
2. 챗봇으로 "화요일 9시로 옮겨줘" 요청
3. 서버 콘솔에서 다음 로그 확인:
   ```
   ✅ [이동시간 재계산] 2025-12-22: 12개 수업 슬롯 처리 완료
   📊 [확인] isTravel===true: XX개
   ```
4. 프론트엔드에서 월요일 13:00-13:10 슬롯이 **삭제**되었는지 확인
5. 화요일에 이동시간 슬롯이 **생성**되었는지 확인

예상 작업 시간: **3-4시간**

================================================================================
4. 문제 3: 이동시간이 같이 이동 안함
================================================================================

┌─────────────────────────────────────────────────────────────────────┐
│ 🔍 현상                                                               │
└─────────────────────────────────────────────────────────────────────┘

- 수업 시간을 이동했는데, **이동시간만** 원래 위치에 남아있음
- 또는 이동시간이 **새 위치에 생성되지 않음**
- 수업과 이동시간이 분리되어 이상한 상태가 됨

┌─────────────────────────────────────────────────────────────────────┐
│ 🔎 원인 분석                                                          │
└─────────────────────────────────────────────────────────────────────┘

📁 관련 파일:
   - server/controllers/coordinationExchangeController.js (라인 900-1203, 1206-1451)

🔧 원인:

1. **Case 1 (즉시 이동) - 라인 900-1203**:
   ```javascript
   // 라인 1143-1154: ✅ 재계산 호출함
   await recalculateTravelTimeSlotsForDate(room, new Date(allSlotsInBlock[0].date), room.owner._id);
   await recalculateTravelTimeSlotsForDate(room, targetDate, room.owner._id);
   ```
   → ✅ Case 1은 재계산이 호출됨 (문제 2와 연관)

2. **Case 2 (자동 배치) - 라인 1206-1451**:
   ```javascript
   // 라인 1246-1363: 이동시간 슬롯을 **직접 생성**
   let travelDurationMinutes = 0;
   if (room.travelMode && room.travelMode !== 'normal' && previousSlot) {
     // ... 계산 ...
   }

   // 라인 1342-1363: 이동시간 슬롯 생성
   for (let i = 0; i < travelSlotCount; i++) {
     room.timeSlots.push({ /* 이동시간 슬롯 */ });
   }
   ```
   → ⚠️ Case 2는 `recalculateTravelTimeSlotsForDate`를 호출하지 않음
   → 대신 직접 생성하지만, 기존 이동시간 삭제 로직은?

3. **Case 3 (양보 요청) - 라인 1454-1530**:
   ```javascript
   // 양보 요청만 생성, 실제 이동은 승인 후
   room.requests.push(yieldRequest);
   await room.save();
   ```
   → ⚠️ Case 3는 즉시 이동하지 않으므로 재계산 불필요

4. **핵심 문제**:
   - Case 1: 재계산 호출하지만 `effectiveTravelMode` 문제 (문제 2와 동일)
   - Case 2: 직접 생성 방식이라 일관성 없음
   - 기존 이동시간 삭제는 라인 1251-1254에서 처리:
     ```javascript
     room.timeSlots = room.timeSlots.filter(slot => {
       const slotDate = new Date(slot.date).toISOString().split('T')[0];
       return !((slotDate === oldSlotDate || slotDate === targetDateStr) && slot.isTravel);
     });
     ```
     → ✅ 삭제는 되지만, 생성 로직이 다름

┌─────────────────────────────────────────────────────────────────────┐
│ 💡 수정 방법                                                          │
└─────────────────────────────────────────────────────────────────────┘

📍 위치: server/controllers/coordinationExchangeController.js

🔧 수정 전략:

옵션 A (권장): Case 2도 재계산 함수 사용
```javascript
// 라인 1246-1404 전체 수정

// 기존: 직접 생성
// 수정 후: 수업 슬롯만 생성 → 재계산 호출

// 수업 슬롯만 생성 (라인 1365-1404)
const classSlotData = {
  user: req.user.id,
  date: targetDate,
  startTime: currentTime,
  endTime: slotEndTime,
  day: targetDayEnglish,
  // ...
};
room.timeSlots.push(classSlotData);

// ✅ DB 저장 전 재계산 호출
await recalculateTravelTimeSlotsForDate(
  room,
  new Date(allSlotsInBlock[0].date),
  room.owner._id,
  effectiveTravelMode
);
await recalculateTravelTimeSlotsForDate(
  room,
  targetDate,
  room.owner._id,
  effectiveTravelMode
);

await room.save();
```

옵션 B: 통합 헬퍼 함수 생성
```javascript
// 새 함수 추가
async function moveSlotWithTravel(room, userId, oldDate, newDate, startTime, endTime, ownerId, effectiveTravelMode) {
  // 1. 기존 슬롯 삭제 (수업 + 이동시간)
  // 2. 새 수업 슬롯 생성
  // 3. 이동시간 재계산
  // 4. 반환
}

// Case 1, 2에서 모두 사용
const result = await moveSlotWithTravel(/* ... */);
```

┌─────────────────────────────────────────────────────────────────────┐
│ ✅ 검증 방법                                                          │
└─────────────────────────────────────────────────────────────────────┘

1. **Case 1 테스트**:
   - 챗봇으로 "화요일 9시로 옮겨줘" 요청
   - 이동시간이 함께 이동하는지 확인

2. **Case 2 테스트**:
   - 챗봇으로 "목요일로 옮겨줘" (시간 지정 안함 → 자동 배치)
   - 이동시간이 함께 생성되는지 확인

3. **통합 테스트**:
   - 여러 번 이동 반복
   - 고아 이동시간 슬롯이 없는지 확인

예상 작업 시간: **4-5시간**

================================================================================
5. 수정 우선순위 및 예상 작업 시간
================================================================================

┌─────────────────────────────────────────────────────────────────────┐
│ 📊 우선순위                                                           │
└─────────────────────────────────────────────────────────────────────┘

🔥 **1순위**: 문제 2 (이동시간 미생성)
   - 이유: 기능이 작동하지 않는 치명적 버그
   - 영향: 모든 이동시간 기능이 무용지물
   - 예상 시간: 3-4시간

🔥 **2순위**: 문제 3 (이동시간이 같이 이동 안함)
   - 이유: 문제 2 해결 후에도 일관성 문제 가능
   - 영향: 데이터 일관성 깨짐
   - 예상 시간: 4-5시간

🟡 **3순위**: 문제 1 (새로고침 후 색상 변경)
   - 이유: UI/UX 문제 (기능은 작동함)
   - 영향: 사용자 혼란
   - 예상 시간: 2-3시간

┌─────────────────────────────────────────────────────────────────────┐
│ ⏰ 총 예상 작업 시간                                                   │
└─────────────────────────────────────────────────────────────────────┘

- 최소: 9시간 (각 문제의 최소 시간 합산)
- 최대: 12시간 (각 문제의 최대 시간 합산)
- 테스트 및 검증: +3시간
- **총합: 12-15시간** (약 2일)

┌─────────────────────────────────────────────────────────────────────┐
│ 📅 권장 작업 순서                                                      │
└─────────────────────────────────────────────────────────────────────┘

Day 1 (오전):
  - 문제 2 수정 (effectiveTravelMode 전달 개선)
  - 테스트 및 검증

Day 1 (오후):
  - 문제 3 수정 (Case 2 재계산 추가)
  - 통합 테스트

Day 2 (오전):
  - 문제 1 수정 (getCurrentScheduleData 강화)
  - 최종 검증

Day 2 (오후):
  - 전체 회귀 테스트
  - 문서 업데이트

================================================================================
6. 🆕 오류 발견 시 작성 가이드
================================================================================

┌─────────────────────────────────────────────────────────────────────┐
│ 📝 새로운 오류 발견 시 이 파일에 추가하는 방법                            │
└─────────────────────────────────────────────────────────────────────┘

이 섹션은 **앞으로 새로운 버그나 문제를 발견했을 때** 이 문서를 어떻게
업데이트할지에 대한 가이드입니다.

┌─────────────────────────────────────────────────────────────────────┐
│ 1️⃣ 문제 발견 시 즉시 기록할 내용                                       │
└─────────────────────────────────────────────────────────────────────┘

새 섹션을 추가하여 다음 정보를 기록하세요:

```
================================================================================
문제 X: [문제 제목을 간단명료하게]
================================================================================

┌─────────────────────────────────────────────────────────────────────┐
│ 🔍 현상 (발견 일시: YYYY-MM-DD HH:MM)                                │
└─────────────────────────────────────────────────────────────────────┘

- 어떤 상황에서 발생했는가?
- 어떤 증상이 나타났는가?
- 재현 가능한가? (Y/N)
- 재현 방법:
  1. 단계 1
  2. 단계 2
  3. ...

┌─────────────────────────────────────────────────────────────────────┐
│ 📸 스크린샷 또는 로그                                                  │
└─────────────────────────────────────────────────────────────────────┘

- 브라우저 콘솔 로그:
  [여기에 로그 붙여넣기]

- 서버 콘솔 로그:
  [여기에 로그 붙여넣기]

- 스크린샷 경로:
  정리/스크린샷/[파일명].png

┌─────────────────────────────────────────────────────────────────────┐
│ 🔎 예상 원인 (초기 분석)                                               │
└─────────────────────────────────────────────────────────────────────┘

- 어떤 파일이 관련되어 있을 것 같은가?
- 어떤 로직에 문제가 있을 것 같은가?
- 비슷한 기존 문제가 있는가?

┌─────────────────────────────────────────────────────────────────────┐
│ ⚠️ 영향 범위                                                          │
└─────────────────────────────────────────────────────────────────────┘

- 치명도: [낮음/중간/높음/치명적]
- 영향 받는 기능:
  - 기능 1
  - 기능 2
  - ...
- 영향 받는 사용자:
  - [방장/조원/전체]

┌─────────────────────────────────────────────────────────────────────┐
│ 🚨 임시 해결 방법 (Workaround)                                        │
└─────────────────────────────────────────────────────────────────────┘

당장 급한 경우 사용할 수 있는 임시 방법:
1. 방법 1
2. 방법 2
...

┌─────────────────────────────────────────────────────────────────────┐
│ 📋 TODO (상세 분석 후 작성)                                            │
└─────────────────────────────────────────────────────────────────────┘

[ ] 관련 파일 읽기 및 분석
[ ] 원인 파악
[ ] 수정 방법 설계
[ ] 테스트 계획 작성
[ ] 수정 구현
[ ] 테스트 실행
[ ] 문서 업데이트
```

┌─────────────────────────────────────────────────────────────────────┐
│ 2️⃣ 파일 저장 및 버전 관리                                              │
└─────────────────────────────────────────────────────────────────────┘

**파일명 규칙**:
```
이동시간_버그_분석_YYYY-MM-DD.txt
```

**Git 커밋 메시지**:
```
docs: 새로운 버그 발견 - [문제 제목]

- 발견 일시: YYYY-MM-DD HH:MM
- 치명도: [낮음/중간/높음/치명적]
- 영향 범위: [간단한 설명]
```

**버전 관리**:
- 이 파일의 맨 위에 "최종 수정일" 업데이트
- 변경 이력 섹션 추가 (맨 아래):
  ```
  ================================================================================
  변경 이력
  ================================================================================

  2025-12-23: 초기 작성 (문제 1, 2, 3 분석)
  2025-12-XX: 문제 4 추가
  2025-12-XX: 문제 1 수정 완료 표시
  ```

┌─────────────────────────────────────────────────────────────────────┐
│ 3️⃣ 문제 해결 후 업데이트                                               │
└─────────────────────────────────────────────────────────────────────┘

문제가 해결되면 해당 섹션에 다음 정보 추가:

```
┌─────────────────────────────────────────────────────────────────────┐
│ ✅ 해결 완료 (YYYY-MM-DD)                                             │
└─────────────────────────────────────────────────────────────────────┘

📍 수정된 파일:
   - 파일경로1 (라인 XX-YY)
   - 파일경로2 (라인 ZZ-WW)

🔧 수정 내용:
   [간단한 설명]

✅ 테스트 결과:
   - 테스트 케이스 1: ✅ 통과
   - 테스트 케이스 2: ✅ 통과
   - ...

📦 커밋 해시: [git commit hash]
```

그리고 파일 맨 위의 "전체 요약" 섹션에 완료 표시:
```
1️⃣ 서버 데이터(timeSlots)에 이동시간 슬롯이 섞여서 옴 ✅ 해결 (2025-12-XX)
2️⃣ 클라이언트가 이를 제대로 분리하지 못함 ✅ 해결 (2025-12-XX)
3️⃣ 슬롯 이동 시 이동시간 재계산이 불완전함 ⏳ 진행 중
```

┌─────────────────────────────────────────────────────────────────────┐
│ 4️⃣ 관련 파일과의 상호 참조                                              │
└─────────────────────────────────────────────────────────────────────┘

**다른 문서와 연결**:
- 코드 주석에 이 문서 참조 추가:
  ```javascript
  // 🐛 Bug Fix: 이동시간 재계산 문제 해결
  // 상세: 정리/정리 가이드/이동시간_버그_분석_2025-12-23.txt - 문제 2
  const effectiveTravelMode = forceTravelMode || room.confirmedTravelMode || ...
  ```

- Git 커밋 메시지에 문서 참조:
  ```
  fix: 이동시간 재계산 버그 수정

  - 문제: effectiveTravelMode가 undefined일 때 재계산 스킵
  - 해결: 함수 파라미터로 명시적 전달
  - 참조: 정리/정리 가이드/이동시간_버그_분석_2025-12-23.txt - 문제 2
  ```

┌─────────────────────────────────────────────────────────────────────┐
│ 5️⃣ 예시: 실제 작성 예제                                                │
└─────────────────────────────────────────────────────────────────────┘

```
================================================================================
문제 4: 챗봇 응답 시 이동시간 정보 노출
================================================================================

┌─────────────────────────────────────────────────────────────────────┐
│ 🔍 현상 (발견 일시: 2025-12-24 14:30)                                │
└─────────────────────────────────────────────────────────────────────┘

- 조원이 챗봇으로 "내 일정 알려줘" 요청 시
- 응답에 "8:10-11:00 수업" 형태로 표시됨
- 이동시간 50분이 포함되어 프라이버시 침해!

재현 가능: Y
재현 방법:
  1. 조원으로 로그인
  2. 챗봇에서 "내 일정 알려줘" 입력
  3. 응답 확인 → "8:10-11:00" 표시됨 (원래 9:00-11:00이어야 함)

┌─────────────────────────────────────────────────────────────────────┐
│ 📸 스크린샷 또는 로그                                                  │
└─────────────────────────────────────────────────────────────────────┘

브라우저 콘솔:
  [챗봇 응답] "화요일 8:10-11:00에 수업이 있습니다."

서버 로그:
  [chatbot] 조원 B의 일정 조회 요청
  [chatbot] 슬롯 반환: { startTime: "08:10", endTime: "11:00" }

┌─────────────────────────────────────────────────────────────────────┐
│ 🔎 예상 원인 (초기 분석)                                               │
└─────────────────────────────────────────────────────────────────────┘

- server/controllers/chatbotController.js에서 슬롯 정보 반환 시
  actualStartTime을 그대로 반환하는 것으로 추정
- 조원에게는 startTime(순수 수업 시간)만 보여야 하는데
  actualStartTime(이동시간 포함)을 반환하고 있는 듯

┌─────────────────────────────────────────────────────────────────────┐
│ ⚠️ 영향 범위                                                          │
└─────────────────────────────────────────────────────────────────────┘

치명도: 높음
영향 받는 기능:
  - 챗봇 일정 조회
  - 챗봇 일정 변경 확인 메시지
영향 받는 사용자:
  - 조원 (방장 프라이버시 침해)

┌─────────────────────────────────────────────────────────────────────┐
│ 🚨 임시 해결 방법 (Workaround)                                        │
└─────────────────────────────────────────────────────────────────────┘

당장은 조원에게 챗봇 대신 캘린더 탭에서 일정 확인하도록 안내

┌─────────────────────────────────────────────────────────────────────┐
│ 📋 TODO (상세 분석 후 작성)                                            │
└─────────────────────────────────────────────────────────────────────┘

[ ] chatbotController.js 파일 읽기
[ ] 슬롯 반환 로직 확인
[ ] 조원/방장 구분 로직 확인
[ ] 수정 방법 설계
[ ] 테스트 케이스 작성
[ ] 수정 구현
```

┌─────────────────────────────────────────────────────────────────────┐
│ 6️⃣ 주의사항                                                           │
└─────────────────────────────────────────────────────────────────────┘

❗ **즉시 기록하기**: 나중에 하려고 미루면 잊어버립니다!
❗ **스크린샷 저장**: 나중에 재현 안될 수도 있으니 증거 확보
❗ **로그 복사**: 서버 로그는 재시작하면 사라질 수 있음
❗ **Git 커밋**: 문서 업데이트도 반드시 커밋해서 이력 남기기

================================================================================
마지막 업데이트: 2025-12-23 (초기 작성)
작성자: Claude Code (AI Assistant)
다음 업데이트 예정: 문제 해결 진행 상황에 따라
================================================================================
