=== 5시간 배정 시 수업 시간 손실 문제 ===

## 현재 상황

### 일반 보기 (5시간 배정)
- A(이이 이): 월 9-10 + 13-17 (1시간 + 4시간 = 5시간) ✓
- B(삼삼 삼): 월 10-11 + 화 13-17 (1시간 + 4시간 = 5시간) ✓

### 대중교통 보기 (문제 발생)
- A(이이 이): 월 9-10(이동) + 10-11(수업) + 13-17(수업) = 5시간 ✓
- B(삼삼 삼): 화 9-10:10(이동) + 10:10-12(수업) + 13-15:10(수업) = **4시간** ❌

**B가 1시간(60분) 부족!**
- 10:10-12 = 110분
- 13-15:10 = 130분
- 총 240분 = 4시간 (원래 300분 = 5시간이어야 함)

## 문제 원인 분석

### 처리 순서와 문제점

```
1. A 월 9-10 처리
   - 첫 배정, 방장에서 출발
   - 이동: 9:00-10:00 (60분)
   - 수업: 10:00-11:00 (60분)
   - assignedSlotsByDate["월"] = [A 9:00-11:00]
   ✅ 성공

2. B 월 10-11 처리 ← 여기서 문제!
   - assignedSlotsByDate["월"]에 A가 9:00-11:00에 있음
   - B의 원래 시작: 10:00
   - 이전 슬롯(A) 종료: 11:00
   - newTravelStartMinutes = Math.max(10:00, 11:00) = 11:00
   - 이동: 11:00-12:10 (70분)
   - 수업: 12:10-13:10 (60분)
   - 12:00-13:00 점심시간(금지시간) 침범 가능성
   - 또는 A 월 13-17과 겹침
   - ⚠️ 재배정 필요 (60분만 재배정 시도)
   - 재배정 실패 → **슬롯 손실!** ❌

3. A 월 13-17 처리
   - assignedSlotsByDate["월"]에 A가 9:00-11:00에 있음
   - 같은 사용자의 이전 슬롯
   - 이동시간: A → A = 0분
   - 수업: 13:00-17:00 (240분) 그대로
   ✅ 성공

4. B 화 13-17 처리
   - 방장에서 출발
   - 이동: 13:00-14:10 (70분)
   - 수업: 14:10-18:10 (240분)
   - 선호시간 초과: 18:10 > 17:00
   - ⚠️ 재배정 필요 (240분만 재배정)
   - 재배정 성공: 화 9:00-12:00 + 13:00-15:10
   ✅ 성공 (하지만 240분만)
```

### 핵심 문제

**B의 두 슬롯(월 10-11, 화 13-17)이 독립적으로 처리됨**
- 월 10-11 (60분) → 재배정 실패 → **손실**
- 화 13-17 (240분) → 재배정 성공 → 배정됨
- 결과: 240분만 배정됨 (60분 손실)

**로그 증거:**
```
🔍 [findAvailableSlot] 시작: {userId: ..., 총수업시간: 240분}
```
→ 240분만 재배정하고 있음! (300분이어야 함)

## 왜 슬롯이 독립적으로 처리되는가?

### 현재 로직
```javascript
for (const mergedSlot of sortedMergedSlots) {
    // 각 슬롯을 개별적으로 처리
    // 이동시간 추가
    // 겹침/선호시간 체크
    // 재배정 필요 시 현재 슬롯만 재배정
}
```

**문제점:**
- 각 슬롯이 독립적으로 처리됨
- 재배정 시 같은 사용자의 다른 슬롯을 고려하지 않음
- 한 슬롯이 재배정 실패하면 그냥 손실됨

## 해결 방법 옵션

### 옵션 1: 재배정 실패 시 원본 유지
```javascript
if (!alternativePlacement.success) {
    // 재배정 실패 → 경고 출력하고 원본 그대로 추가
    console.warn(`⚠️ [재배정 실패] 원본 슬롯 유지 (겹침 발생 가능)`);
    allResultSlots.push(...this.unmergeBlock(mergedSlot));
}
```

**장점:**
- 간단한 수정
- 슬롯 손실 방지

**단점:**
- 겹침 발생 가능
- 사용자에게 혼란

### 옵션 2: 같은 사용자의 슬롯 그룹화
```javascript
// 슬롯을 사용자별로 그룹화
const slotsByUser = groupSlotsByUser(sortedMergedSlots);

for (const [userId, userSlots] of slotsByUser) {
    // 사용자의 모든 슬롯을 함께 처리
    // 재배정 시 전체 수업 시간 고려
}
```

**장점:**
- 근본적인 해결
- 슬롯 손실 방지
- 더 나은 재배정

**단점:**
- 복잡한 수정
- 기존 로직 대폭 변경 필요

### 옵션 3: 재배정 실패 슬롯 수집 후 재시도
```javascript
const failedSlots = [];

for (const mergedSlot of sortedMergedSlots) {
    // 재배정 실패 시
    if (!alternativePlacement.success) {
        failedSlots.push(mergedSlot);
    }
}

// 실패한 슬롯들을 사용자별로 그룹화하여 재시도
retryFailedSlots(failedSlots);
```

**장점:**
- 기존 로직 유지하면서 보완
- 슬롯 손실 방지

**단점:**
- 추가 로직 필요
- 여전히 복잡

## 추천 해결 방법

**단기: 옵션 1 (재배정 실패 시 원본 유지)**
- 빠른 수정
- 사용자에게 경고 표시
- 겹침은 UI에서 시각적으로 표시

**장기: 옵션 2 (사용자별 그룹화)**
- 더 나은 사용자 경험
- 근본적인 해결
- 시간이 걸림

## 필요한 로그 확인

B 월 10-11 슬롯 처리 시:
```
🔄 [슬롯 처리 중]: {날짜: '2025-12-15', 시간: '10:00-11:00', 사용자: '삼삼'}
⚠️ [재배정 필요] ...
🔍 [findAvailableSlot] 시작: {총수업시간: 60분}
⚠️ [한 블록 배치 실패] ...
🔄 [findAvailableSlotsWithSplit] 시작: {총수업시간: 60분}
❌ [배치 실패] ... 또는 ✅ [분할 배치 성공]
```

이 로그를 확인하면:
1. 재배정이 시도되었는지
2. 재배정이 성공/실패했는지
3. 실패 시 슬롯이 어떻게 처리되었는지

알 수 있습니다.

## 다음 단계

1. 사용자에게 B 월 10-11 처리 로그 요청
2. 로그 분석 후 정확한 원인 확인
3. 옵션 1로 빠른 수정 적용
4. 테스트 및 검증
