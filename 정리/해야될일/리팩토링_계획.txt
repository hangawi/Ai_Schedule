=== 5시간 배정 시 슬롯 손실 문제 - 리팩토링 계획 ===

## 문제 요약

**현상**: 5시간 배정 시 대중교통 보기에서 B(삼삼 삼) 학생이 4시간만 배정됨 (1시간 손실)

**원인**:
1. 클라이언트의 `recalculateScheduleWithTravel` 메서드에서 각 슬롯이 독립적으로 처리됨
2. 재배정 시 해당 슬롯의 시간만 재배정 시도 (같은 사용자의 다른 슬롯 미고려)
3. 재배정 실패 시 처리 방식의 문제

**영향 범위**:
- 파일: `client/src/services/travelScheduleCalculator.js`
- 메서드: `recalculateScheduleWithTravel` (701-1616줄)

---

## 현재 처리 흐름 분석

### 1단계: 서버 자동 배정
```
publicTransportAssignmentService.js
↓
각 요일별로 학생들을 거리 순으로 배정
↓
결과: B에게 월 10-11 (60분), 화 13-17 (240분) 배정
```

### 2단계: 클라이언트 대중교통 보기 처리
```
travelScheduleCalculator.js > recalculateScheduleWithTravel
↓
sortedMergedSlots 배열을 순회 (각 슬롯 독립 처리)
↓
for (const mergedSlot of sortedMergedSlots) {
    1. 이동시간 계산
    2. 선호시간 체크
    3. 겹침 체크
    4. 재배정 필요 시:
       - findAvailableSlot(현재 슬롯 시간만) ← 문제!
       - findAvailableSlotsWithSplit(현재 슬롯 시간만) ← 문제!
}
```

### 문제 발생 시나리오

**B 월 10-11 (60분) 처리**:
```
1. 원본: 월 10:00-11:00
2. A가 월 9:00-11:00에 있음 (이전에 배정됨)
3. 이동시간 추가 → 월 11:00-12:10 (이동) + 12:10-13:10 (수업)
4. 점심시간(12:00-13:00) 침범 또는 A 월 13-17과 겹침
5. 재배정 시도: findAvailableSlot(60분) → 실패
6. 재배정 시도: findAvailableSlotsWithSplit(60분) → 실패
7. ⚠️ 원본 유지 또는 조정된 시간 유지 → 60분 손실 가능성
```

**B 화 13-17 (240분) 처리**:
```
1. 원본: 화 13:00-17:00
2. 재배정 시도: findAvailableSlot(240분) → 성공
3. 다른 날짜/시간에 240분 배정 완료
```

**결과**: 60분 + 240분 = 300분이어야 하는데, 240분만 배정됨

---

## 리팩토링 계획

### 🔴 Phase 1: 긴급 수정 (단기 해결책)

**목표**: 슬롯 손실 방지

**작업**:
1. ✅ **완료**: 재배정 실패 시 원본 슬롯 유지
   - 파일: `client/src/services/travelScheduleCalculator.js`
   - 위치: 1367-1371줄
   - 변경: 원본 슬롯을 allResultSlots에 추가하고 continue

2. **추가 검증 필요**: 원본 슬롯 유지 시 중복/겹침 체크
   - 위치: 1367줄 이후
   - 작업: 원본 슬롯 추가 전 assignedSlotsByDate와 겹침 체크
   - 겹침 발생 시 경고 로그 출력

3. **UI 개선**: 겹침 슬롯 시각적 표시
   - 파일: `client/src/components/CalendarView.js` (또는 해당 컴포넌트)
   - 작업: 겹침 슬롯에 경고 표시 (빨간색 테두리 등)

**예상 시간**: 2-3시간

---

### 🟡 Phase 2: 중기 개선 (재배정 로직 개선)

**목표**: 재배정 성공률 향상

**작업**:
1. **재배정 실패 슬롯 수집 및 재시도**
   - 위치: `recalculateScheduleWithTravel` 메서드 끝부분 (1478줄 이후)
   - 로직:
     ```javascript
     const failedSlots = []; // 재배정 실패한 슬롯 수집

     for (const mergedSlot of sortedMergedSlots) {
         // ... 기존 로직 ...
         if (재배정 실패) {
             failedSlots.push(mergedSlot);
         }
     }

     // 실패한 슬롯들을 사용자별로 그룹화하여 재시도
     const failedByUser = groupSlotsByUser(failedSlots);
     for (const [userId, userSlots] of Object.entries(failedByUser)) {
         const totalMinutes = sum(userSlots.map(s => duration(s)));
         // 전체 시간으로 재배정 시도
         const result = await findAvailableSlotsWithSplit(..., totalMinutes);
         if (result.success) {
             // 성공 시 슬롯 추가
         }
     }
     ```

2. **재배정 우선순위 조정**
   - 작은 슬롯(60분)보다 큰 슬롯(240분)을 먼저 재배정
   - 재배정 실패한 슬롯은 나중에 합쳐서 재시도

**예상 시간**: 1-2일

---

### 🟢 Phase 3: 장기 리팩토링 (근본적 해결)

**목표**: 사용자별 슬롯 그룹화 처리

**작업**:
1. **슬롯 그룹화 구조 변경**
   - 현재: `sortedMergedSlots` 배열 (슬롯 순서대로)
   - 변경: `slotsByUser` 맵 (사용자별 그룹)
   ```javascript
   // 슬롯을 사용자별로 그룹화
   const slotsByUser = new Map();
   for (const slot of sortedMergedSlots) {
       const userId = slot.user;
       if (!slotsByUser.has(userId)) {
           slotsByUser.set(userId, []);
       }
       slotsByUser.get(userId).push(slot);
   }
   ```

2. **사용자별 일괄 처리**
   ```javascript
   for (const [userId, userSlots] of slotsByUser) {
       // 사용자의 모든 슬롯 병합
       const totalDuration = sum(userSlots.map(s => duration(s)));
       const memberLocation = memberLocations[userId];

       // 전체 시간을 한 번에 재배정 시도
       let placement = await findAvailableSlot(
           userSlots[0], // 대표 슬롯
           userId,
           memberPreferences,
           travelDurationMinutes,
           totalDuration, // ← 전체 시간
           ...
       );

       // 실패 시 분할 배치
       if (!placement.success) {
           placement = await findAvailableSlotsWithSplit(
               userSlots[0],
               userId,
               memberPreferences,
               travelDurationMinutes,
               totalDuration, // ← 전체 시간
               ...
           );
       }

       // 여전히 실패 시 개별 슬롯으로 폴백
       if (!placement.success) {
           for (const slot of userSlots) {
               // 개별 슬롯 처리 (기존 로직)
           }
       }
   }
   ```

3. **날짜별 처리 순서 최적화**
   - 사용자별로 그룹화된 슬롯을 날짜 순으로 정렬
   - 같은 날짜에 여러 사용자가 있을 경우 거리 순으로 정렬

**예상 시간**: 3-5일

---

## 테스트 계획

### Phase 1 테스트
1. **수동 테스트**:
   - B에게 월 10-11, 화 13-17 배정
   - 대중교통 모드로 전환
   - 총 5시간이 모두 표시되는지 확인
   - 콘솔에서 "⚠️ [재배정 실패]" 메시지 확인

2. **엣지 케이스**:
   - 재배정 실패 슬롯이 여러 개인 경우
   - 재배정 실패 슬롯이 겹치는 경우
   - 재배정 실패 슬롯이 금지시간과 겹치는 경우

### Phase 2 테스트
1. **재시도 로직 테스트**:
   - 첫 재배정 실패 후 재시도 성공 케이스
   - 재시도도 실패하는 케이스

2. **성능 테스트**:
   - 10명 이상의 학생
   - 각 학생이 3-5개의 슬롯
   - 재배정 시간 측정

### Phase 3 테스트
1. **통합 테스트**:
   - 모든 Phase 1-3 변경사항 통합
   - 다양한 시나리오 테스트 (2-20명 학생, 1-10시간 배정)

2. **회귀 테스트**:
   - 기존 기능 (일반 보기) 정상 작동 확인
   - 서버 자동 배정 로직 영향 없음 확인

---

## 위험 요소 및 대응

### 위험 1: Phase 1 수정으로 겹침 발생 가능
- **영향**: 원본 슬롯 유지 시 다른 슬롯과 겹칠 수 있음
- **대응**: UI에서 겹침 경고 표시, 사용자에게 수동 조정 안내

### 위험 2: Phase 3 대규모 리팩토링으로 버그 발생 가능
- **영향**: 기존 기능 손상
- **대응**: 충분한 테스트, 단계별 배포, 롤백 계획 수립

### 위험 3: 성능 저하
- **영향**: 재시도 로직으로 처리 시간 증가
- **대응**: 재시도 횟수 제한, 비동기 처리, 로딩 인디케이터

---

## 우선순위

1. **즉시 (오늘)**: Phase 1 추가 검증 및 수정
2. **이번 주**: Phase 2 구현 및 테스트
3. **다음 주**: Phase 3 설계 및 프로토타입
4. **2주 후**: Phase 3 구현 및 통합 테스트

---

## 체크리스트

### Phase 1
- [✅] 재배정 실패 시 원본 슬롯 유지 코드 작성
- [ ] 원본 슬롯 유지 시 겹침 체크 추가
- [ ] UI 겹침 경고 표시
- [ ] 수동 테스트
- [ ] 코드 리뷰

### Phase 2
- [ ] 재배정 실패 슬롯 수집 로직
- [ ] 사용자별 그룹화 재시도 로직
- [ ] 우선순위 조정 로직
- [ ] 단위 테스트
- [ ] 통합 테스트

### Phase 3
- [ ] 슬롯 그룹화 구조 설계
- [ ] 사용자별 일괄 처리 구현
- [ ] 날짜별 처리 순서 최적화
- [ ] 폴백 로직 구현
- [ ] 전체 회귀 테스트

---

## 참고 자료

- 문제 분석 파일: `5시간배정_문제분석.txt`
- 수정 사항 정리: `수정사항_정리.txt`
- 핵심 파일:
  - `client/src/services/travelScheduleCalculator.js` (재계산 로직)
  - `server/services/schedulingAlgorithm/services/publicTransportAssignmentService.js` (자동 배정)

---

## 버전 관리

- v1.0 (현재): 문제 발생 버전
- v1.1 (계획): Phase 1 적용
- v1.2 (계획): Phase 2 적용
- v2.0 (계획): Phase 3 적용 (메이저 리팩토링)

---

마지막 업데이트: 2025-12-19
작성자: Claude Code
