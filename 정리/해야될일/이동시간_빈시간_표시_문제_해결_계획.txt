================================================================================
🐛 이동시간이 빈시간으로 표시되는 문제 해결 계획
================================================================================
작성일: 2025-12-31
우선순위: 🔴 긴급 (핵심 기능 버그)
파일 위치: 
  - client/src/utils/timetableHelpers.js (getSlotOwner 함수)
  - client/src/components/timetable/TimetableGrid.js (getSlotOwner 호출부)
  - client/src/components/timetable/WeekView.js (이동시간 처리 로직)

================================================================================
📋 문제 상황 분석
================================================================================

🔍 현상:
방장이 자동배정 실행 후 대중교통 보기 → 적용 버튼 클릭 시, 조원 계정에서 이동시간이 빈시간으로 표시됨

예시:
  - a 계정: 9-10시 이동시간, 10-11시 수업
  - b 계정: 13-13:10 이동시간, 13:10-14:10 수업  
  - c 계정: 14:10-14:50 이동시간, 14:50-15:50 수업

문제:
  ❌ a 계정에서 11-11:10분이 빈시간으로 표시됨 (c의 이동시간 일부)
  ❌ a 계정에서 14:40-14:50이 빈시간으로 표시됨 (c의 이동시간 일부)
  ❌ b 계정에서 14:10-14:50이 빈시간으로 표시됨 (c의 이동시간)
  ❌ c 계정에서 14:40-14:50이 빈시간으로 표시됨 (본인 이동시간 일부)
  ❌ c 계정에서 15:50-16:10이 빈시간으로 표시됨

예상 동작:
  ✅ 본인 포함 다른 조원들의 이동시간은 전부 "배정 불가" (빗금)로 표시되어야 함


================================================================================
🔍 원인 분석
================================================================================

1. 데이터 구조 분리:
   - 수업 슬롯: `timeSlots` 배열에 저장
   - 이동시간 슬롯: `travelSlots` 배열에 별도 저장 (분리됨)

2. getSlotOwner 함수의 문제:
   📍 위치: client/src/utils/timetableHelpers.js (190-282번 줄)
   
   현재 로직:
   ```javascript
   export const getSlotOwner = (date, time, timeSlots, members, currentUser, isRoomOwner) => {
     // ❌ timeSlots만 확인하고 travelSlots는 확인하지 않음
     const bookedSlot = (timeSlots || []).find(slot => {
       // ... 날짜와 시간 비교
     });
     
     if (bookedSlot && bookedSlot.isTravel) {
       return { isTravel: true, ... }; // 이동시간 슬롯 반환
     }
   }
   ```
   
   문제점:
   ❌ travelSlots는 별도 배열이므로 timeSlots에서 찾을 수 없음
   ❌ 이동시간 슬롯이 감지되지 않으면 null 반환 → 빈시간으로 표시됨

3. WeekView.js의 이동시간 처리 로직:
   📍 위치: client/src/components/timetable/WeekView.js
   
   확정 전 (isConfirmed=false):
   - 559번, 1166번 줄: 빗금 계산 로직이 작동
   - 조건: !isRoomOwner && travelMode !== 'normal' && myTravelDuration > 0 && !ownerInfo && !isConfirmed
   - 방장 선호시간 내에서 이동시간 확보 불가능한 시간을 빗금으로 표시
   
   확정 후 (isConfirmed=true):
   - 빗금 계산 로직이 스킵됨 (!isConfirmed 조건 때문에)
   - 이동시간 슬롯은 ownerInfo로 감지되어야 함
   - 656번 줄: if (!isRoomOwner && ownerInfo && ownerInfo.isTravel) 조건으로 배정 불가 표시
   
   문제:
   ❌ ownerInfo가 null이면 (getSlotOwner가 이동시간 슬롯을 못 찾으면)
   ❌ 656번 줄 조건이 false가 되어 배정 불가로 표시되지 않음
   ❌ 결과적으로 빈시간으로 표시됨

4. TimetableGrid.js의 prop 전달:
   📍 위치: client/src/components/timetable/TimetableGrid.js
   
   564번 줄: getSlotOwner 함수 정의
   ```javascript
   const getSlotOwner = useCallback((date, time) => {
     const slotsToUse = showMerged ? mergedTimeSlots : timeSlots;
     
     const baseOwnerInfo = getSlotOwnerHelper(
       date, time, slotsToUse, members, currentUser, isRoomOwner
     );
     // ❌ travelSlots를 전달하지 않음
   }, [timeSlots, mergedTimeSlots, members, currentUser, isRoomOwner, showMerged]);
   ```
   
   1148-1157번 줄: WeekView에 prop 전달
   ```javascript
   <WeekView
     travelSlots={travelSlots}  // ✅ travelSlots는 전달됨
     timeSlots={timeSlots}       // ✅ timeSlots도 전달됨
     getSlotOwner={getSlotOwner} // ❌ 하지만 getSlotOwner는 travelSlots를 확인 안 함
     ...
   />
   ```


================================================================================
💡 해결 방안 3가지
================================================================================

[방안 1] ⭐ getSlotOwner 함수 수정 (추천)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
난이도: ★★☆☆☆ (중간)
영향도: 낮음 (함수 시그니처 변경이지만 내부 로직만 수정)
소요시간: 30분

📝 수정 내용:
  1. timetableHelpers.js의 getSlotOwner 함수에 travelSlots 매개변수 추가
  2. timeSlots와 travelSlots를 모두 확인하도록 로직 수정
  3. TimetableGrid.js의 getSlotOwner 호출부에서 travelSlots 전달

✅ 장점:
  - 가장 직접적이고 명확한 해결책
  - 이동시간 슬롯을 확실하게 감지
  - 향후 이동시간 관련 기능 확장 시 유용

❌ 단점:
  - 함수 시그니처 변경으로 인한 약간의 리팩토링 필요
  - 다른 곳에서 getSlotOwner를 호출하는 부분도 수정 필요

📍 수정 대상 파일:
  - client/src/utils/timetableHelpers.js (getSlotOwner 함수)
  - client/src/components/timetable/TimetableGrid.js (getSlotOwner 호출부)


[방안 2] WeekView.js에서 travelSlots 직접 확인
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
난이도: ★★★☆☆ (중간-어려움)
영향도: 중간 (WeekView.js의 로직 복잡도 증가)
소요시간: 1시간

📝 수정 내용:
  1. WeekView.js의 getMergedTimeBlocks 함수에서 ownerInfo 확인 전에 travelSlots 확인
  2. renderNormalView 함수에서도 동일하게 travelSlots 확인
  3. travelSlots에 해당 시간이 있으면 배정 불가로 표시

✅ 장점:
  - 기존 getSlotOwner 함수를 수정하지 않아도 됨
  - WeekView.js 내부에서 완결되는 로직

❌ 단점:
  - WeekView.js의 로직이 더 복잡해짐
  - 중복 코드 발생 가능 (병합 모드 + 일반 모드)
  - 다른 컴포넌트에서 동일한 문제 발생 시 또 수정 필요

📍 수정 대상 파일:
  - client/src/components/timetable/WeekView.js (getMergedTimeBlocks, renderNormalView)


[방안 3] 서버에서 timeSlots에 이동시간 포함
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
난이도: ★★★★☆ (어려움)
영향도: 높음 (서버 API 및 데이터 구조 변경)
소요시간: 2시간 이상

📝 수정 내용:
  1. 서버 API에서 timeSlots에 이동시간 슬롯도 포함해서 반환
  2. isTravel 플래그로 이동시간 슬롯 구분
  3. 클라이언트에서는 travelSlots prop 제거 가능

✅ 장점:
  - 데이터 구조가 단순해짐 (timeSlots 하나로 통합)
  - 클라이언트 로직이 간단해짐

❌ 단점:
  - 서버 API 변경 필요 (영향 범위 큼)
  - 기존 travelSlots를 사용하는 다른 로직도 수정 필요
  - 배포 및 테스트 비용 증가

📍 수정 대상 파일:
  - server/controllers/coordinationSchedulingController.js (자동배정 API)
  - 클라이언트의 모든 travelSlots 사용 부분


================================================================================
📊 권장 해결 방안: 방안 1 (getSlotOwner 함수 수정)
================================================================================

이유:
  ✅ 가장 직접적이고 명확한 해결책
  ✅ 영향 범위가 제한적 (유틸리티 함수 1개 + 호출부 1개)
  ✅ 향후 이동시간 관련 기능 확장에도 유용
  ✅ 데이터 구조를 변경하지 않아도 됨


================================================================================
🔧 상세 구현 계획 (방안 1)
================================================================================

[Step 1] timetableHelpers.js의 getSlotOwner 함수 수정
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📍 파일: client/src/utils/timetableHelpers.js (190-282번 줄)

🔧 수정 전:
```javascript
export const getSlotOwner = (date, time, timeSlots, members, currentUser, isRoomOwner) => {
  if (!timeSlots || !time || !date) return null;
  
  // timeSlots에서만 슬롯 찾기
  const bookedSlot = (timeSlots || []).find(slot => {
    // ... 날짜와 시간 비교
  });
  
  if (bookedSlot) {
    if (bookedSlot.isTravel) {
      return { isTravel: true, ... };
    }
    return { isTravel: false, ... };
  }
  
  return null;
}
```

🔧 수정 후:
```javascript
export const getSlotOwner = (date, time, timeSlots, members, currentUser, isRoomOwner, travelSlots = []) => {
  if (!time || !date) return null;
  
  const currentTime = time.trim();
  const currentMinutes = timeToMinutes(currentTime);
  const currentDateStr = date.toISOString().split('T')[0];
  
  // 🆕 1. travelSlots 먼저 확인 (우선순위 높음)
  const travelSlot = (travelSlots || []).find(slot => {
    if (!slot || !slot.date || !slot.startTime || !slot.endTime) return false;
    
    const slotDateStr = new Date(slot.date).toISOString().split('T')[0];
    if (slotDateStr !== currentDateStr) return false;
    
    const startMinutes = timeToMinutes(slot.startTime);
    const endMinutes = timeToMinutes(slot.endTime);
    return currentMinutes >= startMinutes && currentMinutes < endMinutes;
  });
  
  if (travelSlot) {
    // 이동시간 슬롯 반환
    let userId = travelSlot.userId || travelSlot.user;
    if (typeof userId === 'object' && userId !== null) {
      userId = userId._id || userId.id;
    }
    
    const member = (members || []).find(m => {
      const memberId = m.user?._id?.toString() || m.user?.id?.toString();
      return memberId && userId && memberId === userId.toString();
    });
    
    const color = member?.color || '#87CEEB';
    const name = member ? `${member.user.firstName || ''} ${member.user.lastName || ''}`.trim() : travelSlot.subject;
    
    return {
      name: name,
      color: color,
      textColor: '#000000',
      isTravel: true,  // ✅ 이동시간 플래그
      userId: userId,
      actualUserId: userId,
      subject: travelSlot.subject || '이동',
      travelInfo: travelSlot.travelInfo
    };
  }
  
  // 2. timeSlots 확인 (기존 로직 유지)
  if (!timeSlots || timeSlots.length === 0) return null;
  
  const bookedSlot = (timeSlots || []).find(slot => {
    if (!slot || !slot.date || !slot.startTime || !slot.endTime) return false;
    
    const slotDateStr = new Date(slot.date).toISOString().split('T')[0];
    if (slotDateStr !== currentDateStr) return false;
    
    const startMinutes = timeToMinutes(slot.startTime);
    const endMinutes = timeToMinutes(slot.endTime);
    return currentMinutes >= startMinutes && currentMinutes < endMinutes;
  });
  
  if (bookedSlot) {
    // 기존 로직 유지
    // ...
  }
  
  return null;
}
```

💡 핵심 변경 사항:
  1. 매개변수에 travelSlots 추가 (기본값 = [])
  2. travelSlots를 먼저 확인 (우선순위 높음)
  3. 이동시간 슬롯 발견 시 즉시 반환 (isTravel: true)
  4. timeSlots 확인은 기존 로직 유지


[Step 2] TimetableGrid.js의 getSlotOwner 호출부 수정
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📍 파일: client/src/components/timetable/TimetableGrid.js (564-598번 줄)

🔧 수정 전:
```javascript
const getSlotOwner = useCallback((date, time) => {
  const slotsToUse = showMerged ? mergedTimeSlots : timeSlots;
  
  const baseOwnerInfo = getSlotOwnerHelper(
    date,
    time,
    slotsToUse,
    members,
    currentUser,
    isRoomOwner
  );
  
  // 병합 모드 처리 로직...
  
  return baseOwnerInfo;
}, [timeSlots, mergedTimeSlots, members, currentUser, isRoomOwner, showMerged]);
```

🔧 수정 후:
```javascript
const getSlotOwner = useCallback((date, time) => {
  const slotsToUse = showMerged ? mergedTimeSlots : timeSlots;
  
  const baseOwnerInfo = getSlotOwnerHelper(
    date,
    time,
    slotsToUse,
    members,
    currentUser,
    isRoomOwner,
    travelSlots  // 🆕 travelSlots 추가
  );
  
  // 병합 모드 처리 로직...
  
  return baseOwnerInfo;
}, [timeSlots, mergedTimeSlots, members, currentUser, isRoomOwner, showMerged, travelSlots]);  // 🆕 의존성 추가
```

💡 핵심 변경 사항:
  1. getSlotOwnerHelper 호출 시 travelSlots 전달
  2. useCallback 의존성 배열에 travelSlots 추가


[Step 3] 테스트 시나리오
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

준비:
  1. 방장 + 조원 3명 (a, b, c) 계정 준비
  2. 자동배정 실행 (2시간 수업)
  3. 대중교통 모드로 변경
  4. "보기" 버튼 클릭
  5. "적용" 버튼 클릭 (확정)

테스트 1: a 계정으로 확인
  ✅ a의 이동시간: 9-10시 → "배정 불가" (빗금)로 표시
  ✅ a의 수업: 10-11시 → 정상 표시
  ✅ b의 이동시간: 13-13:10 → "배정 불가" (빗금)로 표시
  ✅ b의 수업: 13:10-14:10 → "배정 불가" (빗금)로 표시
  ✅ c의 이동시간: 14:10-14:50 → "배정 불가" (빗금)로 표시
  ✅ c의 수업: 14:50-15:50 → "배정 불가" (빗금)로 표시

테스트 2: b 계정으로 확인
  ✅ a의 이동시간 + 수업 → "배정 불가" (빗금)
  ✅ b의 이동시간: 13-13:10 → "배정 불가" (빗금)
  ✅ b의 수업: 13:10-14:10 → 정상 표시
  ✅ c의 이동시간 + 수업 → "배정 불가" (빗금)

테스트 3: c 계정으로 확인
  ✅ a, b의 이동시간 + 수업 → "배정 불가" (빗금)
  ✅ c의 이동시간: 14:10-14:50 → "배정 불가" (빗금)
  ✅ c의 수업: 14:50-15:50 → 정상 표시
  ✅ 15:50-16:10 (수업 종료 후) → 빈시간 (정상, 다른 조원 일정 없음)

테스트 4: 방장 계정으로 확인
  ✅ 모든 조원의 이동시간 + 수업이 정상 표시됨
  ✅ 색상 구분 정상 (각 조원별 색상)


================================================================================
🧪 추가 검증 사항
================================================================================

1. 병합 모드 vs 일반 모드 테스트
   - showMerged=true: 연속된 이동시간 블록으로 표시
   - showMerged=false: 10분 단위로 개별 표시

2. 확정 전 vs 확정 후 비교
   - 확정 전: 빗금 계산 로직 작동 (이동시간 확보 불가 시간 표시)
   - 확정 후: 실제 이동시간 슬롯만 표시

3. 다양한 이동수단 테스트
   - transit (대중교통), driving (자동차), bicycling (자전거), walking (도보)
   - 각 이동수단별 아이콘 정상 표시 확인

4. 경계 시간 테스트
   - 이동시간 시작/종료 경계
   - 수업 시작/종료 경계
   - 날짜 경계 (자정 넘나드는 경우는 없을 것으로 예상)


================================================================================
⚠️ 주의사항
================================================================================

1. 성능 고려:
   - travelSlots를 먼저 확인하므로 성능에 미치는 영향 최소화
   - travelSlots는 보통 수업 슬롯보다 개수가 적음

2. 하위 호환성:
   - travelSlots 매개변수에 기본값(= []) 설정
   - 기존 코드에서 travelSlots 없이 호출해도 정상 작동

3. 에러 처리:
   - travelSlots가 null/undefined인 경우 처리
   - 날짜/시간 파싱 실패 시 처리

4. 코드 리뷰:
   - getSlotOwner 함수 시그니처 변경으로 인한 영향 범위 확인
   - 다른 곳에서 getSlotOwner를 호출하는 부분 검색


================================================================================
📝 체크리스트
================================================================================

[Step 1] 코드 수정
  [ ] timetableHelpers.js의 getSlotOwner 함수 수정
      - travelSlots 매개변수 추가
      - travelSlots 우선 확인 로직 추가
      - 이동시간 슬롯 반환 로직 추가
  
  [ ] TimetableGrid.js의 getSlotOwner 호출부 수정
      - getSlotOwnerHelper 호출 시 travelSlots 전달
      - useCallback 의존성 배열에 travelSlots 추가

[Step 2] 빌드 및 기본 테스트
  [ ] npm run build 성공 확인
  [ ] 콘솔 에러 없는지 확인
  [ ] 기본 화면 렌더링 정상 확인

[Step 3] 기능 테스트
  [ ] 테스트 1: a 계정 - 이동시간 배정 불가 표시 확인
  [ ] 테스트 2: b 계정 - 이동시간 배정 불가 표시 확인
  [ ] 테스트 3: c 계정 - 이동시간 배정 불가 표시 확인
  [ ] 테스트 4: 방장 계정 - 모든 이동시간 정상 표시 확인

[Step 4] 추가 검증
  [ ] 병합 모드 vs 일반 모드 테스트
  [ ] 확정 전 vs 확정 후 비교
  [ ] 다양한 이동수단 테스트
  [ ] 경계 시간 테스트

[Step 5] 완료
  [ ] 모든 테스트 통과 확인
  [ ] Git commit
  [ ] 이 파일을 "완료된 일" 폴더로 이동


================================================================================
🎯 예상 결과
================================================================================

수정 후:
  ✅ 적용 버튼 클릭 후, 모든 조원의 이동시간이 "배정 불가" (빗금)로 표시됨
  ✅ 조원은 본인 이동시간도 배정 불가로 표시됨 (이동시간 정보 숨김)
  ✅ 조원은 다른 조원의 이동시간도 배정 불가로 표시됨 (이동시간 정보 숨김)
  ✅ 방장은 모든 조원의 이동시간을 정상적으로 볼 수 있음 (색상 구분됨)
  ✅ 빈시간 문제 완전 해결


================================================================================
📚 참고 문서
================================================================================

관련 파일:
  - client/src/utils/timetableHelpers.js (getSlotOwner 함수)
  - client/src/components/timetable/TimetableGrid.js (getSlotOwner 호출부)
  - client/src/components/timetable/WeekView.js (이동시간 빗금 처리)
  - 정리/완료된 일/빗금_표시_개선_계획.txt (이전 작업 참고)

관련 이슈:
  - 빗금 표시 개선 (완료)
  - 이동시간 빈시간 표시 문제 (현재 작업)


================================================================================
