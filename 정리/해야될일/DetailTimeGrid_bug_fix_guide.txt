## 버그 리포트: 일정 관리 데이터 오염 (DetailTimeGrid 컴포넌트)

**문제 설명:**
현재 애플리케이션의 일정 관리 기능에서 심각한 데이터 오염 문제가 발생하고 있습니다. 특히 일회성 일정 예외(예: 챗봇을 통해 추가된 특정 날짜의 선호 시간)가 `defaultSchedule`(매주 반복되는 기본 일정용)에 잘못 병합되고 있습니다. 이는 `defaultSchedule` 배열이 비정상적으로 커지는 현상(로그에서 1050개 항목 관찰됨)을 초래하며, 성능 저하 및 일정 유효성 검사 로직(예: coordinationExchangeController.js)의 오작동을 야기합니다.

**근본 원인 분석:**
이 데이터 오염의 근본 원인은 일일 일정을 편집하는 컴포넌트, 즉 `ProfileTab/index.js`에서 `DetailTimeGrid`로 임포트되는 컴포넌트에 있습니다.

이 컴포넌트는 다음과 같은 결함 있는 동작을 보입니다.
1.  **결합된 표시:** `DetailTimeGrid`는 단일 날짜의 일정을 표시하기 위해 `defaultSchedule`(props로 `schedule` 전달)과 `scheduleExceptions`(props로 `exceptions` 전달)의 데이터를 병합하여 사용합니다.
2.  **잘못된 업데이트 로직:** 사용자가 `DetailTimeGrid` UI 내에서 시간 슬롯을 대화식으로 수정(추가, 편집, 삭제)할 때, 컴포넌트는 수정된 슬롯의 원본 소스를 올바르게 식별하지 못합니다. 일회성 이벤트의 경우 `exceptions` 상태(setExceptions prop을 통해)를 업데이트하거나 반복 이벤트의 경우 `schedule` 상태(setSchedule prop을 통해)를 업데이트하는 대신, 오류가 발생하여 모든 수정/새로운 슬롯을 `schedule` 상태(즉, `defaultSchedule`)에 저장합니다.
3.  **상태 오염:** 이로 인해 `scheduleExceptions` 데이터가 `ProfileTab` 컴포넌트 내의 `defaultSchedule` 상태 변수로 푸시됩니다. 그런 다음 `ProfileTab`이 저장 작업을 트리거하면(예: `createSaveHandler` 또는 `createAutoSaveHandler`를 통해), 이제 오염된 `defaultSchedule`이 서버로 전송되어 데이터베이스에 영구적인 데이터 손상이 발생합니다.

**영향:**
-   `defaultSchedule` 배열이 커져 성능이 저하됩니다.
-   일회성 예외가 제대로 인식되지 않아 일정 유효성 검사, 특히 조정 기능에서 오류가 발생합니다.
-   예상치 못한 일정 동작으로 인해 사용자 불만이 발생합니다.

**제안된 해결책 및 `DetailTimeGrid.js` 수정 가이드:**

`Ai_Schedule/client/src/components/calendar/DetailTimeGrid.js` (또는 `ProfileTab/index.js`에서 `DetailTimeGrid`로 임포트되는 파일)은 일정 유형을 올바르게 구분하고 업데이트하도록 수정되어야 합니다.

**필요한 주요 수정 사항:**

1.  **표시 시 데이터 소스 식별:** `DetailTimeGrid` 내에서 슬롯을 렌더링할 때, 각 슬롯은 `defaultSchedule`에서 시작되었는지 `scheduleExceptions`에서 시작되었는지 나타내는 식별자(예: `sourceType: 'default'` 또는 `sourceType: 'exception'`)를 가져야 합니다.
2.  **별도 업데이트 로직:** 사용자 작업(추가/편집/삭제)이 슬롯을 수정할 때:
    *   **기존 슬롯의 경우:** `sourceType`을 기반으로 `setSchedule` prop(defaultSchedule 항목의 경우) 또는 `setExceptions` prop(scheduleExceptions 항목의 경우)을 업데이트된 데이터로 호출합니다. 이러한 setter에 전송되는 업데이트된 데이터에는 관련 일정 유형만 포함되도록 합니다.
    *   **새로운 슬롯의 경우:** `DetailTimeGrid` 내에서 특정 날짜에 새로 생성된 시간 슬롯은 일회성 예외로 처리해야 합니다. 따라서 이러한 새 슬롯은 `setSchedule`이 아닌 `setExceptions` prop에 전달되어야 합니다.
3.  **병합 방지:** `setSchedule`은 실제 반복 일정 데이터로만 호출되고 `setExceptions`는 실제 일회성 예외 데이터로만 호출되도록 합니다. 컴포넌트는 이 두 가지 일정 유형의 분리를 엄격하게 유지해야 합니다.

**개념적인 변경 예시 (`DetailTimeGrid.js`의 저장 핸들러 또는 상태 업데이트 로직 내):**

```javascript
// 현재 문제 있는 접근 방식 (개념):
// let allModifiedSlots = someMergedDisplayState;
// setSchedule(allModifiedSlots); // <--- 이 방식은 모든 것을 defaultSchedule에 잘못 넣습니다.

// 수정된 올바른 접근 방식 (개념):
// 수정된 슬롯을 원래 유형으로 다시 분리
let newDefaultSchedule = []; // 필터링되고 업데이트된 기본 슬롯
let newScheduleExceptions = []; // 필터링되고 업데이트된 예외 슬롯

allModifiedSlots.forEach(slot => {
    if (slot.sourceType === 'default' || (slot.isRecurring && !slot.specificDate)) {
        newDefaultSchedule.push(slot);
    } else { // sourceType이 예외이거나, 새로운 일회성 슬롯
        newScheduleExceptions.push(slot);
    }
});

setSchedule(newDefaultSchedule);
setExceptions(newScheduleExceptions);
```

이러한 명확한 분리를 구현함으로써 데이터 오염을 막고, 일정 관리가 의도한 대로 작동할 것입니다.