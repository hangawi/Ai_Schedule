# 이동시간 시스템 오류 분석 및 수정 계획

## 🔴 발견된 심각한 문제들

### 문제 1: 방장이 "일반" 모드로 변경해도 조원 화면에서 대중교통 보기 유지
**증상:**
- 방장이 "일반" 버튼 클릭
- 조원 계정으로 확인 → 여전히 대중교통 보기로 표시됨

**원인 추정:**
- Socket.io 이벤트가 제대로 전송되지 않거나
- 조원이 Socket.io 이벤트를 수신하지 못함
- 또는 `currentTravelMode`가 DB에 제대로 저장되지 않음

### 문제 2: 이동시간 모드에서 금지시간 침범
**증상:**
- 일반 모드 자동배정: 점심시간(12:00-13:00) 침범하지 않음 ✅
- 대중교통/자가용 보기로 전환: 이동시간 때문에 금지시간 침범 ❌

**원인:**
- 이동시간 적용 시 금지시간 검증을 안 함
- `travelScheduleCalculator`에서 이동시간 계산 시 금지시간 체크 누락

### 문제 3: 대중교통 보기 시간표에서 교환/이동 시도 시 일반 시간에만 적용
**증상:**
- 화면: 대중교통 보기 (예: 13:30-14:00)
- 교환 시도: 실제로는 일반 시간 (9:00-10:00) 기준으로 교환됨

**원인:**
- DB에 `originalStartTime/EndTime`과 `startTime/endTime`이 제대로 저장되지 않음
- 교환 로직이 `originalStartTime`을 사용해야 하는데 `startTime`을 사용하고 있거나
- 또는 애초에 서버에 이동시간 포함 스케줄이 저장되지 않음

### 문제 4: 확정 시 대중교통 시간이 아닌 일반 시간이 저장됨
**증상:**
- 대중교통 보기로 확정 (13:30-14:00)
- 개인 시간표 확인: 9:00-10:00으로 저장됨

**원인:**
- `confirmSchedule`에서 `slot.startTime` 대신 `slot.originalStartTime`을 저장하고 있음
- 또는 애초에 DB의 `startTime`이 이동시간 포함 시간이 아님

---

## 🔍 핵심 문제 진단

**근본 원인: `applyTravelMode` API가 제대로 작동하지 않음**

제가 만든 로직:
1. 프론트엔드에서 `travelScheduleCalculator.recalculateScheduleWithTravel()` 호출
2. 이동시간 포함된 `enhancedSchedule` 생성
3. `coordinationService.applyTravelMode()`로 서버에 전송
4. 서버가 `timeSlots`를 업데이트하고 저장

**문제:**
- 서버에서 제대로 저장되지 않거나
- 저장은 되는데 조회 시 원본만 반환되거나
- Socket.io 동기화가 안 되거나
- 아니면 애초에 API 호출 자체가 실패함

---

## 📋 수정 계획

### Step 1: 현재 코드 철저히 분석 (30분)
1. `useTravelMode.js` - API 호출 확인
2. `coordinationService.js` - API 호출 코드 확인
3. `coordinationSchedulingController.applyTravelMode` - 서버 저장 로직 확인
4. Socket.io 이벤트 확인
5. DB 저장/조회 확인

### Step 2: 문제별 수정 (1-2시간)

#### 문제 1 해결: 방장/조원 동기화
- [ ] Socket.io 이벤트가 제대로 전송되는지 확인
- [ ] 조원이 Socket.io 이벤트 리스너를 가지고 있는지 확인
- [ ] `currentTravelMode`가 DB에 저장되고 조회되는지 확인

#### 문제 2 해결: 이동시간 모드에서 금지시간 보호
- [ ] `travelScheduleCalculator.recalculateScheduleWithTravel()`에 금지시간 검증 추가
- [ ] 이동시간 적용 시 금지시간을 침범하는 슬롯은 시간 조정 또는 제외

#### 문제 3 해결: 교환/이동 시 올바른 시간 사용
- [ ] `applyTravelMode`가 실제로 DB의 `startTime/endTime`을 업데이트하는지 확인
- [ ] 교환 로직이 현재 모드에 따라 올바른 시간을 사용하는지 확인

#### 문제 4 해결: 확정 시 올바른 시간 저장
- [ ] `confirmSchedule`에서 방장은 `slot.startTime` (이동시간 포함) 저장
- [ ] 조원은 `slot.originalStartTime` (수업시간만) 저장
- [ ] 실제로 DB에 이동시간 포함 시간이 있는지 확인

### Step 3: 테스트 (30분)
- [ ] 일반 ↔ 대중교통 모드 전환 테스트
- [ ] 조원 동기화 테스트
- [ ] 금지시간 침범 테스트
- [ ] 교환 테스트
- [ ] 확정 및 개인 시간표 저장 테스트

---

## 🎯 수정 우선순위

1. **최우선**: `applyTravelMode` API 동작 확인 및 수정
2. **중요**: Socket.io 동기화 수정
3. **중요**: 확정 시 저장 로직 수정
4. **보통**: 이동시간 모드에서 금지시간 검증

---

## 💡 예상 수정 사항

### 서버 측:
- `applyTravelMode` 함수가 실제로 `timeSlots`를 업데이트하는지 확인
- Socket.io 이벤트 제대로 전송하는지 확인
- `confirmSchedule`에서 `currentTravelMode` 확인 후 적절한 시간 저장

### 클라이언트 측:
- Socket.io 리스너 추가 (조원용)
- `enhancedSchedule`이 실제로 서버에 전송되는지 확인
- 에러 처리 강화

### 공통:
- 로그 추가하여 각 단계별 데이터 추적
- DB에 실제로 저장되는 값 확인

---

**다음 단계: 코드 분석 시작**
