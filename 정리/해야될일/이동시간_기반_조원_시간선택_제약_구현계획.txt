================================================================================
📋 이동시간 기반 조원 시간 선택 제약 구현 계획 (동적 이동시간 모델)
================================================================================
작성일: 2025-12-15
버전: 2.0 (동적 이동시간 계산 반영)
목적: 방장의 이동시간을 비공개로 유지하면서, 조원들이 실제로 불가능한 시간을
     선택하지 못하도록 사전에 차단하는 시스템 구축

================================================================================
🔥 핵심 개념: 이동시간은 "관계값"이다 (가장 중요!)
================================================================================

[잘못된 접근 ❌]
"A는 이동시간 10분, B는 이동시간 1시간"
→ 사람별 고정 이동시간으로 생각하면 100% 충돌 발생

[올바른 접근 ✅]
이동시간 = (이전 일정의 위치) → (현재 일정의 위치)

[왜 이게 중요한가?]

📌 시나리오 1: 순서에 따라 이동시간이 달라짐
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  초기 배정:
    월요일: A(9:00), B(11:00)
    - A 이동시간: 방장 집 → A 위치 = 60분 (8:00-9:00)
    - B 이동시간: A 위치 → B 위치 = 10분 (10:50-11:00)

  A와 B 순서 교환 후:
    월요일: B(9:00), A(11:00)
    - B 이동시간: 방장 집 → B 위치 = 60분 (8:00-9:00) ← 변경!
    - A 이동시간: B 위치 → A 위치 = 10분 (10:50-11:00) ← 변경!

  👉 같은 A인데, 첫 번째면 60분, 두 번째면 10분!

📌 시나리오 2: 요일에 따라 이동시간이 달라짐
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  월요일: A(9:00), B(11:00)
    - B 이동시간: A → B = 10분

  수요일: B(9:00) [혼자]
    - B 이동시간: 방장 집 → B = 60분 ← 같은 B인데 60분!

  👉 B의 이동시간은 요일과 앞 일정에 따라 10분 또는 60분

📌 시나리오 3: 중간 삽입 시 이동시간 재계산
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  기존: A(9:00), C(13:00)
    - A: 방장 집 → A = 60분
    - C: A → C = 90분 (11:30-13:00)

  B를 11:00에 삽입:
    - A: 방장 집 → A = 60분
    - B: A → B = 10분 (10:50-11:00) ← 새로 계산
    - C: B → C = 40분 (12:20-13:00) ← 90분에서 40분으로 감소!

  👉 C의 이동시간이 B 삽입으로 인해 90분 → 40분으로 변경

[결론]
이동시간은 고정값이 아니라, '해당 시간을 선택했을 때 앞뒤 일정이 무엇이 되느냐'에
따라 매번 새로 계산되는 동적 제약 조건이다.

================================================================================
📌 요구사항 요약
================================================================================

[핵심 원칙]
1. 조원들은 방장의 이동시간을 절대 볼 수 없음 (비공개 정보)
2. 조원이 시간을 선택할 때, 시스템은 내부적으로 시뮬레이션을 수행:
   - 해당 시간에 배치될 경우 이전/다음 일정이 무엇인지 계산
   - 각 일정 간 이동시간을 동적으로 계산
   - 금지시간, 충돌 등을 모두 검증
3. 조원에게는 결과(가능/불가능)만 보여주고, 이유(이동시간)는 숨김

[시스템 동작 원리]
  조원이 시간 T를 선택하려고 할 때:

  ① 시스템은 T가 배치되었을 때의 전체 스케줄을 시뮬레이션
  ② 앞 일정의 위치 → T 위치까지 이동시간 계산
  ③ T 위치 → 뒤 일정의 위치까지 이동시간 계산
  ④ 이동시간 + 금지시간 + 다른 제약을 모두 확인
  ⑤ 하나라도 위반하면 → "선택 불가"
  ⑥ 모두 만족하면 → "선택 가능"

[조원이 보는 것]
  ✅ 선택 가능한 시간 (파란색)
  ❌ 선택 불가능한 시간 (회색, "선택할 수 없습니다")
  ❓ 왜 불가능한지는 절대 표시 안 함

================================================================================
🎯 Phase 1: 백엔드 - 동적 이동시간 계산 엔진
================================================================================

[1-1] 위치 정보 모델 설계
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: server/models/room.js

🔹 TimeSlotSchema 확장:

  location: {
    type: {
      type: String,
      enum: ['address', 'coordinates'],
      required: false
    },
    address: String, // "서울시 강남구 ..."
    coordinates: {
      lat: Number,
      lng: Number
    },
    description: String // "강남역 스터디카페"
  }

  // ❌ 고정 이동시간 필드는 추가하지 않음!
  // ✅ 이동시간은 매번 동적으로 계산함

🔹 Room Schema에 방장 기준 위치 추가:

  ownerHomeLocation: {
    type: {
      type: String,
      enum: ['address', 'coordinates'],
      required: false
    },
    address: String,
    coordinates: {
      lat: Number,
      lng: Number
    }
  }

[1-2] 동적 이동시간 계산 엔진
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: server/services/dynamicTravelTimeCalculator.js (신규)

🔹 핵심 함수 1: calculateTravelTimeBetween()

  /**
   * 두 위치 간 이동시간 계산 (Google Maps API 활용)
   * @param {Object} fromLocation - 출발 위치
   * @param {Object} toLocation - 도착 위치
   * @param {String} travelMode - 이동수단 ('transit', 'driving', 'walking', etc.)
   * @returns {Number} 이동시간 (분 단위)
   */
  async calculateTravelTimeBetween(fromLocation, toLocation, travelMode) {
    // Google Maps Distance Matrix API 호출
    // 또는 기존 travelTimeService 활용

    const result = await googleMapsClient.distanceMatrix({
      origins: [fromLocation],
      destinations: [toLocation],
      mode: travelMode,
      departure_time: 'now'
    });

    return result.rows[0].elements[0].duration.value / 60; // 초 → 분
  }

🔹 핵심 함수 2: simulateScheduleWithNewSlot()

  /**
   * 새로운 슬롯을 특정 시간에 배치했을 때 전체 스케줄 시뮬레이션
   * @param {String} roomId - 방 ID
   * @param {Date} date - 날짜
   * @param {Object} newSlot - 삽입할 슬롯 정보
   * @returns {Object} 시뮬레이션 결과
   */
  async simulateScheduleWithNewSlot(roomId, date, newSlot) {
    // 1. 해당 날짜의 기존 슬롯들 조회 (시간순 정렬)
    const room = await Room.findById(roomId)
      .populate('members.user', 'personalTimes')
      .populate('owner', 'personalTimes homeLocation');

    const existingSlots = room.timeSlots
      .filter(slot => isSameDay(slot.date, date))
      .sort((a, b) => timeToMinutes(a.startTime) - timeToMinutes(b.startTime));

    // 2. 새 슬롯을 적절한 위치에 삽입
    const allSlots = [...existingSlots, newSlot]
      .sort((a, b) => timeToMinutes(a.startTime) - timeToMinutes(b.startTime));

    // 3. 각 슬롯의 이동시간 계산
    const simulatedSchedule = [];
    let previousLocation = room.ownerHomeLocation; // 방장 집에서 시작

    for (const slot of allSlots) {
      const travelTime = await this.calculateTravelTimeBetween(
        previousLocation,
        slot.location,
        room.confirmedTravelMode || 'transit'
      );

      simulatedSchedule.push({
        slot,
        travelTimeBefore: travelTime,
        actualStartTime: subtractMinutes(slot.startTime, travelTime),
        previousLocation
      });

      previousLocation = slot.location; // 다음 슬롯을 위해 현재 위치 저장
    }

    return simulatedSchedule;
  }

🔹 핵심 함수 3: validateNewSlotPlacement()

  /**
   * 새로운 슬롯이 해당 시간에 배치 가능한지 검증
   * @param {String} roomId - 방 ID
   * @param {Date} date - 날짜
   * @param {String} startTime - 시작 시간 (HH:MM)
   * @param {String} endTime - 종료 시간 (HH:MM)
   * @param {Object} location - 위치 정보
   * @returns {Object} { valid: boolean, reason: string, details: {...} }
   */
  async validateNewSlotPlacement(roomId, date, startTime, endTime, location) {
    // 1. 시뮬레이션 수행
    const newSlot = { startTime, endTime, location, date };
    const simulatedSchedule = await this.simulateScheduleWithNewSlot(
      roomId,
      date,
      newSlot
    );

    // 2. 새 슬롯 찾기
    const newSlotIndex = simulatedSchedule.findIndex(
      item => item.slot.startTime === startTime
    );
    const newSlotInfo = simulatedSchedule[newSlotIndex];

    // 3. 검증 항목들

    // 3-1. 이동시간 때문에 실제 시작 시간이 금지시간과 겹치는가?
    const room = await Room.findById(roomId);
    const actualStart = newSlotInfo.actualStartTime;

    for (const blockedTime of room.settings.blockedTimes) {
      if (isTimeInRange(actualStart, blockedTime.startTime, startTime)) {
        return {
          valid: false,
          reason: 'blocked_time_conflict',
          details: {
            actualStartTime: actualStart,
            blockedTime: blockedTime.startTime
          }
        };
      }
    }

    // 3-2. 이전 슬롯과 충돌하는가?
    if (newSlotIndex > 0) {
      const prevSlot = simulatedSchedule[newSlotIndex - 1];
      const prevEndTime = prevSlot.slot.endTime;

      if (timeToMinutes(actualStart) < timeToMinutes(prevEndTime)) {
        return {
          valid: false,
          reason: 'previous_slot_conflict',
          details: {
            previousEndTime: prevEndTime,
            actualStartTime: actualStart
          }
        };
      }
    }

    // 3-3. 다음 슬롯과 충돌하는가?
    if (newSlotIndex < simulatedSchedule.length - 1) {
      const nextSlot = simulatedSchedule[newSlotIndex + 1];
      const nextTravelTime = nextSlot.travelTimeBefore;
      const requiredEndTime = subtractMinutes(
        nextSlot.slot.startTime,
        nextTravelTime
      );

      if (timeToMinutes(endTime) > timeToMinutes(requiredEndTime)) {
        return {
          valid: false,
          reason: 'next_slot_conflict',
          details: {
            requiredEndTime,
            requestedEndTime: endTime
          }
        };
      }
    }

    // 4. 모든 검증 통과
    return {
      valid: true,
      reason: 'all_checks_passed',
      details: {
        travelTimeBefore: newSlotInfo.travelTimeBefore,
        actualStartTime: newSlotInfo.actualStartTime
      }
    };
  }

[1-3] 가능한 시간대 목록 계산 API
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: server/controllers/coordinationSchedulingController.js

🔹 엔드포인트: GET /api/coordination/rooms/:roomId/available-slots

  /**
   * 조원이 선택 가능한 시간대 목록 반환
   * 방장의 이동시간을 고려하여 실제로 가능한 시간만 필터링
   */
  exports.getAvailableSlots = async (req, res) => {
    try {
      const { roomId } = req.params;
      const { memberId, date, memberLocation } = req.query;

      const room = await Room.findById(roomId);
      if (!room) {
        return res.status(404).json({ msg: '방을 찾을 수 없습니다.' });
      }

      // 1. 해당 날짜의 모든 가능한 시간대 생성 (예: 9:00~18:00, 30분 단위)
      const allPossibleSlots = generateTimeSlots(
        room.settings.startHour,
        room.settings.endHour,
        30 // 분 단위
      );

      // 2. 각 시간대별로 검증
      const availabilityResults = [];

      for (const slot of allPossibleSlots) {
        const validation = await dynamicTravelTimeCalculator
          .validateNewSlotPlacement(
            roomId,
            new Date(date),
            slot.startTime,
            slot.endTime,
            memberLocation
          );

        availabilityResults.push({
          startTime: slot.startTime,
          endTime: slot.endTime,
          available: validation.valid,
          // ❌ reason은 반환하지 않음 (조원에게 이동시간 비공개)
        });
      }

      res.json({
        date,
        slots: availabilityResults,
        travelMode: room.confirmedTravelMode
      });

    } catch (error) {
      console.error('가능한 시간대 조회 실패:', error);
      res.status(500).json({ msg: '서버 오류가 발생했습니다.' });
    }
  };

  // 헬퍼 함수
  function generateTimeSlots(startHour, endHour, intervalMinutes) {
    const slots = [];
    for (let hour = startHour; hour < endHour; hour++) {
      for (let min = 0; min < 60; min += intervalMinutes) {
        const startTime = `${String(hour).padStart(2, '0')}:${String(min).padStart(2, '0')}`;
        const endMinutes = min + intervalMinutes;
        const endHour = hour + Math.floor(endMinutes / 60);
        const endMin = endMinutes % 60;
        const endTime = `${String(endHour).padStart(2, '0')}:${String(endMin).padStart(2, '0')}`;

        slots.push({ startTime, endTime });
      }
    }
    return slots;
  }

================================================================================
🎯 Phase 2: 백엔드 - 교환 승인 시 전체 스케줄 재계산
================================================================================

[2-1] 교환 승인 로직 수정
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: server/controllers/coordinationExchangeController.js

🔹 수정 함수: approveExchangeRequest()

  exports.approveExchangeRequest = async (req, res) => {
    try {
      // ... 기존 교환 승인 로직 ...

      // ⭐ 교환 후 해당 날짜의 이동시간 재계산
      const affectedDates = new Set();

      // 교환된 슬롯들의 날짜 수집
      affectedDates.add(request.timeSlot.date);
      if (request.targetSlot) {
        affectedDates.add(request.targetSlot.date);
      }

      // 각 날짜별로 이동시간 재계산
      for (const date of affectedDates) {
        await recalculateScheduleForDate(room._id, date);
      }

      await room.save();

      res.json({
        msg: '교환이 승인되었습니다.',
        recalculatedDates: Array.from(affectedDates)
      });

    } catch (error) {
      console.error('교환 승인 실패:', error);
      res.status(500).json({ msg: '교환 승인에 실패했습니다.' });
    }
  };

[2-2] 스케줄 재계산 서비스
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: server/services/scheduleRecalculator.js (신규)

  /**
   * 특정 날짜의 전체 스케줄 재계산
   * 교환, 삽입, 삭제 등으로 순서가 바뀌었을 때 호출
   */
  async function recalculateScheduleForDate(roomId, date) {
    const room = await Room.findById(roomId)
      .populate('owner', 'homeLocation');

    // 1. 해당 날짜의 모든 슬롯 조회 (시간순 정렬)
    const slotsForDate = room.timeSlots
      .filter(slot => isSameDay(slot.date, date))
      .sort((a, b) => timeToMinutes(a.startTime) - timeToMinutes(b.startTime));

    if (slotsForDate.length === 0) return;

    // 2. 각 슬롯의 이동시간 재계산
    let previousLocation = room.ownerHomeLocation;

    for (let i = 0; i < slotsForDate.length; i++) {
      const slot = slotsForDate[i];

      // 이전 위치 → 현재 슬롯 위치까지 이동시간 계산
      const travelTime = await dynamicTravelTimeCalculator
        .calculateTravelTimeBetween(
          previousLocation,
          slot.location,
          room.confirmedTravelMode || 'transit'
        );

      // ⚠️ 주의: TimeSlot 스키마에 이동시간 필드를 저장하지 않음!
      // 이동시간은 항상 동적으로 계산함
      // 단, 캐싱을 위해 임시로 메모리에 저장할 수는 있음 (선택사항)

      previousLocation = slot.location;
    }

    // 3. 재계산 완료 로그
    console.log(`✅ [재계산 완료] ${date}: ${slotsForDate.length}개 슬롯`);
  }

  module.exports = { recalculateScheduleForDate };

================================================================================
🎯 Phase 3: 프론트엔드 - 조원 UI 수정
================================================================================

[3-1] coordinationService.js API 함수 추가
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: client/src/services/coordinationService.js

  /**
   * 조원이 선택 가능한 시간대 목록 조회
   */
  async getAvailableSlots(roomId, memberId, date, memberLocation) {
    const token = await getAuthToken();
    const params = new URLSearchParams({
      memberId,
      date,
      memberLocation: JSON.stringify(memberLocation)
    });

    const res = await fetch(
      `${API_BASE_URL}/api/coordination/rooms/${roomId}/available-slots?${params}`,
      {
        headers: { 'Authorization': `Bearer ${token}` }
      }
    );

    if (!res.ok) throw new Error('가능한 시간대 조회 실패');
    return await res.json();
  }

[3-2] 교환 요청 모달 수정
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: client/src/components/modals/ChangeRequestModal.js

  const [availableSlots, setAvailableSlots] = useState([]);
  const [memberLocation, setMemberLocation] = useState(null);

  // 모달 오픈 시 가능한 시간대 조회
  useEffect(() => {
    if (isOpen && currentRoom && memberLocation) {
      coordinationService.getAvailableSlots(
        currentRoom._id,
        user.id,
        selectedDate,
        memberLocation
      )
      .then(data => {
        setAvailableSlots(data.slots);
      })
      .catch(err => {
        console.error('가능한 시간대 조회 실패:', err);
      });
    }
  }, [isOpen, currentRoom, selectedDate, memberLocation]);

  // 시간 선택 시 검증
  const handleTimeSelect = (startTime, endTime) => {
    const slot = availableSlots.find(
      s => s.startTime === startTime && s.endTime === endTime
    );

    if (!slot || !slot.available) {
      showAlert('선택할 수 없는 시간입니다', 'error');
      return;
    }

    setSelectedTime({ startTime, endTime });
  };

  // 시간표 그리드 렌더링
  return (
    <div className="time-grid">
      {availableSlots.map(slot => (
        <div
          key={`${slot.startTime}-${slot.endTime}`}
          className={`time-slot ${
            slot.available ? 'available' : 'blocked'
          }`}
          onClick={() => slot.available && handleTimeSelect(slot.startTime, slot.endTime)}
        >
          {slot.startTime} - {slot.endTime}
          {!slot.available && (
            <div className="blocked-tooltip">
              선택할 수 없습니다
              {/* ❌ 이유는 표시하지 않음! */}
            </div>
          )}
        </div>
      ))}
    </div>
  );

[3-3] 위치 정보 입력 UI 추가
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: client/src/components/modals/ChangeRequestModal.js

  // 조원이 수업 위치를 입력할 수 있는 필드 추가
  const [locationInput, setLocationInput] = useState('');

  const handleLocationChange = async (address) => {
    setLocationInput(address);

    // Google Maps Geocoding API로 주소 → 좌표 변환
    try {
      const result = await geocodeAddress(address);
      setMemberLocation({
        type: 'coordinates',
        address: address,
        coordinates: {
          lat: result.lat,
          lng: result.lng
        }
      });
    } catch (error) {
      console.error('주소 변환 실패:', error);
    }
  };

  return (
    <div className="location-input-section">
      <label>수업 위치</label>
      <input
        type="text"
        placeholder="예: 서울시 강남구 테헤란로 123"
        value={locationInput}
        onChange={(e) => handleLocationChange(e.target.value)}
      />
      <small>위치를 입력하면 선택 가능한 시간을 확인할 수 있습니다</small>
    </div>
  );

================================================================================
🎯 Phase 4: 타이머 시작 조건 변경
================================================================================

[4-1] 방장이 이동수단 선택 시 타이머 시작
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: server/controllers/coordinationSchedulingController.js

🔹 새 엔드포인트: POST /api/coordination/rooms/:roomId/start-confirmation-timer

  exports.startConfirmationTimer = async (req, res) => {
    try {
      const { roomId } = req.params;
      const { travelMode } = req.body;

      const room = await Room.findById(roomId);

      if (!room) {
        return res.status(404).json({ msg: '방을 찾을 수 없습니다.' });
      }

      if (!room.isOwner(req.user.id)) {
        return res.status(403).json({ msg: '방장만 이동수단을 선택할 수 있습니다.' });
      }

      // 이미 확정되었으면 변경 불가
      if (room.confirmedTravelMode) {
        return res.status(400).json({ msg: '이미 이동수단이 확정되었습니다.' });
      }

      // 타이머 시작
      room.confirmedTravelMode = travelMode;
      room.autoConfirmAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24시간 후

      await room.save();

      res.json({
        msg: '이동수단이 선택되었습니다. 24시간 후 자동 확정됩니다.',
        travelMode,
        autoConfirmAt: room.autoConfirmAt
      });

    } catch (error) {
      console.error('타이머 시작 실패:', error);
      res.status(500).json({ msg: '타이머 시작에 실패했습니다.' });
    }
  };

[4-2] 프론트엔드 - TravelModeButtons 수정
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: client/src/components/coordination/TravelModeButtons.js

  const handleModeSelect = async (modeId) => {
    if (confirmedTravelMode) {
      showAlert('이미 이동수단이 확정되었습니다', 'error');
      return;
    }

    if (!window.confirm(`${getModeLabel(modeId)} 모드를 선택하시겠습니까? 선택 후 24시간 뒤 자동 확정됩니다.`)) {
      return;
    }

    try {
      const result = await coordinationService.startConfirmationTimer(
        currentRoom._id,
        modeId
      );

      showAlert(
        `${getModeLabel(modeId)} 모드가 선택되었습니다.\n${formatDate(result.autoConfirmAt)}에 자동 확정됩니다.`,
        'success'
      );

      // 방 정보 새로고침
      await fetchRoomDetails(currentRoom._id);

    } catch (error) {
      showAlert(`모드 선택 실패: ${error.message}`, 'error');
    }
  };

[4-3] runAutoSchedule 수정
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: server/controllers/coordinationSchedulingController.js

  exports.runAutoSchedule = async (req, res) => {
    try {
      // ... 기존 자동배정 로직 ...

      // ❌ 타이머를 자동으로 시작하지 않음
      // room.autoConfirmAt = new Date(Date.now() + 24 * 60 * 60 * 1000);

      // ✅ 스케줄만 생성
      room.timeSlots = assignedSlots;
      await room.save();

      res.json({
        msg: '자동 배정이 완료되었습니다. 이동수단을 선택해주세요.',
        assignedSlots: assignedSlots.length
      });

    } catch (error) {
      // ...
    }
  };

================================================================================
📊 구현 순서 및 체크리스트
================================================================================

□ Phase 1: 백엔드 - 동적 이동시간 계산 엔진
  □ 1-1: Room 모델에 위치 정보 필드 추가
    □ TimeSlot.location 필드 추가
    □ Room.ownerHomeLocation 필드 추가
    □ 마이그레이션 스크립트 작성 (기존 데이터 처리)

  □ 1-2: dynamicTravelTimeCalculator.js 서비스 생성
    □ calculateTravelTimeBetween() 구현
    □ simulateScheduleWithNewSlot() 구현
    □ validateNewSlotPlacement() 구현
    □ 유닛 테스트 작성

  □ 1-3: available-slots API 엔드포인트 추가
    □ GET /api/coordination/rooms/:roomId/available-slots 구현
    □ generateTimeSlots() 헬퍼 함수 구현
    □ 테스트: 다양한 시나리오에서 가능한 시간대 확인

□ Phase 2: 백엔드 - 교환 승인 시 재계산
  □ 2-1: scheduleRecalculator.js 서비스 생성
    □ recalculateScheduleForDate() 구현
    □ 날짜별 슬롯 정렬 로직
    □ 이동시간 재계산 로직

  □ 2-2: 교환 승인 로직 수정
    □ approveExchangeRequest()에 재계산 호출 추가
    □ 영향받는 날짜 수집 로직
    □ 테스트: A-B 교환 시 이동시간 변경 확인

□ Phase 3: 프론트엔드 - 조원 UI
  □ 3-1: coordinationService.js API 함수 추가
    □ getAvailableSlots() 구현
    □ startConfirmationTimer() 구현

  □ 3-2: ChangeRequestModal.js 수정
    □ 위치 입력 UI 추가
    □ 가능한 시간대 조회 로직
    □ 선택 불가 시간 비활성화
    □ 스타일링 (.blocked 클래스)

  □ 3-3: 위치 정보 입력 컴포넌트
    □ Google Maps Autocomplete 통합
    □ 주소 → 좌표 변환 (Geocoding API)

□ Phase 4: 타이머 시작 조건
  □ 4-1: startConfirmationTimer API 추가
    □ POST /api/coordination/rooms/:roomId/start-confirmation-timer 구현
    □ autoConfirmAt 설정 로직
    □ 중복 선택 방지

  □ 4-2: TravelModeButtons.js 수정
    □ handleModeSelect() 구현
    □ 확인 모달 추가
    □ 타이머 시작 알림

  □ 4-3: runAutoSchedule 수정
    □ 자동 타이머 시작 제거
    □ 스케줄만 생성하도록 변경

================================================================================
🧪 테스트 시나리오
================================================================================

[시나리오 1: 기본 동적 이동시간 계산]
  전제:
    - 방장 집: 서울시 강남구
    - A 위치: 강남역 (방장 집에서 60분)
    - B 위치: 역삼역 (강남역에서 10분)

  테스트 1-1: A가 첫 번째일 때
    - 월요일 9:00에 A 배정
    - 확인: A 이동시간 = 60분 (방장 집 → A)
    - 확인: 실제 시작 가능 시간 = 8:00

  테스트 1-2: B를 A 앞에 배치
    - 월요일 9:00 B, 11:00 A로 변경
    - 확인: B 이동시간 = ??? (방장 집 → B)
    - 확인: A 이동시간 = 10분 (B → A)

[시나리오 2: 교환 후 이동시간 변화]
  전제:
    - 월요일: A(9:00), B(11:00)
    - A 이동시간: 60분, B 이동시간: 10분

  테스트 2-1: A와 B 교환
    - 교환 요청 생성 및 승인
    - 확인: B 이동시간 = 60분으로 변경
    - 확인: A 이동시간 = 10분으로 변경
    - 확인: 조원들에게 변경사항 반영

[시나리오 3: 조원의 시간 선택 제약]
  전제:
    - 12:00-13:00 금지시간
    - 11:00에 A 배정 (A → 다음 위치 20분)

  테스트 3-1: 조원이 13:00 선택 시도
    - 계산: 11:00 수업 종료 + 20분 이동 = 11:20 도착
    - 확인: 11:20 ~ 13:00 사이에 금지시간(12:00-13:00) 포함
    - 확인: 13:00 선택 불가로 표시
    - 확인: 조원에게 이유 표시 안 됨

[시나리오 4: 중간 삽입 시 재계산]
  전제:
    - 월요일: A(9:00), C(13:00)
    - C 이동시간: A → C = 90분

  테스트 4-1: B를 11:00에 삽입
    - B 추가 요청
    - 확인: A(9:00), B(11:00), C(13:00) 순서
    - 확인: B 이동시간 = A → B 계산
    - 확인: C 이동시간 = B → C로 변경 (90분에서 감소)

[시나리오 5: 타이머 시작]
  테스트 5-1: 자동배정 후 타이머 미시작
    - 방장이 자동배정 실행
    - 확인: autoConfirmAt = null
    - 확인: 타이머 표시 안 됨

  테스트 5-2: 이동수단 선택 후 타이머 시작
    - 방장이 "대중교통" 선택
    - 확인: autoConfirmAt 설정됨
    - 확인: 타이머 시작 알림
    - 확인: 조원에게 제약 적용

================================================================================
⚠️ 주의사항 및 최적화
================================================================================

[1] 성능 최적화
  ⚠️ 문제: 매번 Google Maps API 호출하면 비용 및 속도 문제
  ✅ 해결:
    - 이동시간 캐싱 (Redis 또는 메모리 캐시)
    - 캐시 키: `${fromLocation.lat},${fromLocation.lng}-${toLocation.lat},${toLocation.lng}-${travelMode}`
    - TTL: 24시간 (이동시간은 시간대에 따라 변할 수 있음)

[2] 방장의 이동시간 비공개 유지
  ❌ 절대 노출하지 말 것:
    - API 응답에서 이동시간 수치
    - 에러 메시지에 이동시간 언급
    - 프론트엔드 콘솔 로그에 이동시간 출력

  ✅ 조원에게 보여줄 것:
    - "선택 가능" / "선택 불가능" 결과만
    - "선택할 수 없습니다" 간단한 메시지

[3] UX 고려사항
  - 너무 많은 시간이 차단되면 조원 혼란
  - 안내 메시지: "현재 선택 가능한 시간이 제한되어 있습니다"
  - 가능한 시간이 없을 경우: "선택 가능한 시간이 없습니다. 다른 날짜를 선택해주세요"

[4] 데이터 일관성
  - 교환 승인 시 트랜잭션 처리 필요
  - 재계산 중 다른 교환 요청 차단 (락)
  - 재계산 실패 시 롤백

[5] 초기 데이터 마이그레이션
  - 기존 TimeSlot에 location 필드 없음
  - 마이그레이션 스크립트로 기본 위치 설정
  - 또는 조원이 위치 입력할 때까지 임시 위치 사용

================================================================================
📝 예상 소요 시간
================================================================================

Phase 1: 동적 이동시간 계산 엔진 ................. 6-8시간
  - 위치 모델 설계 및 마이그레이션 (2시간)
  - dynamicTravelTimeCalculator 구현 (3-4시간)
  - available-slots API 구현 (1-2시간)

Phase 2: 교환 승인 시 재계산 .................... 3-4시간
  - scheduleRecalculator 구현 (2-3시간)
  - 교환 로직 통합 (1시간)

Phase 3: 프론트엔드 조원 UI ..................... 4-5시간
  - API 함수 추가 (1시간)
  - 위치 입력 UI (2-3시간)
  - 시간 선택 제약 UI (1시간)

Phase 4: 타이머 시작 조건 ....................... 2-3시간
  - 백엔드 API (1시간)
  - 프론트엔드 통합 (1-2시간)

테스트 및 디버깅 ................................ 4-6시간
최적화 (캐싱, 성능 튜닝) ........................ 2-3시간
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
총 예상 시간: 21-29시간

================================================================================
🎯 핵심 요약 (발표용)
================================================================================

[문제]
조원들은 방장의 이동시간을 볼 수 없지만, 이동시간 때문에 실제로 불가능한 시간을
선택하면 충돌이 발생함.

[해결]
이동시간을 "사람의 속성"이 아닌 "일정 간 관계"로 정의하고,
조원이 시간을 선택할 때 시스템이 내부적으로 시뮬레이션을 수행하여
실제로 가능한 시간만 선택 가능하도록 사전에 필터링함.

[핵심 기술]
1. 동적 이동시간 계산: 순서, 요일, 앞뒤 일정에 따라 매번 새로 계산
2. 스케줄 시뮬레이션: 조원의 선택을 전체 스케줄에 적용해보고 검증
3. 결과만 공개: 조원에게는 "가능/불가능" 결과만 표시, 이유는 숨김

[효과]
- 조원의 위치 정보 비공개 유지
- 선택 후 충돌 제거 (사전 방지)
- 현실적인 시간표만 제시

================================================================================
