===============================================================================
스케줄링 시스템 버그 분석 및 해결방안
작성일: 2025-12-29
===============================================================================

[목차]
1. 프로젝트 구조 개요
2. 버그 1: 선호시간 밖 배정 문제
3. 버그 2: 이동시간 재계산 문제
4. 해결 방안 및 구현 계획


===============================================================================
1. 프로젝트 구조 개요
===============================================================================

[핵심 파일 구조]
프로젝트는 client/server 구조로 되어있으며, 주요 스케줄링 로직은 server 쪽에 위치

server/
├── services/
│   ├── schedulingAlgorithm/
│   │   ├── index.js                              # 메인 스케줄링 알고리즘
│   │   ├── services/
│   │   │   └── publicTransportAssignmentService.js  # 대중교통 모드 배정
│   │   ├── helpers/
│   │   │   └── assignmentHelper.js               # 배정 헬퍼 함수들
│   │   ├── utils/
│   │   │   └── timeUtils.js                      # 시간 검증 유틸
│   │   └── validators/
│   │       └── prohibitedTimeValidator.js        # 금지시간 검증
│   ├── dynamicTravelTimeCalculator.js            # 이동시간 계산
│   └── scheduleRecalculator.js                   # 스케줄 재계산
└── utils/
    └── scheduleMoveHandler.js                     # 일정 이동 처리


[주요 흐름]
1. 사용자가 "대중교통 보기" 버튼 클릭
2. schedulingAlgorithm/index.js에서 transportMode='public' 으로 설정
3. publicTransportAssignmentService.assignByPublicTransport() 호출
4. assignmentHelper.findNearestMemberWithSufficientTime()로 각 멤버 검증
5. timeUtils.validateTimeSlotWithTravel()로 이동시간+수업시간 검증
6. assignTimeSlot()으로 타임테이블에 실제 배정


===============================================================================
2. 버그 1: 선호시간 밖 배정 문제
===============================================================================

[증상]
- 예시 시나리오:
  * 방장: 월화수 9-12, 13-17시 선호시간
  * a: 화요일 13:20-14:00, 16:30-17:00 선호시간
  * b: 선호시간 없음
  * 1시간 배정 시 a는 13:20-14:00, 16:30-16:50이 수업시간

- "대중교통 보기" 클릭 시:
  * 13:20-14:20이 이동시간이 되고
  * 14:20-15:00, 16:30-16:50이 수업시간이 됨
  * ❌ 문제: 14:20-15:00은 a의 선호시간(13:20-14:00, 16:30-17:00) 밖임!


[원인 분석]

1. 현재 로직의 문제점:

   [파일: publicTransportAssignmentService.js:92-138]
   ```
   const result = await findNearestMemberWithSufficientTime({
     currentLocation,
     currentEndTime: currentEndTime || '09:00',
     candidateMembers: unassignedMembers,
     currentDay: DAY_MAP[dayOfWeek],
     classDurationMinutes: minClassDurationMinutes,
     transportMode,
     roomBlockedTimes,
     roomExceptions
   });
   ```

   → findNearestMemberWithSufficientTime()가 호출되어 시간 검증은 하지만,
      검증 실패 시 명확한 알림 메커니즘이 없음


2. validateTimeSlotWithTravel 로직 분석:

   [파일: timeUtils.js:327-408]
   - 이동시간 + 수업시간이 선호시간 내에 들어가는지 검증
   - 예외시간(점심시간 등)과 충돌 시 자동으로 시간을 뒤로 밀어냄
   - ❌ 문제: 밀린 결과가 선호시간을 벗어나도 isValid=true를 반환할 수 있음!

   예시:
   - 선호시간: 13:20-14:00 (40분)
   - 이동시간: 60분, 수업시간: 60분 (총 120분 필요)
   - 13:20부터 시작해도 15:20까지 필요 → 선호시간(14:00) 초과!
   - 하지만 findNextAvailableSlot()은 preferenceEnd 체크만 하고 반환


3. 부분 배정 로직:

   [파일: assignmentHelper.js:404-428]
   - 전체 시간 배정 실패 시 부분 배정 시도
   - 30분 단위로 줄여가며 배정 가능 여부 확인
   - ❌ 문제: 부분 배정이 성공하더라도 선호시간을 벗어날 수 있음


[근본 원인]
→ 배정 가능 여부 검증은 하지만, "선호시간 내에서만" 배정해야 한다는
   제약 조건이 충분히 강제되지 않음
→ 알림 없이 선호시간 밖으로 밀려나는 경우가 발생


===============================================================================
3. 버그 2: 이동시간 재계산 문제
===============================================================================

[증상]
- 예시 시나리오:
  * 초기 상태: 월요일에 a, b 모두 배정됨
    - 방장 → a (이동시간 20분)
    - a → b (이동시간 10분)

  * a를 화요일로 이동:
    - 월요일: 방장 → b (이동시간 30분이어야 함)
    - ❌ 문제: b의 이동시간이 10분으로 유지됨!

  * b를 다시 화요일로 이동:
    - 화요일: 방장 → a → b
    - ❌ 문제: 이동시간이 재계산되지 않음


[원인 분석]

1. 현재 일정 이동 로직:

   [파일: scheduleMoveHandler.js:전체]
   - handleScheduleMoveRequest()가 일정 이동 요청 처리
   - 원본 일정 삭제 → 새 일정 추가
   - ❌ 문제: 이동 후 scheduleRecalculator 호출이 없음!


2. 재계산 로직은 존재함:

   [파일: scheduleRecalculator.js:42-129]
   - recalculateScheduleForDate(roomId, date) 함수 존재
   - 특정 날짜의 모든 슬롯을 시간순으로 정렬
   - 각 슬롯의 이동시간을 이전 위치 기준으로 재계산
   - ✅ 로직 자체는 정상

   예시:
   ```
   방장 → a (20분) → b (10분)

   a 제거 후:
   방장 → b (30분)  ← 재계산됨
   ```


3. 재계산이 트리거되지 않는 이유:

   [파일: scheduleMoveHandler.js:전체]
   - 일정 이동 처리는 프론트엔드 상태만 변경
   - 백엔드 Room 모델 업데이트 없음
   - scheduleRecalculator 호출 없음

   → 즉, 재계산 로직은 있지만 호출되지 않음!


[근본 원인]
→ 일정 이동 시 영향받는 날짜들에 대해 자동으로 재계산을 트리거하는
   메커니즘이 없음
→ 특히 다음 두 날짜를 재계산해야 함:
   1. 원본 날짜 (이동 전)
   2. 목표 날짜 (이동 후)


===============================================================================
4. 해결 방안 및 구현 계획
===============================================================================

┌─────────────────────────────────────────────────────────────────────┐
│ 버그 1: 선호시간 밖 배정 문제 - 해결 방안                           │
└─────────────────────────────────────────────────────────────────────┘

[해결 전략]
배정이 선호시간을 벗어날 경우 명확한 알림을 제공하고,
사용자가 인지할 수 있도록 함


[구현 계획]

Step 1: validateTimeSlotWithTravel 강화
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: server/services/schedulingAlgorithm/utils/timeUtils.js

현재 코드 (라인 327-408):
- findNextAvailableSlot()이 preferenceEnd 체크만 함
- 선호시간 초과 시 { impossible: true } 반환
- ✅ 이 부분은 이미 정상 작동

추가 필요:
- validateTimeSlotWithTravel()에서 반환 시 추가 정보 제공
- 선호시간 내 배정 가능 여부 명시
- 필요한 최소 선호시간 길이 정보 제공

수정 예시:
```javascript
// 기존
return { isValid: false, reason: `[${dayOfWeek}] ${preferenceStart}-${preferenceEnd}: ${result.reason}` };

// 수정 후
return {
  isValid: false,
  reason: `[${dayOfWeek}] ${preferenceStart}-${preferenceEnd}: ${result.reason}`,
  preferenceInsufficient: true,  // ← 추가
  requiredMinutes: totalDurationMinutes,  // ← 추가
  availableMinutes: prefEndMinutes - prefStartMinutes  // ← 추가
};
```


Step 2: findNearestMemberWithSufficientTime 알림 강화
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: server/services/schedulingAlgorithm/helpers/assignmentHelper.js

현재 코드 (라인 404-428):
- 부분 배정 시도는 하지만 실패 원인이 명확하지 않음

수정 필요:
1. 검증 실패한 멤버들을 추적
2. 실패 원인별로 분류 (선호시간 부족, 금지시간 충돌 등)
3. 함수 반환값에 실패 정보 포함

수정 예시:
```javascript
// 함수 시작 부분에 추가
const failedMembers = [];

// 각 멤버 검증 실패 시
if (!fullValidation.isValid) {
  failedMembers.push({
    memberId: member.user._id.toString(),
    memberName: member.user.displayName || memberId.substring(0, 8),
    reason: fullValidation.reason,
    preferenceInsufficient: fullValidation.preferenceInsufficient,
    requiredMinutes: fullValidation.requiredMinutes,
    availableMinutes: fullValidation.availableMinutes
  });
}

// 함수 끝에서 반환
if (모든 멤버 실패) {
  return {
    allFailed: true,
    failedMembers: failedMembers
  };
}
```


Step 3: assignByPublicTransport 알림 처리
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: server/services/schedulingAlgorithm/services/publicTransportAssignmentService.js

현재 코드 (라인 92-138):
- result가 null이면 단순히 다음 날로 이동

수정 필요:
1. result.allFailed === true 체크
2. 실패한 멤버들의 정보를 수집
3. 알림 메시지 생성하여 반환

수정 예시:
```javascript
const result = await findNearestMemberWithSufficientTime({ ... });

if (!result) {
  console.log(`   → [${DAY_MAP[dayOfWeek]}] 더 이상 배정 불가, 다음 요일로 이동`);
  break;
}

// ← 여기에 추가
if (result.allFailed) {
  console.log(`   ⚠️  모든 멤버 배정 실패:`);
  result.failedMembers.forEach(fm => {
    if (fm.preferenceInsufficient) {
      console.log(`     - ${fm.memberName}: 선호시간 부족 (필요: ${fm.requiredMinutes}분, 가용: ${fm.availableMinutes}분)`);
    } else {
      console.log(`     - ${fm.memberName}: ${fm.reason}`);
    }
  });
  break;
}
```


Step 4: 메인 알고리즘에서 알림 수집 및 반환
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: server/services/schedulingAlgorithm/index.js

현재 코드 (라인 200-211):
```javascript
return {
  assignments,
  carryOverAssignments,
  unassignedMembersInfo
};
```

수정 필요:
- 알림 정보를 수집하여 반환
- 프론트엔드에서 사용자에게 표시

수정 예시:
```javascript
// 알림 수집용 배열 (메인 함수 시작 부분)
const warnings = [];

// assignByPublicTransport 호출 시
const publicTransportResult = await assignByPublicTransport(...);
if (publicTransportResult?.warnings) {
  warnings.push(...publicTransportResult.warnings);
}

// 반환 시
return {
  assignments,
  carryOverAssignments,
  unassignedMembersInfo,
  warnings  // ← 추가
};
```


Step 5: 프론트엔드 알림 표시
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: client/src/... (해당 컴포넌트)

구현 필요:
- 백엔드에서 warnings 배열 받기
- 알림 모달/토스트로 표시

표시 내용 예시:
```
⚠️ 일부 멤버를 배정할 수 없습니다:

- a: 선호시간이 부족합니다
  (필요: 120분, 가용: 40분)

- b: 선호시간이 없습니다
```



┌─────────────────────────────────────────────────────────────────────┐
│ 버그 2: 이동시간 재계산 문제 - 해결 방안                           │
└─────────────────────────────────────────────────────────────────────┘

[해결 전략]
일정이 이동될 때 자동으로 영향받는 날짜들의 이동시간을 재계산


[구현 계획]

Step 1: 일정 이동 시 재계산 트리거 추가
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: server/utils/scheduleMoveHandler.js

현재 코드:
- 일정 이동만 처리하고 끝
- Room 모델 업데이트 없음

수정 필요:
1. 일정 이동 후 Room 모델 업데이트
2. 영향받는 날짜 추출 (원본 날짜, 목표 날짜)
3. scheduleRecalculator 호출

수정 예시 (패턴 1 마지막 부분, 라인 150 이후):
```javascript
// 기존 반환 전에 추가

// ===== 이동시간 재계산 트리거 =====
const { recalculateScheduleForDate } = require('../services/scheduleRecalculator');

// 1. Room 모델 업데이트 (roomId는 파라미터로 추가 필요)
const room = await Room.findById(roomId);
if (!room) {
  return {
    isMoveRequest: true,
    result: {
      success: false,
      understood: `...`,
      action: 'room_not_found',
      explanation: '방을 찾을 수 없습니다.'
    }
  };
}

// 2. 원본 날짜와 목표 날짜 추출
const sourceDateObj = foundSchedule.date;  // Date 객체
const targetDateObj = new Date(sourceDateObj);
// targetDay를 반영하여 날짜 계산 (요일 차이 계산)
// (이 부분은 실제 날짜 계산 로직 필요)

// 3. 재계산 실행
try {
  await recalculateScheduleForDate(roomId, sourceDateObj);  // 원본 날짜
  await recalculateScheduleForDate(roomId, targetDateObj);  // 목표 날짜

  console.log(`✅ [이동시간 재계산 완료]`);
} catch (error) {
  console.error(`❌ [이동시간 재계산 실패]`, error);
}

// 4. 기존 반환
return {
  isMoveRequest: true,
  result: {
    success: true,
    ...
  }
};
```


Step 2: 날짜 계산 로직 보완
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
현재 문제:
- 요일 기반으로 이동하는데, 실제 Date 객체를 어떻게 구할지 불명확
- 예: "월요일 일정을 화요일로" → 어느 주의 화요일?

해결 방안:
1. Room 모델에서 currentWeek 정보 가져오기
2. 요일 → 날짜 변환 헬퍼 함수 작성

새 헬퍼 함수:
```javascript
/**
 * 요일 코드를 기준으로 해당 주의 Date 객체 반환
 * @param {Date} weekStart - 주 시작 날짜 (월요일)
 * @param {string} dayCode - 요일 코드 (월, 화, 수, ...)
 * @returns {Date}
 */
function getDayDateFromWeekStart(weekStart, dayCode) {
  const dayMap = { '월': 1, '화': 2, '수': 3, '목': 4, '금': 5, '토': 6, '일': 0 };
  const dayOffset = dayMap[dayCode];

  const result = new Date(weekStart);
  result.setDate(result.getDate() + dayOffset - 1);  // 월요일이 1
  return result;
}
```


Step 3: 재계산 결과 프론트엔드 반영
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: server/services/scheduleRecalculator.js

현재 코드:
- 재계산 후 결과 반환
- ✅ 로직은 정상

추가 필요:
- 재계산 결과를 응답에 포함
- 프론트엔드에서 UI 업데이트

수정 예시 (scheduleMoveHandler.js에서):
```javascript
// 재계산 실행
const recalcResult1 = await recalculateScheduleForDate(roomId, sourceDateObj);
const recalcResult2 = await recalculateScheduleForDate(roomId, targetDateObj);

// 반환 시
return {
  isMoveRequest: true,
  result: {
    success: true,
    understood: `...`,
    action: 'move',
    schedule: updatedSchedule,
    fixedSchedules: updatedFixedSchedules,
    explanation: `✅ ${title}을 ${sourceDayKor}에서 ${targetDayKorean}요일 ${targetTime}로 이동했어요! 😊`,
    movedSchedule: newSchedule,

    // ← 추가
    recalculationResults: {
      sourceDate: {
        date: sourceDateObj,
        recalculatedCount: recalcResult1.recalculatedCount,
        slots: recalcResult1.slots
      },
      targetDate: {
        date: targetDateObj,
        recalculatedCount: recalcResult2.recalculatedCount,
        slots: recalcResult2.slots
      }
    }
  }
};
```


Step 4: API 엔드포인트 수정
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: server/routes/... (일정 이동 API)

수정 필요:
1. roomId를 파라미터로 전달받도록 수정
2. handleScheduleMoveRequest에 roomId 전달
3. 재계산 결과를 응답에 포함

예시:
```javascript
router.post('/move-schedule', async (req, res) => {
  const { roomId, message, currentSchedule, fixedSchedules } = req.body;

  const result = await handleScheduleMoveRequest(
    message,
    currentSchedule,
    fixedSchedules,
    roomId  // ← 추가
  );

  res.json(result);
});
```


Step 5: 프론트엔드 UI 업데이트
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
구현 필요:
- 재계산 결과를 받아서 UI 업데이트
- 이동시간 변경 사항을 시각적으로 표시

표시 내용 예시:
```
✅ 구몬을 월요일에서 화요일로 이동했어요!

📍 이동시간이 재계산되었습니다:
- 월요일: b의 이동시간 10분 → 30분
- 화요일: a의 이동시간 20분 유지, b의 이동시간 10분
```



┌─────────────────────────────────────────────────────────────────────┐
│ 구현 우선순위                                                        │
└─────────────────────────────────────────────────────────────────────┘

[우선순위 1: 버그 2 해결 (이동시간 재계산)]
- 이유: 데이터 정합성 문제로 더 심각
- 예상 작업 시간: 4-6시간
- 핵심 파일:
  * scheduleMoveHandler.js (재계산 트리거 추가)
  * scheduleRecalculator.js (이미 구현됨, 활용만 하면 됨)

[우선순위 2: 버그 1 해결 (선호시간 밖 배정 알림)]
- 이유: 사용자 경험 개선
- 예상 작업 시간: 6-8시간
- 핵심 파일:
  * timeUtils.js (반환값 강화)
  * assignmentHelper.js (실패 정보 수집)
  * publicTransportAssignmentService.js (알림 처리)
  * 프론트엔드 (알림 UI)


┌─────────────────────────────────────────────────────────────────────┐
│ 주의사항 및 고려사항                                                 │
└─────────────────────────────────────────────────────────────────────┘

1. 버그 1 해결 시 주의사항:
   - validateTimeSlotWithTravel()의 반환값 변경이 기존 코드에 영향을 주지 않도록
     하위 호환성 유지
   - warnings 배열이 없는 경우에도 프론트엔드가 정상 작동하도록 방어 코드 추가

2. 버그 2 해결 시 주의사항:
   - 재계산이 너무 자주 발생하지 않도록 최적화
   - 재계산 실패 시에도 이동 자체는 성공하도록 예외 처리
   - Room 모델 업데이트 시 트랜잭션 고려

3. 테스트 케이스:
   - 버그 1: 선호시간이 짧은 멤버 + 긴 이동시간
   - 버그 2: 여러 멤버가 한 날에 배정된 상태에서 순서 변경

4. 성능 고려:
   - 재계산이 무거운 연산이므로 비동기 처리 필요
   - 대량의 일정 이동 시 배치 재계산 고려


===============================================================================
문서 끝
===============================================================================
