================================================================================
조원 시간 선택 기능 - 실제 사용 예제 코드
================================================================================


예제 1: 조원이 특정 시간을 선택할 때 검증하기
================================================================================

// React 컴포넌트 예제
import React, { useState } from 'react';
import travelScheduleCalculator from './services/travelScheduleCalculator';

function MemberScheduleSelector({ currentRoom, currentUser, travelMode }) {
  const [selectedDate, setSelectedDate] = useState('2025-12-20');
  const [selectedTime, setSelectedTime] = useState('');
  const [validationResult, setValidationResult] = useState(null);

  const handleTimeSelect = async (time) => {
    // "09:00" → 540분으로 변환
    const timeMinutes = travelScheduleCalculator.parseTime(time);
    const classDuration = 60; // 1시간 수업

    // 시뮬레이션 실행
    const result = await travelScheduleCalculator.simulateTimeSlotPlacement(
      currentRoom,
      currentUser._id,
      selectedDate,
      timeMinutes,
      classDuration,
      travelMode
    );

    setValidationResult(result);

    if (result.canPlace) {
      // ✅ 배치 가능
      alert(`선택 가능합니다!\n수업 시간: ${result.activityStart} - ${result.activityEnd}`);
      setSelectedTime(time);
    } else {
      // ❌ 배치 불가
      alert('이 시간은 선택할 수 없습니다.');
    }
  };

  return (
    <div>
      <h2>시간 선택</h2>
      <input
        type="date"
        value={selectedDate}
        onChange={(e) => setSelectedDate(e.target.value)}
      />

      <div className="time-grid">
        {['09:00', '10:00', '11:00', '13:00', '14:00', '15:00'].map(time => (
          <button
            key={time}
            onClick={() => handleTimeSelect(time)}
            className="time-slot"
          >
            {time}
          </button>
        ))}
      </div>

      {validationResult && (
        <div>
          <h3>검증 결과:</h3>
          <p>배치 가능: {validationResult.canPlace ? '✅' : '❌'}</p>
          {validationResult.canPlace && (
            <>
              <p>수업 시간: {validationResult.activityStart} - {validationResult.activityEnd}</p>
              {/* 이동시간은 표시하지 않음 (조원에게 숨김) */}
            </>
          )}
        </div>
      )}
    </div>
  );
}


================================================================================
예제 2: 시간표 그리드에 금지 구간 표시하기
================================================================================

import React, { useState, useEffect } from 'react';
import travelScheduleCalculator from './services/travelScheduleCalculator';

function TimetableGrid({ currentRoom, currentUser, selectedDate, travelMode }) {
  const [blockedTimes, setBlockedTimes] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadBlockedTimes();
  }, [currentRoom, selectedDate, travelMode]);

  const loadBlockedTimes = async () => {
    setLoading(true);
    const blocked = await travelScheduleCalculator.getBlockedTimesForMember(
      currentRoom,
      currentUser._id,
      selectedDate,
      travelMode
    );
    setBlockedTimes(blocked);
    setLoading(false);
  };

  const isTimeBlocked = (time) => {
    return blockedTimes.some(blocked => {
      const blockStart = travelScheduleCalculator.parseTime(blocked.startTime);
      const blockEnd = travelScheduleCalculator.parseTime(blocked.endTime);
      const currentTime = travelScheduleCalculator.parseTime(time);

      return currentTime >= blockStart && currentTime < blockEnd;
    });
  };

  const handleTimeClick = async (time) => {
    if (isTimeBlocked(time)) {
      alert('이 시간은 선택할 수 없습니다.');
      return;
    }

    // 추가 검증
    const timeMinutes = travelScheduleCalculator.parseTime(time);
    const result = await travelScheduleCalculator.simulateTimeSlotPlacement(
      currentRoom,
      currentUser._id,
      selectedDate,
      timeMinutes,
      60,
      travelMode
    );

    if (result.canPlace) {
      // 시간 선택 처리
      console.log('선택된 시간:', time);
    }
  };

  if (loading) return <div>로딩 중...</div>;

  // 09:00 ~ 18:00 시간표 생성
  const timeSlots = [];
  for (let hour = 9; hour < 18; hour++) {
    for (let minute = 0; minute < 60; minute += 10) {
      const time = travelScheduleCalculator.formatTime(hour * 60 + minute);
      timeSlots.push(time);
    }
  }

  return (
    <div className="timetable-grid">
      {timeSlots.map(time => {
        const blocked = isTimeBlocked(time);
        return (
          <div
            key={time}
            className={`time-slot ${blocked ? 'blocked' : 'available'}`}
            onClick={() => handleTimeClick(time)}
            style={{
              backgroundColor: blocked ? '#e0e0e0' : '#ffffff',
              cursor: blocked ? 'not-allowed' : 'pointer',
              border: '1px solid #ccc',
              padding: '8px',
              margin: '2px'
            }}
          >
            {time}
          </div>
        );
      })}
    </div>
  );
}


================================================================================
예제 3: 순서 변경 시 이동시간 재계산
================================================================================

import React, { useState } from 'react';
import travelScheduleCalculator from './services/travelScheduleCalculator';

function ScheduleReorder({ currentRoom, travelMode }) {
  const [schedules, setSchedules] = useState([
    { id: 1, userId: 'user1', name: 'A', time: '09:00', day: '2025-12-20' },
    { id: 2, userId: 'user2', name: 'B', time: '10:00', day: '2025-12-20' }
  ]);

  const swapSchedules = async (index1, index2) => {
    const newSchedules = [...schedules];
    [newSchedules[index1], newSchedules[index2]] = [newSchedules[index2], newSchedules[index1]];

    // 순서 변경 후 각 스케줄의 이동시간 재계산
    for (let i = 0; i < newSchedules.length; i++) {
      const schedule = newSchedules[i];
      const timeMinutes = travelScheduleCalculator.parseTime(schedule.time);

      const result = await travelScheduleCalculator.simulateTimeSlotPlacement(
        currentRoom,
        schedule.userId,
        schedule.day,
        timeMinutes,
        60,
        travelMode
      );

      console.log(`${schedule.name}의 이동시간:`, result.travelTime);
      console.log(`  출발: ${result.from}`);
      console.log(`  도착: ${result.to}`);
    }

    setSchedules(newSchedules);
  };

  return (
    <div>
      <h2>스케줄 순서 변경</h2>
      {schedules.map((schedule, index) => (
        <div key={schedule.id} style={{ padding: '10px', border: '1px solid #ccc', margin: '5px' }}>
          <span>{schedule.name} - {schedule.time}</span>
          {index > 0 && (
            <button onClick={() => swapSchedules(index, index - 1)}>
              ↑ 위로
            </button>
          )}
          {index < schedules.length - 1 && (
            <button onClick={() => swapSchedules(index, index + 1)}>
              ↓ 아래로
            </button>
          )}
        </div>
      ))}
    </div>
  );
}


================================================================================
예제 4: 선택 가능한 모든 시간대 미리 계산하기
================================================================================

import React, { useState, useEffect } from 'react';
import travelScheduleCalculator from './services/travelScheduleCalculator';

function AvailableTimesList({ currentRoom, currentUser, selectedDate, travelMode }) {
  const [availableTimes, setAvailableTimes] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadAvailableTimes();
  }, [currentRoom, selectedDate, travelMode]);

  const loadAvailableTimes = async () => {
    setLoading(true);
    const classDuration = 60; // 1시간 수업

    const result = await travelScheduleCalculator.getAvailableTimesForMember(
      currentRoom,
      currentUser._id,
      selectedDate,
      classDuration,
      travelMode
    );

    setAvailableTimes(result.availableSlots);
    setLoading(false);
  };

  if (loading) return <div>선택 가능한 시간대를 계산 중...</div>;

  return (
    <div>
      <h2>선택 가능한 시간대 ({availableTimes.length}개)</h2>
      <div className="available-times">
        {availableTimes.map((slot, index) => (
          <div key={index} className="available-slot" style={{ padding: '10px', margin: '5px', border: '1px solid green' }}>
            <strong>{slot.startTime}</strong>
            <p>실제 수업: {slot.actualActivityStart} - {slot.actualActivityEnd}</p>
            {/* 이동시간 정보는 표시하지 않음 */}
          </div>
        ))}
      </div>
    </div>
  );
}


================================================================================
예제 5: 드래그 앤 드롭으로 시간 조정하기
================================================================================

import React, { useState } from 'react';
import travelScheduleCalculator from './services/travelScheduleCalculator';

function DraggableSchedule({ currentRoom, currentUser, initialTime, selectedDate, travelMode }) {
  const [currentTime, setCurrentTime] = useState(initialTime);
  const [isDragging, setIsDragging] = useState(false);

  const handleDragEnd = async (newTime) => {
    const timeMinutes = travelScheduleCalculator.parseTime(newTime);

    // 새로운 시간이 유효한지 검증
    const result = await travelScheduleCalculator.simulateTimeSlotPlacement(
      currentRoom,
      currentUser._id,
      selectedDate,
      timeMinutes,
      60,
      travelMode
    );

    if (result.canPlace) {
      // ✅ 유효한 시간 - 변경 허용
      setCurrentTime(newTime);
      alert(`시간이 ${newTime}으로 변경되었습니다.\n실제 수업: ${result.activityStart} - ${result.activityEnd}`);
    } else {
      // ❌ 유효하지 않은 시간 - 원래 시간으로 복원
      alert('이 시간으로 변경할 수 없습니다.');
    }

    setIsDragging(false);
  };

  return (
    <div
      className={`draggable-schedule ${isDragging ? 'dragging' : ''}`}
      draggable
      onDragStart={() => setIsDragging(true)}
      onDragEnd={() => setIsDragging(false)}
    >
      <h3>내 수업</h3>
      <p>시간: {currentTime}</p>
      <button onClick={() => handleDragEnd('11:00')}>11:00으로 변경</button>
      <button onClick={() => handleDragEnd('14:00')}>14:00으로 변경</button>
    </div>
  );
}


================================================================================
예제 6: 실시간 충돌 알림
================================================================================

import React, { useState, useEffect } from 'react';
import travelScheduleCalculator from './services/travelScheduleCalculator';

function RealTimeConflictChecker({ currentRoom, currentUser, selectedDate, selectedTime, travelMode }) {
  const [conflicts, setConflicts] = useState([]);

  useEffect(() => {
    checkConflicts();
  }, [selectedTime, selectedDate, travelMode]);

  const checkConflicts = async () => {
    if (!selectedTime) return;

    const timeMinutes = travelScheduleCalculator.parseTime(selectedTime);
    const result = await travelScheduleCalculator.simulateTimeSlotPlacement(
      currentRoom,
      currentUser._id,
      selectedDate,
      timeMinutes,
      60,
      travelMode
    );

    if (!result.canPlace) {
      setConflicts(result.conflicts);
    } else {
      setConflicts([]);
    }
  };

  if (conflicts.length === 0) {
    return <div className="no-conflicts">✅ 충돌 없음</div>;
  }

  return (
    <div className="conflicts-warning">
      <h3>⚠️ 선택할 수 없는 시간입니다</h3>
      <ul>
        {conflicts.map((conflict, index) => (
          <li key={index}>
            {conflict.type === 'blocked' && `금지시간: ${conflict.name}`}
            {conflict.type === 'overlap' && `다른 일정과 겹침: ${conflict.time}`}
          </li>
        ))}
      </ul>
    </div>
  );
}


================================================================================
사용 팁
================================================================================

1. 성능 최적화
   - getAvailableTimesForMember는 많은 시뮬레이션을 수행하므로
     필요할 때만 호출하세요 (예: 날짜 변경 시)

2. 로딩 상태 표시
   - 이동시간 계산은 Google Maps API를 호출하므로
     로딩 인디케이터를 표시하세요

3. 에러 처리
   - try-catch로 네트워크 오류를 처리하세요
   - 주소 정보가 없는 경우 사용자에게 안내하세요

4. 캐싱
   - 같은 날짜/시간을 반복 검증할 때는 결과를 캐싱하세요


================================================================================
