================================================================================
📋 이동시간 시스템 완전 통합 구현 계획
================================================================================
작성일: 2025-12-16
목적: 이동시간 모드를 표시 레이어가 아닌 실제 데이터로 통합하여 모든 기능이 일관되게 작동하도록 수정

================================================================================
🔥 핵심 문제 5가지
================================================================================

문제 1: 이동시간 모드 동기화 및 적용
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
현상:
  - 방장이 "대중교통" 모드 선택 → 조원 화면에는 표시되지만
  - 챗봇, 교환 요청은 여전히 일반 모드(이동시간 없음) 기준으로 작동
  - 조원이 보는 시간(10:00, 13:00) ≠ 실제 저장된 시간(9:00, 10:00)

원인:
  - 서버 timeSlots는 항상 일반 모드 데이터
  - enhancedSchedule은 클라이언트에서만 계산되는 표시용 데이터

해결:
  ✅ 서버에 이동시간 포함 스케줄 저장
  ✅ currentTravelMode에 맞는 timeSlots를 DB에 저장
  ✅ 모든 API(교환, 챗봇, available-slots)가 현재 모드 기준으로 작동


문제 2: 자동배정이 금지시간 침범
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
현상:
  - 4시간 배정 시 A(13-17), B(17-20:10) ← 금지시간 침범!
  - 선호시간이 작아도 무리하게 한 블록에 배정

원인:
  - 자동배정 알고리즘이 "블록 분할 최소화"만 고려
  - 금지시간 검증 부족

해결:
  ✅ 금지시간을 절대 침범하지 않도록 검증 강화
  ✅ 필요하면 블록을 나눠서 배정 (예: 3시간 + 3시간)
  ✅ schedulingAlgorithm.js 수정


문제 3: 확정 시 이동시간 포함 저장 문제
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
현상:
  - 확정 시 일반 모드 시간만 저장됨
  - 확정 후에도 자동배정처럼 중복 추가됨

원인:
  - 확정 로직이 currentTravelMode 무시
  - 확정 후 상태 관리 미흡

해결:
  ✅ 방장: 이동시간 포함하여 개인시간에 저장
  ✅ 조원: 수업시간만 저장 (이동시간 제외)
  ✅ 확정 후 중복 추가 방지 (confirmedAt 체크)


문제 4: 조원 시간 변경 시 이동시간 미고려
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
현상:
  - 조원은 이동시간을 보지 못하지만
  - 시간 변경 시 이동시간 부분이 금지시간인지 모름
  - 예: 수업 10시 (이동시간 9-10시) → 13시로 변경 시 12-13시 금지시간 체크 안 됨

원인:
  - 교환 모달, 챗봇이 이동시간 미고려

해결:
  ✅ available-slots API가 이동시간 포함하여 가능한 시간 계산
  ✅ 조원에게 이동시간 부분을 "선택 불가"로 표시 (이유는 숨김)


문제 5: 교환 시 이동시간 재계산 안 됨
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
현상:
  - A, B 교환 시 순서가 바뀌지만 이동시간은 그대로

원인:
  - 교환 승인 후 scheduleRecalculator 호출 안 됨

해결:
  ✅ 교환 승인 시 scheduleRecalculator로 이동시간 재계산
  ✅ 재계산된 스케줄을 DB에 저장


================================================================================
📊 구현 계획 (6단계)
================================================================================

Phase 1: Room 모델 수정 (30분)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: server/models/room.js

수정 내용:
  1. TimeSlot 스키마에 originalStartTime, originalEndTime 추가
     - 일반 모드 원본 시간 보관 (모드 전환 시 필요)

  2. TimeSlot 스키마에 adjustedForTravelTime 플래그 추가
     - 이동시간이 적용된 슬롯인지 표시

코드:
  ```javascript
  const timeSlotSchema = new mongoose.Schema({
    // 기존 필드...
    startTime: String,    // 현재 모드의 시작 시간
    endTime: String,      // 현재 모드의 종료 시간

    // 새로 추가
    originalStartTime: String,  // 일반 모드 원본 시작 시간
    originalEndTime: String,    // 일반 모드 원본 종료 시간
    adjustedForTravelTime: {    // 이동시간 적용 여부
      type: Boolean,
      default: false
    }
  });
  ```


Phase 2: 이동시간 적용 API 추가 (1-1.5시간)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: server/controllers/coordinationSchedulingController.js

새 API 엔드포인트:
  POST /api/coordination/rooms/:roomId/apply-travel-mode

기능:
  1. 프론트엔드에서 계산된 enhancedSchedule 받기
  2. DB의 timeSlots를 이동시간 포함 시간으로 교체
  3. originalStartTime, originalEndTime에 원본 저장
  4. currentTravelMode 설정
  5. Socket.io로 모든 사용자에게 알림

코드 구조:
  ```javascript
  exports.applyTravelMode = async (req, res) => {
    const { roomId } = req.params;
    const { travelMode, enhancedSchedule } = req.body;

    const room = await Room.findById(roomId);

    // 원본 저장 (첫 적용 시에만)
    room.timeSlots.forEach((slot, idx) => {
      const enhanced = enhancedSchedule[idx];
      if (!slot.originalStartTime) {
        slot.originalStartTime = slot.startTime;
        slot.originalEndTime = slot.endTime;
      }
      slot.startTime = enhanced.startTime;
      slot.endTime = enhanced.endTime;
      slot.adjustedForTravelTime = travelMode !== 'normal';
    });

    room.currentTravelMode = travelMode;
    await room.save();

    // Socket.io 알림
    io.to(roomId).emit('scheduleUpdated', room);

    res.json({ success: true, room });
  };
  ```


Phase 3: 프론트엔드 모드 변경 로직 수정 (1시간)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: client/src/hooks/useTravelMode.js

수정 내용:
  1. handleModeChange에서 enhancedSchedule 계산 후 서버로 전송
  2. applyTravelMode API 호출 추가

코드:
  ```javascript
  const handleModeChange = async (newMode) => {
    // 1. 이동시간 계산
    const enhanced = await travelScheduleCalculator.recalculate(
      currentRoom,
      newMode
    );

    setEnhancedSchedule(enhanced);

    // 2. 서버에 저장 (방장만)
    if (isOwner) {
      await coordinationService.applyTravelMode(
        currentRoom._id,
        newMode,
        enhanced.timeSlots
      );
    }
  };
  ```


Phase 4: 자동배정 알고리즘 금지시간 검증 강화 (1.5-2시간)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: server/services/schedulingAlgorithm.js

수정 내용:
  1. 배정 전 금지시간 검증 강화
  2. 블록이 금지시간 침범 시 분할
  3. 분할 후에도 조건 만족하는지 재검증

로직:
  ```javascript
  function assignSlot(member, duration, availableSlots, prohibitedTimes) {
    // 1. 연속된 시간 찾기
    let bestSlot = findContinuousSlot(availableSlots, duration);

    // 2. 금지시간 검증
    if (overlapsProhibitedTime(bestSlot, prohibitedTimes)) {
      // 3. 블록 분할 시도
      const splitSlots = splitSlotToAvoidProhibited(
        duration,
        availableSlots,
        prohibitedTimes
      );

      if (splitSlots.length > 0) {
        return splitSlots;  // 예: [3시간, 3시간]
      } else {
        throw new Error('금지시간을 피할 수 없습니다');
      }
    }

    return [bestSlot];
  }
  ```


Phase 5: 확정 시 이동시간 포함 저장 (1시간)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: server/controllers/coordinationSchedulingController.js

수정 내용:
  1. confirmSchedule API에서 currentTravelMode 확인
  2. 방장: 이동시간 포함 저장 (startTime 그대로)
  3. 조원: 원본 시간 저장 (originalStartTime 사용)
  4. confirmedAt 설정으로 중복 방지

코드:
  ```javascript
  exports.confirmSchedule = async (req, res) => {
    const room = await Room.findById(roomId);

    // 이미 확정됐으면 중복 방지
    if (room.confirmedAt) {
      return res.status(400).json({
        error: '이미 확정된 스케줄입니다'
      });
    }

    for (const slot of room.timeSlots) {
      const member = await User.findById(slot.user);

      // 방장: 이동시간 포함 저장
      if (member._id.equals(room.owner)) {
        await Profile.addPersonalTime({
          startTime: slot.startTime,  // 이동시간 포함
          endTime: slot.endTime
        });
      }
      // 조원: 수업시간만 저장
      else {
        await Profile.addPersonalTime({
          startTime: slot.originalStartTime || slot.startTime,
          endTime: slot.originalEndTime || slot.endTime
        });
      }
    }

    room.confirmedAt = new Date();
    room.confirmedTravelMode = room.currentTravelMode;
    await room.save();
  };
  ```


Phase 6: 교환 승인 시 이동시간 재계산 (30분)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 파일: server/controllers/coordinationExchangeController.js

수정 내용:
  1. 교환 승인 후 scheduleRecalculator 호출
  2. 재계산된 스케줄을 applyTravelMode로 저장

코드:
  ```javascript
  exports.approveExchange = async (req, res) => {
    // ... 교환 로직

    // 교환 완료 후 이동시간 재계산 (현재 모드가 이동시간 모드일 때만)
    if (room.currentTravelMode && room.currentTravelMode !== 'normal') {
      const recalculated = await scheduleRecalculator.recalculateScheduleForDate(
        room,
        [affectedDate]
      );

      // 재계산된 스케줄 적용
      await applyTravelMode(room._id, room.currentTravelMode, recalculated);
    }

    await room.save();
  };
  ```


================================================================================
📝 테스트 시나리오
================================================================================

시나리오 1: 이동시간 모드 동기화
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. 방장이 자동배정 실행
2. 방장이 "대중교통" 모드 선택
3. 조원 화면 확인: 대중교통 시간표 표시
4. 조원이 챗봇으로 교환 요청
   - 예상: 대중교통 모드 시간 기준으로 교환
   - 확인: 방장 시간표에서도 대중교통 시간으로 교환됨


시나리오 2: 자동배정 금지시간 검증
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. 방장 금지시간: 18:00-24:00
2. A, B 선호시간: 13:00-17:00
3. 4시간 배정 실행
4. 예상: A(13-17), B(13-17 다른 날) 또는 분할
5. 확인: 금지시간(18시 이후) 침범 안 함


시나리오 3: 확정 시 이동시간 포함 저장
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. 대중교통 모드로 자동배정: A(10:00), B(13:00)
2. 타이머 만료 또는 수동 확정
3. 프로필 > 개인시간 확인
   - 방장: 8:00-11:00 (이동시간 포함)
   - A: 10:00-11:00 (수업시간만)
   - B: 13:00-14:00 (수업시간만)


시나리오 4: 조원 시간 변경 시 이동시간 고려
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. A 수업: 10:00 (이동시간 9:00-10:00)
2. 방장 금지시간: 12:00-13:00
3. 조원 A가 13:00으로 변경 시도
4. 예상: "선택할 수 없습니다" (이동시간 12-13시가 금지시간)
5. 확인: 14:00은 선택 가능


시나리오 5: 교환 시 이동시간 재계산
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. 월요일: A(10:00), B(13:00)
   - A 이동시간: 방장 집 → A = 1시간 (9-10)
   - B 이동시간: A → B = 1시간 (12-13)
2. A와 B 교환 승인
3. 예상: B(10:00), A(13:00)
   - B 이동시간: 방장 집 → B = 1시간 (9-10)
   - A 이동시간: B → A = 1시간 (12-13)
4. 확인: 이동시간이 자동으로 재계산됨


================================================================================
⏱️ 예상 시간
================================================================================

Phase 1: Room 모델 수정                    30분
Phase 2: 이동시간 적용 API 추가            1-1.5시간
Phase 3: 프론트엔드 모드 변경 로직 수정    1시간
Phase 4: 자동배정 금지시간 검증 강화       1.5-2시간
Phase 5: 확정 시 이동시간 포함 저장        1시간
Phase 6: 교환 승인 시 이동시간 재계산      30분

총 예상 시간: 5.5-6.5시간

================================================================================
✅ 완료 체크리스트
================================================================================

□ Phase 1: Room 모델 수정
  □ originalStartTime, originalEndTime 필드 추가
  □ adjustedForTravelTime 플래그 추가

□ Phase 2: 이동시간 적용 API
  □ POST /api/coordination/rooms/:roomId/apply-travel-mode 구현
  □ Socket.io 알림 추가

□ Phase 3: 프론트엔드 모드 변경
  □ useTravelMode.js 수정
  □ coordinationService.js에 applyTravelMode 함수 추가

□ Phase 4: 자동배정 금지시간 검증
  □ schedulingAlgorithm.js 수정
  □ 블록 분할 로직 추가

□ Phase 5: 확정 로직 수정
  □ confirmSchedule API 수정
  □ confirmedAt 중복 체크 추가
  □ 방장/조원 구분하여 저장

□ Phase 6: 교환 승인 재계산
  □ approveExchange에 scheduleRecalculator 호출 추가
  □ 재계산된 스케줄 applyTravelMode로 저장

================================================================================
