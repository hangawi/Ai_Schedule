==================================================================================================
타임테이블 이슈 해결 계획
==================================================================================================
작성일: 2026-01-05
작성자: Claude Code

==================================================================================================
📋 목차
==================================================================================================
1. 문제 요약
2. 문제 1 분석: 중간 시간대 삼삼 시간표 안 보이는 이슈
3. 문제 2 분석: 대중교통 외 교통수단 이동시간 표기 이슈
4. 해결 계획
5. 구현 우선순위
6. 테스트 계획

==================================================================================================
1. 문제 요약
==================================================================================================

**문제 1: 중간 시간대 조원 시간표가 안 보이는 이슈**
- 증상: 자동배정 후 대중교통보기를 누르면 중간에 있는 '삼삼' 계정의 시간표가 안 보임
- 예시:
  * a: 9:00-9:50 이동시간, 9:50-10:50 수업시간
  * b(삼삼): 10:50-11:00 이동시간, 11:00-12:00 수업시간 (← 안 보임!)
  * c: 13:00-13:10 이동시간, 13:10-15:10 수업시간
  * 하지만 b, c 둘 다 13시 이후로 배치되면 삼삼이 보임

**문제 2: 대중교통 외 교통수단 이동시간 표기 이슈**
- 증상: 대중교통보기는 잘 작동하지만 자동차/도보/자전거는 안 됨
- 구체적:
  * 일반 배정 → 자동차 보기 적용 → 조원 계정으로 챗봇을 통해 일정 이동
  * 결과: 모든 조원들의 이동시간이 바뀜
  * 원래: "방장 > 조원 > 조원"
  * 현재: "현재 주소 > 주소 > 주소"

==================================================================================================
2. 문제 1 분석: 중간 시간대 삼삼 시간표 안 보이는 이슈
==================================================================================================

**관련 파일:**
- client/src/components/timetable/WeekView.js

**원인 분석:**

1. **조원 Visibility Control 로직 (WeekView.js:732-748)**
   - 조원은 다른 사람의 슬롯을 보면 안 되도록 빗금 처리
   - 코드 위치: `getMergedTimeBlocks` 함수 내부
   
   ```javascript
   // 🔒 조원은 이동시간 슬롯을 절대 보면 안 됨
   if (!isRoomOwner && ownerInfo && ownerInfo.isTravel) {
     slotType = 'blocked';
     slotData = {
       name: '배정 불가',
       info: { type: 'travel_hidden' },
       isTravelHidden: true,
       ownerScheduleType: 'travel_hidden'
     };
   }
   ```

2. **다른 조원의 수업 시간도 빗금 처리 (WeekView.js:814-824)**
   ```javascript
   // 🔒 조원은 다른 사람의 슬롯을 빗금으로 표시
   if (!isRoomOwner && slotData && currentUser) {
     const currentUserId = currentUser.id || currentUser._id;
     const slotUserId = slotData.userId || slotData.actualUserId;
     if (slotUserId && slotUserId.toString() !== currentUserId.toString()) {
       slotType = 'blocked';
       slotData = { name: '배정 불가', ... };
     }
   }
   ```

3. **문제의 핵심:**
   - 이동시간 슬롯과 다른 조원의 수업 슬롯이 모두 같은 방식으로 빗금 처리됨
   - 병합 모드에서 연속된 빗금 블록이 하나로 합쳐짐
   - 결과: 중간에 있는 조원(삼삼)의 실제 수업 시간이 이동시간 빗금에 묻혀버림

4. **b, c 둘 다 13시 이후일 때 삼삼이 보이는 이유:**
   - 9:00-13:00 사이에 다른 수업(a)이 없으면 이동시간 빗금만 있음
   - 삼삼의 수업이 이동시간과 분리되어 표시됨

**해결 방향:**
- 조원의 본인 수업 시간은 항상 표시되어야 함
- 다른 조원의 수업은 "배정됨"으로 표시 (빗금 X)
- 이동시간만 빗금 처리

==================================================================================================
3. 문제 2 분석: 대중교통 외 교통수단 이동시간 표기 이슈
==================================================================================================

**관련 파일:**
- server/controllers/coordinationSchedulingController.js (applyTravelMode)
- client/src/services/travelScheduleCalculator.js
- server/controllers/coordinationExchangeController.js (smartExchange)

**원인 분석:**

1. **applyTravelMode 함수에서 travelSlots 저장 (Line 1145-1171)**
   ```javascript
   room.travelTimeSlots = receivedTravelSlots.map(e => {
     return {
       user: userId,
       date: dateObj,
       from: e.from,  // ← 여기서 from/to를 그대로 가져옴
       to: e.to,
       travelMode: e.travelMode || travelMode,
       travelInfo: e.travelInfo
     };
   });
   ```

2. **문제의 핵심:**
   - 대중교통보기: 처음 자동배정할 때 from/to가 올바르게 설정됨
   - 자동차/도보/자전거: 교통수단을 바꾸면서 from/to가 재계산되어야 하는데...
   - 챗봇으로 일정 이동 시: smartExchange가 호출되면서 모든 조원의 travelSlots가 재계산됨
   - 이때 from/to가 "방장 > 조원 > 조원" 대신 "현재 주소 > 주소 > 주소"로 바뀜

3. **추정 원인:**
   - travelScheduleCalculator.js에서 이동시간을 계산할 때 from/to를 결정하는 로직
   - 첫 번째 수업의 from은 "방장 주소"여야 하는데, "사용자 현재 주소"로 설정됨
   - 조원 계정으로 챗봇을 사용할 때, 조원의 주소를 기준으로 from/to가 재계산됨

4. **교통수단별 차이:**
   - 대중교통: 처음 설정 시 올바르게 저장되고, 이후 변경 없이 잘 작동
   - 자동차/도보/자전거: 교통수단 변경 또는 일정 이동 시 from/to가 재계산되면서 문제 발생

**해결 방향:**
- 챗봇을 통해 일정 이동 시 다른 조원의 travelSlots는 건드리지 않음
- 또는 travelSlots 재계산 시 첫 번째 수업의 from은 항상 "방장 주소"로 설정
- 교통수단 변경 시에도 from/to 정보를 유지

==================================================================================================
4. 해결 계획
==================================================================================================

**문제 1 해결 계획:**

□ Step 1: WeekView.js 수정
  파일: client/src/components/timetable/WeekView.js
  함수: getMergedTimeBlocks (Line 568-900)
  
  수정 내용:
  1. 조원이 자신의 수업을 볼 때는 항상 표시
  2. 다른 조원의 수업은 "배정됨" (주황색 등)으로 표시
  3. 이동시간만 빗금 처리
  
  변경 전:
  ```javascript
  // 모든 다른 조원의 슬롯을 빗금 처리
  if (!isRoomOwner && slotUserId !== currentUserId) {
    slotType = 'blocked';
    slotData = { name: '배정 불가', ... };
  }
  ```
  
  변경 후:
  ```javascript
  // 본인 수업은 표시, 다른 조원 수업은 "배정됨"으로 표시
  if (!isRoomOwner && slotUserId !== currentUserId) {
    slotType = 'occupied';  // 새로운 타입
    slotData = { name: '배정됨', color: '#FFA500', ... };
  }
  ```

□ Step 2: 병합 모드 렌더링 수정
  파일: client/src/components/timetable/WeekView.js
  함수: renderMergedView (Line 903-1150)
  
  수정 내용:
  1. 'occupied' 타입에 대한 스타일 추가
  2. 빗금은 이동시간과 금지시간에만 적용
  
  추가할 CSS:
  ```javascript
  ...(block.type === 'occupied' ? {
    backgroundColor: '#FFA500',
    borderColor: '#FF8C00'
  } : {})
  ```

□ Step 3: 일반 모드 렌더링 수정
  파일: client/src/components/timetable/WeekView.js
  함수: renderNormalView (Line 1154-1288)
  
  수정 내용:
  - TimeSlot 컴포넌트에 'occupied' 타입 전달

**문제 2 해결 계획:**

□ Step 1: smartExchange 함수 수정
  파일: server/controllers/coordinationExchangeController.js
  함수: smartExchange
  
  수정 내용:
  1. 일정 이동 시 현재 사용자의 travelSlots만 재계산
  2. 다른 조원의 travelSlots는 유지
  
  ```javascript
  // 현재 사용자의 슬롯만 필터링
  const userSlotsToUpdate = room.timeSlots.filter(slot => 
    slot.user.toString() === req.user.id.toString()
  );
  
  // 다른 조원의 travelSlots는 유지
  const otherUsersTravelSlots = room.travelTimeSlots.filter(slot => 
    slot.user.toString() !== req.user.id.toString()
  );
  
  // 재계산 후 병합
  room.travelTimeSlots = [...otherUsersTravelSlots, ...newUserTravelSlots];
  ```

□ Step 2: travelScheduleCalculator.js 수정
  파일: client/src/services/travelScheduleCalculator.js
  
  수정 내용:
  1. 첫 번째 수업의 from은 항상 "방장 주소" 또는 "집"으로 설정
  2. 마지막 수업의 to는 항상 "집"으로 설정
  3. 중간 수업들의 from/to는 이전/다음 수업의 주소로 설정
  
  ```javascript
  // 첫 번째 수업
  if (index === 0) {
    from = ownerAddress || '집';
  } else {
    from = previousClassAddress;
  }
  
  // 마지막 수업
  if (index === sortedClasses.length - 1) {
    to = '집';
  } else {
    to = nextClassAddress;
  }
  ```

□ Step 3: applyTravelMode 함수 수정
  파일: server/controllers/coordinationSchedulingController.js
  함수: applyTravelMode (Line 1109-1351)
  
  수정 내용:
  1. 교통수단 변경 시 from/to 정보 유지
  2. receivedTravelSlots가 없을 때 기존 travelTimeSlots 유지
  
  ```javascript
  // 교통수단만 변경할 때
  if (!receivedTravelSlots || receivedTravelSlots.length === 0) {
    // 기존 travelTimeSlots의 travelMode만 업데이트
    room.travelTimeSlots = room.travelTimeSlots.map(slot => ({
      ...slot,
      travelMode: travelMode
    }));
  }
  ```

==================================================================================================
5. 문제 2 실제 해결 방법 (2026-01-05 완료)
==================================================================================================

**원인 재분석:**
- Google Maps API가 driving/walking/bicycling 모드에서 ZERO_RESULTS 반환
- 이 경우 dynamicTravelTimeCalculator.js가 기본값 30분 반환 (Line 145)
- 기존의 정확한 이동시간(대중교통 모드로 계산된 값)이 30분으로 덮어씌워짐

**실제 해결 방법:**

✅ Step 1: travelTimeCache.js에 fallback 메서드 추가
  - getFromAnyMode() 메서드 추가
  - 다른 교통수단(transit, driving, walking, bicycling)의 캐시된 값 찾기
  - 우선순위: transit > driving > walking > bicycling

✅ Step 2: dynamicTravelTimeCalculator.js 수정 (Line 143-151)
  - API가 ZERO_RESULTS 반환 시
  - 다른 교통수단의 캐시된 값이 있는지 확인
  - 있으면 그 값을 사용하고 현재 모드에도 캐싱
  - 없으면 기본값 30분 반환

✅ Step 3: recalculateTravelTimeSlotsForDate 함수 수정 (Line 205-241)
  - **핵심 문제:** targetUserId로 필터링하면 previousSlot 컨텍스트 손실
  - **이전 로직:**
    * classSlots = targetUserId의 슬롯만 필터링
    * previousSlot = classSlots[i-1] (같은 사용자의 이전 슬롯)
    * 예: 화요일 A(9-10), B(10-11 새로 이동), C(11-12)
    * classSlots = [B만] → previousSlot = null → 방장→B 계산 (❌ 잘못!)
  - **수정 로직:**
    * classSlots = 해당 날짜의 전체 슬롯 (시간순 정렬)
    * loop에서 targetUserId 아니면 continue로 스킵
    * previousSlot = classSlots[i-1] (실제 이전 슬롯)
    * 예: classSlots = [A, B, C] → B 처리 시 previousSlot = A → A→B 계산 (✅ 정확!)

**동작 원리:**
1. 대중교통 모드 적용: API 성공 → 60분, 30분, 70분 캐싱
2. 자동차 모드로 변경: API 실패(ZERO_RESULTS) → 대중교통 캐시 찾기 → 60분, 30분, 70분 사용
3. 조원이 챗봇으로 일정 이동:
   - 전체 슬롯 컨텍스트 유지 → 올바른 previousSlot 참조
   - 캐시된 값 사용 → 이동시간 정확하게 계산 ✅

**수정된 파일:**
- server/services/schedulingAlgorithm/utils/travelTimeCache.js (getFromAnyMode 메서드 추가)
- server/services/dynamicTravelTimeCalculator.js (Line 143-151 수정)
- server/controllers/coordinationExchangeController.js (Line 205-241 수정)

**장점:**
- 교통수단 변경 시에도 정확한 이동시간 유지
- 불필요한 API 호출 감소
- 기존 로직 변경 최소화

==================================================================================================
6. 구현 완료 상태
==================================================================================================

✅ **문제 1: 조원 시간표 표시 - 해결 완료 (2026-01-05)**
  - client/src/components/timetable/WeekView.js Line 540 수정
  - ownerInfo 우선순위 조정으로 배치된 조원 시간표 표시
  
✅ **문제 2: 이동시간 표기 - 해결 완료 (2026-01-05)**
  - server/services/schedulingAlgorithm/utils/travelTimeCache.js (getFromAnyMode 추가)
  - server/services/dynamicTravelTimeCalculator.js (fallback 로직 추가)
  - server/controllers/coordinationExchangeController.js (previousSlot 컨텍스트 유지)
  - 교통수단 변경 시 캐시된 이동시간 재사용
  - 조원 일정 이동 시 올바른 이동시간 계산

==================================================================================================
7. 테스트 계획
==================================================================================================

**문제 1 테스트:**
1. 방장 계정으로 자동배정 실행
2. 대중교통보기 적용
3. 조원 계정(삼삼)으로 로그인
4. 본인의 수업 시간이 표시되는지 확인
5. 다른 조원의 수업은 "배정됨"으로 표시되는지 확인
6. 이동시간은 빗금으로 표시되는지 확인

**문제 2 테스트:**
1. 방장 계정으로 자동배정 실행
2. 대중교통보기 적용
3. from/to가 "방장 > 조원 > 조원"으로 표시되는지 확인
4. 자동차보기로 변경
5. from/to가 여전히 올바르게 표시되는지 확인
6. 조원 계정으로 로그인
7. 챗봇으로 일정 이동 ("2시간 뒤로 옮겨줘")
8. 본인의 일정만 이동되는지 확인
9. 다른 조원의 from/to가 변경되지 않았는지 확인
10. 본인의 from/to가 올바르게 표시되는지 확인

**통합 테스트:**
1. 여러 조원이 있는 방에서 테스트
2. 다양한 교통수단(대중교통, 자동차, 도보, 자전거) 테스트
3. 다양한 시간대 배치 테스트
4. 병합 모드/일반 모드 전환 테스트

==================================================================================================
8. 주의사항
==================================================================================================

1. **WeekView.js 수정 시:**
   - 기존 병합 로직을 최대한 유지
   - 성능 영향 최소화
   - 방장 뷰에 영향 없도록 주의

2. **smartExchange 수정 시:**
   - 기존 일정 이동 기능 유지
   - 다른 조원의 데이터 보호
   - 트랜잭션 처리 확인

3. **travelScheduleCalculator.js 수정 시:**
   - 모든 교통수단에 대해 동일하게 작동
   - from/to 로직 일관성 유지
   - null/undefined 처리

==================================================================================================
EOF
==================================================================================================
