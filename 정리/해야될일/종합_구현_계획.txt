================================================================================
작성일: 2025-12-19
버전: 3.0 (통합 계획)
목적: 이동시간 관련 모든 기능 통합 구현 계획
================================================================================

🎯 핵심 개념 정리
================================================================================

1. 이동시간은 "관계값"이다 (가장 중요!)
   - 이동시간 = (이전 일정의 위치) → (현재 일정의 위치)
   - 순서가 바뀌면 이동시간도 바뀜
   - 요일이 바뀌면 이동시간도 바뀔 수 있음

2. 조원들의 시간 교환 시 이동시간 제약
   - 조원들은 방장의 이동시간을 볼 수 없음 (비공개)
   - 하지만 다른 조원의 이동시간을 침범하면 안 됨
   - 시스템이 내부적으로 시뮬레이션하여 가능/불가능만 표시

3. 챗봇을 통한 시간표 변경 시 이동시간 유지
   - 대중교통 적용 후 챗봇으로 일정 변경 시
   - 수업 시간만 이동하면 안 되고, 이동시간도 함께 이동해야 함

================================================================================
📋 구현 작업 목록
================================================================================

┌─────────────────────────────────────────────────────────────────────┐
│ Phase 1: 챗봇 이동시간 처리 수정 (최우선)                              │
└─────────────────────────────────────────────────────────────────────┘

🔴 우선순위: 긴급
📁 영향 파일:
   - server/utils/scheduleMoveHandler.js
   - server/controllers/chatbotController.js
   - client/src/components/chat/handlers/scheduleHandlers.js

📌 문제점:
   현재: 챗봇으로 일정 이동 시 수업 시간만 이동, 이동시간 정보 손실
   예시:
   - 원본: 월 13:00-13:10 (이동) + 13:10-16:10 (수업)
   - 변경 후: 화 13:00-16:00 (이동시간 없음) ❌

✅ 작업 내용:

1.1. scheduleMoveHandler.js 수정
   위치: 186-193번 라인 (패턴 1), 346-354번 라인 (패턴 2)

   변경 전:
   ```javascript
   const newSchedule = {
     ...foundSchedule,
     days: [targetDayKorean],
     startTime: targetTime,
     endTime: newEndTime,
     type: wasFixed ? 'custom' : foundSchedule.type
   };
   ```

   변경 후:
   ```javascript
   const newSchedule = {
     ...foundSchedule,
     days: [targetDayKorean],
     startTime: targetTime,
     endTime: newEndTime,
     type: wasFixed ? 'custom' : foundSchedule.type,
     // 이동시간 관련 메타데이터 유지
     originalStartTime: foundSchedule.originalStartTime,
     originalEndTime: foundSchedule.originalEndTime,
     adjustedForTravelTime: foundSchedule.adjustedForTravelTime,
     travelTimeBefore: foundSchedule.travelTimeBefore,
     location: foundSchedule.location
   };
   ```

1.2. Room의 timeSlots 통합 확인
   - 챗봇이 수정하는 데이터가 Room.timeSlots인지 확인
   - Room.timeSlots에 이동시간 정보가 포함되어 있는지 검증
   - 필요 시 scheduleRecalculator 호출하여 이동시간 재계산

1.3. 이동 후 재계산 로직 추가
   ```javascript
   // 새 일정 추가 후
   updatedSchedule.push(newSchedule);

   // 이동시간 재계산 필요 여부 확인
   if (foundSchedule.adjustedForTravelTime) {
     // Room에 저장된 경우 scheduleRecalculator 호출
     // 또는 클라이언트에서 재계산 요청 트리거
   }
   ```

1.4. 테스트 시나리오
   [ ] 대중교통 적용 → 챗봇으로 일정 이동 → 이동시간 유지 확인
   [ ] 일반 모드 → 챗봇으로 일정 이동 → 정상 작동 확인
   [ ] 고정 일정 → 챗봇으로 일정 이동 → 정상 작동 확인

예상 시간: 4-6시간


┌─────────────────────────────────────────────────────────────────────┐
│ Phase 2: 조원 간 시간 교환 시 이동시간 검증 (중요)                      │
└─────────────────────────────────────────────────────────────────────┘

🟡 우선순위: 높음
📁 영향 파일:
   - server/controllers/coordinationExchangeRequestController.js
   - server/services/scheduleValidator.js (신규 또는 기존 파일)
   - client/src/components/coordination/TimeSelector.js

📌 요구사항:
   "배정될때 시간 교환.txt"의 핵심 개념 구현

   핵심 원칙:
   1. 조원들은 방장의 이동시간을 절대 볼 수 없음
   2. 조원이 시간 T를 선택할 때 시스템이 내부적으로 시뮬레이션
   3. 조원에게는 결과(가능/불가능)만 표시, 이유는 숨김

✅ 작업 내용:

2.1. 시뮬레이션 엔진 구현
   파일: server/services/scheduleSimulator.js (신규)

   ```javascript
   /**
    * 조원이 특정 시간을 선택했을 때 전체 스케줄 시뮬레이션
    * @param {string} roomId - 방 ID
    * @param {string} userId - 선택하는 조원 ID
    * @param {Date} targetDate - 목표 날짜
    * @param {string} targetTime - 목표 시간
    * @param {number} duration - 소요 시간
    * @returns {Object} { isValid, reason (internal only) }
    */
   async function simulateScheduleWithNewSlot(roomId, userId, targetDate, targetTime, duration) {
     // ① 해당 날짜의 전체 슬롯 조회
     // ② 새 슬롯을 시간순으로 삽입
     // ③ 모든 슬롯의 이동시간 재계산
     // ④ 각 슬롯이 다른 슬롯의 이동시간과 충돌하는지 확인
     // ⑤ 금지시간 침범 확인
     // ⑥ 결과 반환 (가능/불가능)
   }
   ```

2.2. coordinationExchangeRequestController.js 수정
   위치: createExchangeRequest 메서드

   변경:
   ```javascript
   // 요청 생성 전 시뮬레이션 수행
   const simulation = await scheduleSimulator.simulateScheduleWithNewSlot(
     roomId,
     requesterId,
     targetDate,
     targetTime,
     requiredDuration
   );

   if (!simulation.isValid) {
     return res.status(400).json({
       success: false,
       message: '해당 시간으로 변경할 수 없습니다.', // 이유는 숨김
       // reason은 로그에만 출력 (조원에게 보이지 않음)
     });
   }
   ```

2.3. 클라이언트 시간 선택 UI 개선
   파일: client/src/components/coordination/TimeSelector.js

   - 선택 불가능한 시간은 회색으로 표시
   - 툴팁: "선택할 수 없습니다" (이유 표시 안 함)
   - API 호출: /api/coordination/validate-time-slot

2.4. 동적 이동시간 계산 통합

   시나리오 예시:
   ```
   초기: 월요일 A(9:00), B(11:00)
   - A 이동: 방장 집 → A = 60분 (8:00-9:00)
   - B 이동: A → B = 10분 (10:50-11:00)

   C가 10:00 선택 시도:
   - 시뮬레이션: A(9:00), C(10:00), B(11:00)
   - A 이동: 방장 집 → A = 60분 (8:00-9:00)
   - C 이동: A → C = ? 분 (계산 필요)
   - B 이동: C → B = ? 분 (재계산 필요)

   결과:
   - C의 이동시간이 A의 9:00 수업 시간을 침범하면 → 불가능
   - 모든 제약 만족 → 가능
   ```

2.5. 테스트 시나리오
   [ ] 순서 변경 시 이동시간 재계산 확인
   [ ] 중간 삽입 시 뒤따르는 슬롯 이동시간 변경 확인
   [ ] 조원이 다른 조원 이동시간 침범 시 거부 확인
   [ ] 조원 UI에서 이동시간 정보 숨김 확인

예상 시간: 2-3일


┌─────────────────────────────────────────────────────────────────────┐
│ Phase 3: 대중교통 재계산 시 슬롯 손실 방지 (기존 이슈)                  │
└─────────────────────────────────────────────────────────────────────┘

🟢 우선순위: 중간
📁 영향 파일:
   - client/src/services/travelScheduleCalculator.js

📌 문제점: (리팩토링_계획.txt 내용)
   5시간 배정 시 대중교통 보기에서 1시간 손실 발생

✅ 작업 내용: (기존 계획 유지)

3.1. Phase 1: 긴급 수정
   [ ] 재배정 실패 시 원본 슬롯 유지 (완료)
   [ ] 원본 슬롯 유지 시 겹침 체크 추가
   [ ] UI 겹침 경고 표시

3.2. Phase 2: 중기 개선
   [ ] 재배정 실패 슬롯 수집 및 재시도
   [ ] 재배정 우선순위 조정

3.3. Phase 3: 장기 리팩토링
   [ ] 슬롯 그룹화 구조 변경
   [ ] 사용자별 일괄 처리

예상 시간: 1-2주 (기존 계획 참고)


┌─────────────────────────────────────────────────────────────────────┐
│ Phase 4: 통합 테스트 및 검증                                          │
└─────────────────────────────────────────────────────────────────────┘

🔵 우선순위: 중간
📁 영향 범위: 전체 시스템

✅ 테스트 시나리오:

4.1. 엔드투엔드 테스트
   [ ] 자동배정 → 대중교통 적용 → 챗봇으로 일정 변경 → 이동시간 유지 확인
   [ ] 자동배정 → 조원 간 시간 교환 → 이동시간 재계산 확인
   [ ] 챗봇 일정 변경 → 조원 간 시간 교환 → 충돌 검증

4.2. 회귀 테스트
   [ ] 기존 기능 정상 작동 확인 (일반 모드)
   [ ] 서버 자동 배정 로직 영향 없음 확인
   [ ] Google Calendar 동기화 영향 없음 확인

4.3. 성능 테스트
   [ ] 10명 이상 조원, 각 5시간 배정 시 처리 시간
   [ ] 시뮬레이션 응답 속도 (1초 이내 목표)

예상 시간: 3-5일

================================================================================
🗓️ 일정 계획
================================================================================

Week 1 (현재):
  Mon-Tue: Phase 1 (챗봇 이동시간 처리) 구현 및 테스트
  Wed-Fri: Phase 2 (조원 시간 교환 검증) 설계 및 구현 시작

Week 2:
  Mon-Wed: Phase 2 완료 및 테스트
  Thu-Fri: Phase 3.1 (긴급 수정) 적용

Week 3:
  Mon-Fri: Phase 3.2-3.3 (중장기 개선) 구현

Week 4:
  Mon-Wed: Phase 4 (통합 테스트)
  Thu-Fri: 버그 수정 및 최종 검증

================================================================================
⚠️ 위험 요소 및 대응
================================================================================

위험 1: 챗봇 수정으로 기존 기능 손상
  - 대응: 충분한 회귀 테스트, 일반 모드와 대중교통 모드 분리 테스트

위험 2: 시뮬레이션 성능 저하
  - 대응: 캐싱, 인덱싱, 비동기 처리

위험 3: 복잡한 시나리오에서 예상치 못한 동작
  - 대응: 로그 강화, 단계별 검증, 사용자 피드백 수집

================================================================================
📊 진행 상황 추적
================================================================================

Phase 1: 챗봇 이동시간 처리
  [ ] 1.1. scheduleMoveHandler.js 수정
  [ ] 1.2. Room.timeSlots 통합 확인
  [ ] 1.3. 이동 후 재계산 로직 추가
  [ ] 1.4. 테스트 완료

Phase 2: 조원 시간 교환 검증
  [ ] 2.1. 시뮬레이션 엔진 구현
  [ ] 2.2. coordinationExchangeRequestController 수정
  [ ] 2.3. 클라이언트 UI 개선
  [ ] 2.4. 동적 이동시간 계산 통합
  [ ] 2.5. 테스트 완료

Phase 3: 슬롯 손실 방지
  [ ] 3.1. Phase 1 완료
  [ ] 3.2. Phase 2 완료
  [ ] 3.3. Phase 3 완료

Phase 4: 통합 테스트
  [ ] 4.1. 엔드투엔드 테스트
  [ ] 4.2. 회귀 테스트
  [ ] 4.3. 성능 테스트

================================================================================
📌 핵심 참고 개념
================================================================================

이동시간 계산 시나리오 (반드시 숙지)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

시나리오 1: 순서 교환 시 이동시간 변경
  초기: 월 A(9:00), B(11:00)
  - A 이동: 방장 집 → A = 60분
  - B 이동: A → B = 10분

  교환 후: 월 B(9:00), A(11:00)
  - B 이동: 방장 집 → B = 60분 ← 변경!
  - A 이동: B → A = 10분 ← 변경!

시나리오 2: 중간 삽입 시 이동시간 재계산
  기존: A(9:00), C(13:00)
  - A 이동: 60분
  - C 이동: 90분

  B 삽입: A(9:00), B(11:00), C(13:00)
  - A 이동: 60분 (유지)
  - B 이동: 10분 (새로 계산)
  - C 이동: 40분 (90분 → 40분 감소!)

시나리오 3: 요일 변경 시 이동시간 변경
  월 A(9:00), B(11:00)
  - B 이동: A → B = 10분

  화 B(9:00) [혼자]
  - B 이동: 방장 집 → B = 60분 ← 같은 B인데 다른 시간!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

결론: 이동시간은 고정값이 아니라 동적으로 계산되는 제약 조건!

================================================================================
마지막 업데이트: 2025-12-19
작성자: Claude Code
상태: 계획 수립 완료, 구현 대기
================================================================================
