═══════════════════════════════════════════════════════════════════════════════
📋 이동시간 재계산 버그 상세 분석 및 해결방안
═══════════════════════════════════════════════════════════════════════════════
작성일: 2025-12-24
상태: 🔴 긴급 수정 필요
우선순위: ⭐⭐⭐⭐⭐ (최고)

═══════════════════════════════════════════════════════════════════════════════
📌 문제 요약
═══════════════════════════════════════════════════════════════════════════════

❌ 핵심 문제:
   챗봇으로 한 명이 일정을 이동하면, 같은 날짜의 다른 조원들의 이동시간도
   모두 재계산되어 버림!

❌ 재현 시나리오:
   1. 월요일 상태:
      - A 조원: 9-10시 이동시간, 10-12시 수업
      - B 조원: 13:00-13:10 이동시간, 13:10-15:10 수업

   2. B가 챗봇으로 화요일 14:10으로 이동

   3. 결과 (버그!):
      - A의 이동시간이 9-10시 → 9:10-10시로 변경됨! (왜?!)
      - 확정 후: A의 수업시간도 9:10-12시로 변경됨 (완전히 망가짐)

❌ 영향 범위:
   - 챗봇 빈자리 이동 시 발생
   - 같은 날짜의 모든 조원 영향
   - 자동배정 확정 시 데이터 손상

═══════════════════════════════════════════════════════════════════════════════
🔍 근본 원인 분석
═══════════════════════════════════════════════════════════════════════════════

1️⃣ 문제 발생 흐름
─────────────────────────────────────────────────────────────────────────────

[챗봇 요청]
  ↓
[smartExchange API 호출]
  ↓
[Case 1: 빈자리 이동]
  ├─ B의 월요일 슬롯 삭제
  ├─ B의 화요일 슬롯 생성
  └─ ❌ recalculateTravelTimeSlotsForDate(room, 월요일, ...)  호출
      │
      ├─ 월요일의 "모든 사람"의 이동시간 슬롯 삭제 ← A의 것도 삭제됨!
      ├─ 월요일의 "모든 사람"의 수업 슬롯 가져오기 ← A의 것도 포함됨!
      └─ "모든 사람"의 이동시간 재계산 ← A의 이동시간도 재계산됨!


2️⃣ 코드 레벨 분석
─────────────────────────────────────────────────────────────────────────────

📂 파일: server/controllers/coordinationExchangeController.js

🔴 문제 위치 1: smartExchange 함수 (1337-1351줄)
─────────────────────────────────────────────────────────────────────────────
// B가 이동할 때
await recalculateTravelTimeSlotsForDate(room, oldDate, room.owner._id, effectiveTravelMode);
await recalculateTravelTimeSlotsForDate(room, targetDate, room.owner._id, effectiveTravelMode);

❌ 문제점:
   - userId 파라미터가 없어서 모든 사람의 이동시간을 재계산함
   - B만 이동했는데 A, C, D... 모든 조원이 영향받음


🔴 문제 위치 2: recalculateTravelTimeSlotsForDate 함수 (76-137줄)
─────────────────────────────────────────────────────────────────────────────
// ① 해당 날짜의 이동시간 슬롯 "모두" 삭제
room.timeSlots = room.timeSlots.filter(slot => {
  const slotDate = new Date(slot.date).toISOString().split('T')[0];
  const isTravelSlot = slot.isTravel === true || slot.subject === '이동시간';
  const shouldDelete = slotDate === dateStr && isTravelSlot;
  return !shouldDelete;  // ❌ A, B, C... 모든 조원의 이동시간 삭제!
});

// ② 해당 날짜의 수업 슬롯 "모두" 가져오기
const classSlots = room.timeSlots.filter(slot => {
  const slotDate = new Date(slot.date).toISOString().split('T')[0];
  return slotDate === dateStr && !slot.isTravel;  // ❌ A, B, C... 모든 조원 포함!
}).sort(...);

// ③ "모든 조원"의 이동시간 재계산
for (let i = 0; i < classSlots.length; i++) {
  // ...이동시간 계산...  // ❌ A의 이동시간도 새로 계산됨!
}

❌ 문제점:
   - 특정 사용자만 재계산하는 기능이 없음
   - 날짜 기준으로만 필터링하여 모든 조원 영향


3️⃣ 왜 A의 이동시간이 9:10-10시로 바뀌는가?
─────────────────────────────────────────────────────────────────────────────

[추론 1] A의 첫 10분 슬롯 손실
  - A의 원래 슬롯: 10:00-10:10, 10:10-10:20, ..., 11:50-12:00
  - 어떤 과정에서 10:00-10:10 슬롯이 사라짐
  - 재계산 시 10:10-10:20이 첫 번째 슬롯이 됨
  - 이동시간이 10:10 기준으로 계산됨 → 9:10-10:10 (60분)

[추론 2] 메타데이터 손상
  - recalculateTravelTimeSlotsForDate는 메타데이터를 설정하지 않음
  - 확정 시 병합되면서 잘못된 메타데이터 사용
  - originalStartTime이 잘못 설정되어 이동시간 계산 오류


4️⃣ 추가 문제: 메타데이터 복사 오류
─────────────────────────────────────────────────────────────────────────────

📂 파일: server/controllers/coordinationExchangeController.js (1281-1311줄)

// smartExchange Case 1에서 새 슬롯 생성 시
const slotData = {
  startTime: currentTime,  // ✅ 새 위치 (14:10, 14:20, ...)
  endTime: slotEndTime,

  // ❌ 문제: 이전 위치의 메타데이터를 그대로 복사
  originalStartTime: allSlotsInBlock[0]?.originalStartTime,  // 13:10 (잘못됨!)
  originalEndTime: allSlotsInBlock[0]?.originalEndTime,      // 15:10 (잘못됨!)
  adjustedForTravelTime: allSlotsInBlock[0]?.adjustedForTravelTime,
};

❌ 문제점:
   - B가 13:10-15:10에서 14:10으로 이동
   - 새 슬롯에 originalStartTime: 13:10이 복사됨 (원래 위치)
   - 하지만 새 위치는 14:10이므로 originalStartTime: 14:10이어야 함
   - 확정 시 병합되면서 잘못된 메타데이터로 이동시간 계산 오류

═══════════════════════════════════════════════════════════════════════════════
✅ 해결방안
═══════════════════════════════════════════════════════════════════════════════

해결방안 1: 특정 사용자만 재계산 (⭐ 추천)
─────────────────────────────────────────────────────────────────────────────

📝 수정 내용:
   recalculateTravelTimeSlotsForDate 함수에 targetUserId 파라미터 추가
   → 지정된 사용자의 이동시간만 삭제/재계산


🔧 코드 수정 1: recalculateTravelTimeSlotsForDate 함수 시그니처 변경
─────────────────────────────────────────────────────────────────────────────
📂 파일: server/controllers/coordinationExchangeController.js (50줄)

[변경 전]
const recalculateTravelTimeSlotsForDate = async (room, date, ownerId, forceTravelMode = null) => {

[변경 후]
const recalculateTravelTimeSlotsForDate = async (room, date, ownerId, forceTravelMode = null, targetUserId = null) => {


🔧 코드 수정 2: 이동시간 삭제 로직 수정
─────────────────────────────────────────────────────────────────────────────
📂 파일: server/controllers/coordinationExchangeController.js (76-140줄)

[변경 전]
// ① 해당 날짜의 이동시간 슬롯 모두 삭제
room.timeSlots = room.timeSlots.filter(slot => {
  const slotDate = new Date(slot.date).toISOString().split('T')[0];
  const isTravelSlot = slot.isTravel === true || slot.subject === '이동시간';
  const shouldDelete = slotDate === dateStr && isTravelSlot;
  return !shouldDelete;
});

[변경 후]
// ① 특정 사용자의 이동시간 슬롯만 삭제
room.timeSlots = room.timeSlots.filter(slot => {
  const slotDate = new Date(slot.date).toISOString().split('T')[0];
  const isTravelSlot = slot.isTravel === true || slot.subject === '이동시간';

  // ✅ targetUserId가 지정되면 그 사용자의 것만 삭제
  if (targetUserId) {
    const slotUserId = String(slot.user._id || slot.user);
    const shouldDelete = slotDate === dateStr && isTravelSlot && slotUserId === String(targetUserId);
    return !shouldDelete;
  } else {
    // targetUserId가 없으면 전체 삭제 (기존 동작 유지)
    const shouldDelete = slotDate === dateStr && isTravelSlot;
    return !shouldDelete;
  }
});


🔧 코드 수정 3: 수업 슬롯 필터링 로직 수정
─────────────────────────────────────────────────────────────────────────────
📂 파일: server/controllers/coordinationExchangeController.js (142-150줄)

[변경 전]
// ② 해당 날짜의 수업 슬롯들만 가져와서 시간순 정렬
const classSlots = room.timeSlots
  .filter(slot => {
    const slotDate = new Date(slot.date).toISOString().split('T')[0];
    return slotDate === dateStr && !slot.isTravel;
  })
  .sort(...);

[변경 후]
// ② 특정 사용자의 수업 슬롯만 가져와서 시간순 정렬
const classSlots = room.timeSlots
  .filter(slot => {
    const slotDate = new Date(slot.date).toISOString().split('T')[0];
    const slotUserId = String(slot.user._id || slot.user);

    // ✅ targetUserId가 지정되면 그 사용자의 것만
    if (targetUserId) {
      return slotDate === dateStr && !slot.isTravel && slotUserId === String(targetUserId);
    } else {
      // targetUserId가 없으면 전체 (기존 동작 유지)
      return slotDate === dateStr && !slot.isTravel;
    }
  })
  .sort(...);


🔧 코드 수정 4: smartExchange에서 호출 시 userId 전달
─────────────────────────────────────────────────────────────────────────────
📂 파일: server/controllers/coordinationExchangeController.js (1337-1351줄)

[변경 전]
// Case 1: 빈자리 이동
await recalculateTravelTimeSlotsForDate(room, new Date(allSlotsInBlock[0].date), room.owner._id, effectiveTravelMode);
await recalculateTravelTimeSlotsForDate(room, targetDate, room.owner._id, effectiveTravelMode);

[변경 후]
// Case 1: 빈자리 이동 - ✅ B만 재계산
await recalculateTravelTimeSlotsForDate(room, new Date(allSlotsInBlock[0].date), room.owner._id, effectiveTravelMode, req.user.id);
await recalculateTravelTimeSlotsForDate(room, targetDate, room.owner._id, effectiveTravelMode, req.user.id);


📂 파일: server/controllers/coordinationExchangeController.js (1487-1500줄)

[변경 전]
// Case 2: 자동 배치
await recalculateTravelTimeSlotsForDate(room, new Date(oldSlotDate), room.owner._id, effectiveTravelMode);
await recalculateTravelTimeSlotsForDate(room, targetDate, room.owner._id, effectiveTravelMode);

[변경 후]
// Case 2: 자동 배치 - ✅ 이동한 사용자만 재계산
await recalculateTravelTimeSlotsForDate(room, new Date(oldSlotDate), room.owner._id, effectiveTravelMode, req.user.id);
await recalculateTravelTimeSlotsForDate(room, targetDate, room.owner._id, effectiveTravelMode, req.user.id);


🔧 코드 수정 5: 메타데이터 초기화 (추가 문제 해결)
─────────────────────────────────────────────────────────────────────────────
📂 파일: server/controllers/coordinationExchangeController.js (1281-1311줄)

[변경 전]
const slotData = {
  startTime: currentTime,
  endTime: slotEndTime,
  // ❌ 이전 위치의 메타데이터 복사
  originalStartTime: allSlotsInBlock[0]?.originalStartTime,
  originalEndTime: allSlotsInBlock[0]?.originalEndTime,
  adjustedForTravelTime: allSlotsInBlock[0]?.adjustedForTravelTime,
};

[변경 후]
const slotData = {
  startTime: currentTime,
  endTime: slotEndTime,
  // ✅ 메타데이터 초기화 (재계산 후 설정됨)
  originalStartTime: undefined,
  originalEndTime: undefined,
  adjustedForTravelTime: false,
};


해결방안 2: 영향받는 사용자만 재계산 (고급)
─────────────────────────────────────────────────────────────────────────────

📝 개념:
   B가 이동하면:
   - B의 이동시간 재계산 (당연)
   - B 다음 시간대 슬롯의 사용자 이동시간도 재계산 (영향받음)
   - A는 B 이전 시간대이므로 영향 안 받음 → 재계산 안 함

⚠️ 복잡도:
   - 구현이 복잡함
   - 먼저 방법 1로 시도 후, 필요하면 적용


해결방안 3: 확정 시에만 재계산 (대안)
─────────────────────────────────────────────────────────────────────────────

📝 개념:
   - smartExchange에서는 재계산 안 함
   - confirmSchedule에서 전체 재계산

⚠️ 단점:
   - 확정 전에는 이동시간이 표시되지 않음
   - 사용자 경험 저하

═══════════════════════════════════════════════════════════════════════════════
📋 수정 체크리스트
═══════════════════════════════════════════════════════════════════════════════

[ ] 1. recalculateTravelTimeSlotsForDate 함수 시그니처에 targetUserId 파라미터 추가
[ ] 2. 이동시간 삭제 로직에 targetUserId 조건 추가
[ ] 3. 수업 슬롯 필터링 로직에 targetUserId 조건 추가
[ ] 4. smartExchange Case 1에서 req.user.id 전달
[ ] 5. smartExchange Case 2에서 req.user.id 전달
[ ] 6. smartExchange Case 1/2에서 메타데이터 초기화
[ ] 7. travelTimeSlots 삭제 로직도 targetUserId 조건 추가 (추가 확인 필요)
[ ] 8. 테스트: A, B 두 명이 월요일에 있을 때 B만 이동
[ ] 9. 테스트: A의 이동시간이 변경되지 않는지 확인
[ ] 10. 테스트: 확정 후 A의 시간이 정상인지 확인

═══════════════════════════════════════════════════════════════════════════════
🧪 테스트 시나리오
═══════════════════════════════════════════════════════════════════════════════

시나리오 1: 기본 빈자리 이동
─────────────────────────────────────────────────────────────────────────────
[초기 상태]
  - 월요일: A(9-10시 이동, 10-12시 수업), B(13:00-13:10 이동, 13:10-15:10 수업)

[작업]
  - B를 챗봇으로 화요일 14:10으로 이동

[기대 결과]
  ✅ 월요일 A: 9-10시 이동, 10-12시 수업 (변경 없음!)
  ✅ 월요일 B: 삭제됨
  ✅ 화요일 B: 새로 생성됨, 이동시간 계산됨

[확정 후 기대 결과]
  ✅ 월요일 A: 9-10시 이동, 10-12시 수업 (여전히 변경 없음!)
  ✅ 화요일 B: 정상적으로 병합됨


시나리오 2: 같은 날짜에 3명 있을 때
─────────────────────────────────────────────────────────────────────────────
[초기 상태]
  - 월요일: A(9-12시), B(13-15시), C(15-17시)

[작업]
  - B를 화요일로 이동

[기대 결과]
  ✅ 월요일 A: 변경 없음
  ✅ 월요일 C: 이동시간 재계산될 수 있음 (B 다음이므로 영향받음)
  ✅ 화요일 B: 새로 생성됨


시나리오 3: 연속 이동
─────────────────────────────────────────────────────────────────────────────
[초기 상태]
  - 월요일: A(9-12시), B(13-15시)

[작업 1]
  - B를 화요일로 이동

[작업 2]
  - A를 수요일로 이동

[기대 결과]
  ✅ 월요일: 비어있음
  ✅ 화요일: B만 (A 영향 없음)
  ✅ 수요일: A만

═══════════════════════════════════════════════════════════════════════════════
⚠️ 주의사항
═══════════════════════════════════════════════════════════════════════════════

1. travelTimeSlots 배열 처리
   - recalculateTravelTimeSlotsForDate 함수에서 travelTimeSlots도 삭제/추가함
   - 이 부분도 targetUserId 조건 추가 필요 (85-92줄)

2. 기존 호출 호환성
   - targetUserId가 없으면 기존 동작 유지 (전체 재계산)
   - confirmSchedule 등 다른 곳에서 호출 시 영향 없음

3. 성능
   - 특정 사용자만 재계산하므로 성능 향상
   - 조원이 많을수록 효과 큼

4. 버그 추적
   - 수정 후에도 A의 이동시간이 바뀌면 다른 원인 조사 필요
   - 로그로 어느 시점에서 바뀌는지 추적

═══════════════════════════════════════════════════════════════════════════════
📝 관련 이슈 및 기록
═══════════════════════════════════════════════════════════════════════════════

[2025-12-24] 문제 발견
  - 사용자 보고: B 이동 시 A의 이동시간도 바뀜
  - 증상: 9-10시 → 9:10-10시, 확정 후 9:10-12시

[2025-12-24] 근본 원인 파악
  - recalculateTravelTimeSlotsForDate가 날짜 기준으로 전체 재계산
  - userId 필터링 없음

[2025-12-24] 해결방안 수립
  - targetUserId 파라미터 추가
  - 특정 사용자만 재계산하도록 수정

═══════════════════════════════════════════════════════════════════════════════
✅ 다음 단계
═══════════════════════════════════════════════════════════════════════════════

1. ✅ 문서 작성 완료
2. ⏳ 코드 수정 진행 중
3. ⏳ 테스트 예정
4. ⏳ 배포 예정

═══════════════════════════════════════════════════════════════════════════════
