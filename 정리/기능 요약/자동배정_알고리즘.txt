================================================================================
                        자동배정 알고리즘 상세 분석
================================================================================
작성일: 2025-12-04
목적: 일정맞추기 자동배정 알고리즘의 완전한 이해 및 문제 진단

================================================================================


================================================================================
                            1. 전체 흐름 개요
================================================================================

📂 메인 파일: server/services/schedulingAlgorithm/index.js
📂 배정 로직: server/services/schedulingAlgorithm/services/slotAssignmentService.js

┌─────────────────────────────────────────────────────────────────────┐
│                        자동배정 전체 프로세스                           │
└─────────────────────────────────────────────────────────────────────┘

1. 입력 검증
2. 멤버별 필요 슬롯 계산
3. 타임테이블 생성 (방장 + 멤버 선호시간 교집합)
4. 배정 초기화
5. 기존 슬롯 로드
6. 지연 배정 처리 (캐리오버)
7. ⭐ 메인 배정 (assignByTimeOrder)
8. 캐리오버 재처리
9. 미배정 멤버 정보 생성
10. 결과 반환


================================================================================
                        2. 타임테이블 생성 (Step 3)
================================================================================

📂 파일: services/timetableCreationService.js

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Step 2.1: 방장의 가능한 시간대 수집
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

- 방장의 defaultSchedule 읽기
- specificDate가 있으면 해당 날짜에만 적용
- dayOfWeek가 있으면 해당 요일에 적용
- 시작~종료 시간을 30분 단위 슬롯으로 분할
- ownerAvailableSlots Set에 추가

예시:
  방장: 수 9-12, 13-17
  → 수 9:00, 9:30, 10:00, 10:30, 11:00, 11:30, 13:00, 13:30, 14:00, 14:30, 15:00, 15:30, 16:00, 16:30


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Step 2.2: 방장의 개인시간 제거
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

- owner.personalTimes에서 방장의 개인 일정 확인
- 해당 시간대를 ownerAvailableSlots에서 제거


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Step 2.3: 금지 시간 제거 (점심시간 등)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

- roomSettings.ownerBlockedTimes 확인
- 점심시간(12:00-13:00) 등 제거


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Step 2.4: 멤버의 선호시간 추가 (방장과 교집합만)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

각 멤버마다:
1. member.user.defaultSchedule 읽기
2. 주말 제외
3. specificDate 또는 dayOfWeek 처리
4. 시간대를 30분 단위 슬롯으로 분할
5. ⚠️ 방장의 가능한 시간대(ownerAvailableSlots)와 겹치는 것만 추가

timetable 구조:
  {
    "2025-01-08-09:00": {
      assignedTo: null,
      available: [
        { memberId: "userA", priority: 2, isOwner: false },
        { memberId: "userB", priority: 2, isOwner: false },
        { memberId: "userC", priority: 2, isOwner: false }
      ],
      date: Date객체,
      dayOfWeek: 3 (1=월, 2=화, ...)
    },
    "2025-01-08-09:30": { ... },
    ...
  }


예시:
  방장: 수 9-12, 13-17
  A: 수 9-12, 13-17
  B: 수 9-12, 13-17, 목 9-12
  C: 수 9-12, 목 9-12

  결과:
    수 9:00: [A, B, C]
    수 9:30: [A, B, C]
    수 10:00: [A, B, C]
    ...
    수 13:00: [A, B]
    수 13:30: [A, B]
    ...
    목 9:00: [B, C]  (방장이 목요일도 가능한 경우만)


================================================================================
                    3. 멤버별 필요 슬롯 계산 (Step 2)
================================================================================

📂 파일: helpers/assignmentHelper.js → calculateMemberRequiredSlots()

계산 공식:
  필요 슬롯 = (minHoursPerWeek * numWeeks * 2)

예시:
  - 2시간/주, 1주 → 2 * 1 * 2 = 4슬롯 (30분 단위)
  - 3시간/주, 1주 → 3 * 1 * 2 = 6슬롯


================================================================================
                    4. ⭐ 메인 배정 로직 (assignByTimeOrder)
================================================================================

📂 파일: services/slotAssignmentService.js → assignByTimeOrder()

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Step 4.1: 멤버별 가용 슬롯 계산
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

각 멤버마다:
  - timetable의 모든 슬롯 확인
  - 해당 멤버가 available에 있으면 카운트
  - 결과: memberAvailableSlots = { userA: 14, userB: 20, userC: 12 }


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Step 4.2: 멤버 정렬 (배정 순서 결정)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

sortMembersByMode() 함수:

  1순위: 우선순위 (priority) 높은 순
  2순위: 배정 모드에 따라
    - normal: 가용 슬롯 적은 순
    - first_come_first_served: joinedAt 빠른 순
    - from_today: 가용 슬롯 적은 순

보통 모드 예시:
  memberMaxPriority = { userA: 2, userB: 2, userC: 2 }  // 모두 같음
  memberAvailableSlots = { userA: 14, userB: 20, userC: 12 }

  정렬 결과: [userC(12), userA(14), userB(20)]
  → C가 먼저, A가 두 번째, B가 마지막


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Step 4.3: 각 멤버에게 블록 배정 (현재 로직)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

정렬된 멤버 순서대로 (C → A → B):

  for (const memberId of membersByAvailability) {

    // 1) 모든 가능한 블록 찾기
    allPossibleBlocks = []
    for (각 슬롯) {
      if (해당 멤버가 사용 가능) {
        block = findConsecutiveBlock(i, memberId, remainingSlots)
        allPossibleBlocks.push({ block, startIndex: i })
      }
    }

    // 2) 블록 정렬 ⚠️ 핵심 부분!
    allPossibleBlocks.sort((a, b) => {
      // 1순위: 시간 순서 (이른 시간 우선)
      if (a.startIndex !== b.startIndex)
        return a.startIndex - b.startIndex

      // 2순위: 긴 블록 우선 (분할 최소화)
      return b.block.length - a.block.length
    })

    // 3) 최적 블록 배정
    bestBlock = allPossibleBlocks[0]  // 가장 이른 시간
    배정(bestBlock)
  }


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Step 4.4: findConsecutiveBlock() 동작 원리
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

findConsecutiveBlock(startIndex, memberId, maxSlots):

  blockKeys = []
  for (i = startIndex; i < sortedKeys.length; i++) {
    if (slot이 이미 배정됨) break
    if (멤버가 사용 불가) break
    if (연속되지 않음) break  // ⚠️ 여기서 끊김!

    blockKeys.push(key)
    if (blockKeys.length >= maxSlots) break
  }

  return blockKeys

⚠️ 주의: 점심시간 같은 빈 시간을 건너뛰지 못함!
  - 수 11:30 → 12:00(점심) → 13:00
  - 11:30 다음이 13:00이면 "연속되지 않음"으로 간주하고 break
  - 따라서 11:30까지만 반환 (1시간 블록)


================================================================================
                        5. 현재 문제점 분석
================================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
문제 상황 재현
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

입력:
  - A: 수 9-12, 13-17 (14슬롯)
  - B: 수 9-12, 13-17, 목 9-12 (20슬롯)
  - C: 수 9-12, 목 9-12 (12슬롯)
  - 각자 2시간(4슬롯) 배정

멤버 순서: C(12) → A(14) → B(20)

1️⃣ C 배정:
   - 가장 이른 블록 찾기
   - 수 9:00부터 연속 블록 찾기
   - findConsecutiveBlock → 수 9:00-11:00 (4슬롯) 찾음
   - ✅ C: 수 9-11 배정

   타임테이블 상태:
     수 9:00-11:00: C
     수 11:00-12:00: 비어있음 (A, B 가능)
     수 13:00-17:00: 비어있음 (A, B 가능)

2️⃣ A 배정:
   - 가장 이른 블록 찾기
   - 수 11:00부터 연속 블록 찾기
   - findConsecutiveBlock(수 11:00, A, 4슬롯)
     → 수 11:00, 11:30 (2슬롯)
     → 12:00은 점심시간이라 빔
     → 연속되지 않으므로 break!
     → **2슬롯만 반환** ⚠️

   - allPossibleBlocks에 추가:
     [
       { block: [수 11:00, 11:30], startIndex: 낮음 },
       { block: [수 13:00, 13:30, 14:00, 14:30], startIndex: 중간 },
       { block: [수 15:00, 15:30, 16:00, 16:30], startIndex: 높음 }
     ]

   - 정렬 (시간 순서 우선):
     1. 수 11:00 블록 (2슬롯)  ← 가장 이름
     2. 수 13:00 블록 (4슬롯 이상)
     3. 수 15:00 블록 (4슬롯 이상)

   - bestBlock = 수 11:00 블록 (2슬롯)
   - 2슬롯 배정 → **2슬롯 부족!**

   - 다시 블록 찾기 (remainingSlots = 2)
   - 가장 이른 블록 = 수 15:00 블록?

   - ❌ A: 수 11-12 + 15-16 (분할됨!)

3️⃣ B 배정:
   - 남은 블록: 수 13:00-15:00
   - ✅ B: 수 13-15


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
근본 원인
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. **시간 순서 우선 정렬**
   - 가장 이른 시간을 무조건 선택
   - 짧은 블록이라도 시간이 이르면 선택됨

2. **findConsecutiveBlock의 한계**
   - 점심시간 같은 빈 시간을 건너뛰지 못함
   - 연속되지 않으면 즉시 종료
   - 짧은 블록을 반환

3. **블록 길이 고려 부족**
   - 2순위로만 고려
   - 시간이 이르면 무조건 우선


================================================================================
                            6. 해결 방안
================================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
방안 1: 블록 길이를 1순위로 (추천)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

allPossibleBlocks.sort((a, b) => {
  // 1순위: 필요한 만큼 채울 수 있는 블록 우선
  const aIsFull = a.block.length >= remainingSlots
  const bIsFull = b.block.length >= remainingSlots
  if (aIsFull !== bIsFull) return bIsFull ? 1 : -1

  // 2순위: 긴 블록 우선
  const lengthDiff = b.block.length - a.block.length
  if (lengthDiff !== 0) return lengthDiff

  // 3순위: 시간 순서
  return a.startIndex - b.startIndex
})

효과:
  - 필요한 만큼 채울 수 있는 블록을 최우선
  - 분할 최소화
  - 시간 순서는 마지막 고려


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
방안 2: 짧은 블록 필터링
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// 필요한 양의 절반 이하인 블록은 제외
if (block.length >= remainingSlots * 0.5) {
  allPossibleBlocks.push({ block, startIndex: i })
}

효과:
  - 너무 짧은 블록은 후보에서 제외
  - 분할 가능성 감소


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
방안 3: 한 번에 전체 배정 (현재 문제의 근본 해결)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

현재는 부족하면 다시 배정을 시도하는데,
대신 **처음부터 필요한 만큼을 채울 수 있는 블록만 선택**

if (bestBlock.block.length >= remainingSlots) {
  // 한 번에 전체 배정
  배정(bestBlock)
} else {
  // 다음 블록으로 넘어가기
  continue
}


================================================================================
                            7. 기대 결과
================================================================================

방안 1 적용 시 예상 배정:

1️⃣ C 배정:
   - 필요: 4슬롯
   - 블록 후보:
     * 수 9:00 (4슬롯 이상) ← 필요량 충족, 가장 긴 블록
     * 목 9:00 (4슬롯 이상)
   - 선택: 수 9:00 (시간 순서상 더 이름)
   - ✅ C: 수 9-11

2️⃣ A 배정:
   - 필요: 4슬롯
   - 블록 후보:
     * 수 11:00 (2슬롯) ← 필요량 미달
     * 수 13:00 (4슬롯 이상) ← 필요량 충족 ✅
   - 선택: 수 13:00 (필요량 충족하는 것 중 가장 이름)
   - ✅ A: 수 13-15 (연속!)

3️⃣ B 배정:
   - 필요: 4슬롯
   - 블록 후보:
     * 수 11:00 (2슬롯)
     * 수 15:00 (4슬롯 이상) ← 필요량 충족
     * 목 9:00 (4슬롯 이상) ← 필요량 충족
   - 선택: 수 15:00 또는 목 9:00
   - ✅ B: 수 15-17 또는 목 9-11


================================================================================
                            8. 구현 상태
================================================================================

✅ 방안 1 구현 완료 (2025-12-04)

파일: server/services/schedulingAlgorithm/services/slotAssignmentService.js
위치: 193-206번 줄

변경 내용:
  기존: 1) 시간 순서 → 2) 긴 블록
  개선: 1) 필요량 충족 블록 → 2) 긴 블록 → 3) 시간 순서

효과:
  - 필요한 만큼 한 번에 채울 수 있는 블록 우선 선택
  - 짧은 블록으로 인한 분할 배정 방지
  - 연속된 시간 배정 보장

테스트 필요:
  - 2시간 배정: A(수 13-15), B(수 15-17), C(수 9-11) 예상
  - 1시간 배정: A(수 13-14), B(수 14-15), C(목 9-10) 예상
  - 3시간 배정: 각자 연속 3시간 배정 예상


================================================================================
