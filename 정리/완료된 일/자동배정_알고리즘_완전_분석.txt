================================================================================
                    자동배정 알고리즘 완전 분석 문서
================================================================================

작성일: 2025-12-09
분석 대상: C:\Users\예상\OneDrive\Desktop\프로젝트\Ai_Schedule\server\services\schedulingAlgorithm
분석 범위: 전체 알고리즘 구조 (24개 파일)

================================================================================
목차
================================================================================
1. 알고리즘 개요
2. 전체 흐름도
3. 데이터 구조 (Input/Output)
4. 단계별 상세 설명
5. 배정 전략 (일반 모드 vs 대중교통 모드)
6. 우선순위 계산 방식
7. 충돌 해결 방식
8. 실제 예시 시나리오 (3가지)
9. LLM(AI) 사용 여부 분석
10. 주요 함수 목록 및 역할

================================================================================
1. 알고리즘 개요
================================================================================

[목적]
방(Room)에 속한 여러 학생(멤버)들에게 주당 최소 시간(기본 3시간)을 자동으로 배정하는
스케줄링 알고리즘입니다.

[핵심 원리]
- 방장(owner)의 가능 시간대를 기준으로 타임테이블 생성
- 각 학생의 개인 시간표(선호시간/개인시간)를 고려
- 시간 순서 또는 거리 순서로 배정
- 충돌 시 우선순위, 가용 슬롯 수 등을 고려하여 배정

[주요 특징]
✓ LLM/AI 사용 없음 - 순수 규칙 기반 알고리즘
✓ 30분 단위 슬롯 관리
✓ 다중 주(2주 이상) 배정 지원
✓ 이월(carry over) 관리
✓ 2가지 배정 모드 (일반 모드 / 대중교통 모드)


================================================================================
2. 전체 흐름도
================================================================================

┌─────────────────────────────────────────────────────────────────┐
│                     입력 데이터 검증                              │
│  - members: 멤버 배열                                             │
│  - owner: 방장 객체                                               │
│  - roomTimeSlots: 기존 슬롯                                       │
│  - options: 옵션 (minHoursPerWeek, numWeeks, transportMode 등)    │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                     다중 주 vs 단일 주                           │
│  - numWeeks > 1 → multiWeekSchedulingService 호출                │
│  - numWeeks = 1 → 단일 주 배정 진행                              │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                  Step 1: 타임테이블 생성                         │
│  ① 방장의 defaultSchedule + scheduleExceptions 수집              │
│  ② 방장의 personalTimes 제거                                     │
│  ③ 방 설정의 금지시간(ownerBlockedTimes) 제거                    │
│  ④ 각 멤버의 defaultSchedule/scheduleExceptions 추가             │
│  ⑤ 각 멤버의 personalTimes 제거                                  │
│  → timetable 객체 완성                                           │
│     key: "2025-09-16-09:00"                                      │
│     value: {                                                     │
│       assignedTo: null,                                          │
│       available: [{memberId, priority, isOwner}],                │
│       date: Date,                                                │
│       dayOfWeek: 1-7                                             │
│     }                                                            │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                Step 2: 배정 초기화 및 기존 슬롯 로드             │
│  - assignments 객체 초기화 (멤버별)                              │
│  - 기존 roomTimeSlots 로드하여 assignments에 반영               │
│  - memberRequiredSlots 계산 (주당 시간 * 6 + 이월시간 * 6)       │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                 Phase 0: 지연 배정 처리                          │
│  - deferredAssignments (이전 주에서 넘어온 배정) 처리            │
│  - 경쟁 적은 슬롯 우선 배정                                       │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                 Phase 1: 충돌 식별                               │
│  - 2명 이상이 같은 슬롯을 원하고 우선순위가 같으면 충돌           │
│  - 멤버별 가용 슬롯 수 계산                                       │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│            배정 전략 선택 (transportMode 확인)                   │
├─────────────────────────────────────────────────────────────────┤
│  [일반 모드]                    │  [대중교통 모드]                │
│  transportMode = 'normal'       │  transportMode = 'public'      │
│                                 │  'driving', 'walking'          │
├─────────────────────────────────┼────────────────────────────────┤
│  assignByTimeOrder()            │  assignByPublicTransport()     │
│  - 시간 순서 우선 배정          │  - 거리 순서 우선 배정          │
│  - 연속 블록 우선 배정          │  - 이동시간 고려                │
│  - 선택지 적은 멤버 우선        │  - Google Maps API 사용         │
└─────────────────────────────────┴────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│            Phase 6: 캐리오버 처리 (이월 시간 배정)               │
│  - carryOver가 있는 멤버에게 우선권 부여                          │
│  - 빈 슬롯 찾아서 1시간 블록 단위로 배정                          │
│  - 2주 연속 미배정 시 needsIntervention 플래그 설정              │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                   최종 결과 반환                                 │
│  {                                                               │
│    assignments: {멤버별 배정 결과},                               │
│    carryOverAssignments: [이월 정보],                            │
│    unassignedMembersInfo: [미배정 멤버 정보]                     │
│  }                                                               │
└─────────────────────────────────────────────────────────────────┘


================================================================================
3. 데이터 구조 (Input/Output)
================================================================================

[INPUT]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1) members: 멤버 배열
   [{
     user: {
       _id: ObjectId,
       displayName: String,
       defaultSchedule: [{              // 반복 스케줄
         dayOfWeek: 1-7,                // 1=월요일, 7=일요일
         startTime: "09:00",
         endTime: "18:00",
         priority: 1-5,                 // 우선순위
         specificDate: "2025-09-16"     // (선택) 특정 날짜만
       }],
       scheduleExceptions: [{           // 챗봇으로 추가된 선호시간
         specificDate: "2025-09-16",
         startTime: ISO DateTime,
         endTime: ISO DateTime,
         priority: 1-5
       }],
       personalTimes: [{                // 개인시간 (수업 불가능)
         startTime: "12:00",
         endTime: "13:00",
         days: [1, 2, 3],               // 반복 요일
         isRecurring: true,
         specificDate: null             // (선택) 특정 날짜만
       }],
       addressLat: Number,              // 위도 (대중교통 모드용)
       addressLng: Number,              // 경도
       address: String
     },
     carryOver: 2,                      // 이월 시간 (시간 단위)
     carryOverHistory: [{
       timestamp: Date,
       hours: Number
     }],
     joinedAt: Date                     // 가입일 (선착순 모드용)
   }]

2) owner: 방장 객체
   {
     _id: ObjectId,
     user: {
       defaultSchedule: [...],           // 방장 가능 시간
       scheduleExceptions: [...],        // 챗봇으로 추가된 시간
       personalTimes: [...],             // 방장 개인시간
       addressLat: Number,
       addressLng: Number,
       address: String
     }
   }

3) roomTimeSlots: 기존 슬롯 배열 (선택)
   [{
     date: Date,
     startTime: "09:00",
     endTime: "09:30",
     subject: String,
     user: ObjectId,
     status: "confirmed" | "pending" | "cancelled"
   }]

4) options: 옵션 객체
   {
     minHoursPerWeek: 3,                // 주당 최소 시간 (기본 3시간)
     numWeeks: 2,                       // 배정할 주 수 (기본 2주)
     currentWeek: Date,                 // 시작 날짜 (기본: 현재 날짜)
     assignmentMode: 'normal'           // 'normal' | 'first_come_first_served' | 'from_today'
       | 'first_come_first_served'
       | 'from_today',
     transportMode: 'normal'            // 'normal' | 'public' | 'driving' | 'walking'
       | 'public'
       | 'driving'
       | 'walking',
     minClassDurationMinutes: 60,      // 최소 수업 시간 (분)
     clientToday: "2025-09-16",         // from_today 모드에서 사용
     ownerPreferences: {                // 방장 선호 설정
       focusTimeType: 'morning'         // 'morning' | 'lunch' | 'afternoon' | 'evening' | 'none'
         | 'lunch'
         | 'afternoon'
         | 'evening'
         | 'none'
     },
     roomSettings: {
       scheduleStartTime: "09:00",      // 스케줄 시작 시간
       scheduleEndTime: "18:00",        // 스케줄 종료 시간
       ownerBlockedTimes: [{            // 금지 시간 (점심시간 등)
         name: "점심시간",
         startTime: "12:00",
         endTime: "13:00"
       }]
     },
     fullRangeStart: Date,              // 전체 범위 시작 (다중 주용)
     fullRangeEnd: Date                 // 전체 범위 끝
   }

5) deferredAssignments: 지연 배정 배열 (선택)
   [{
     memberId: String,
     neededHours: Number
   }]


[OUTPUT]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

{
  assignments: {
    "멤버ID1": {
      memberId: "멤버ID1",
      assignedHours: 12,               // 배정된 슬롯 수 (30분 단위)
      requiredSlots: 18,               // 필요 슬롯 수
      slots: [{
        date: Date,
        day: "monday",
        startTime: "09:00",
        endTime: "09:30",
        subject: "자동 배정",
        user: "멤버ID1",
        status: "confirmed"
      }],
      needsIntervention: false,        // (선택) 개입 필요 여부
      interventionReason: null         // (선택) 개입 이유
    },
    "멤버ID2": { ... }
  },

  carryOverAssignments: [{            // 이월 배정 정보
    memberId: "멤버ID1",
    neededHours: 1.5,                 // 부족 시간 (시간 단위)
    priority: 3,
    week: Date,
    consecutiveCarryOvers: 1          // 연속 이월 횟수
  }],

  unassignedMembersInfo: [{           // 미배정 멤버 정보
    memberId: "멤버ID1",
    neededHours: 1.5,
    assignedSlots: [...],
    needsIntervention: false,
    interventionReason: null
  }]
}


[내부 데이터 구조]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1) timetable: 타임테이블 객체
   {
     "2025-09-16-09:00": {
       assignedTo: null | "멤버ID",   // 배정된 멤버 ID
       available: [{                  // 사용 가능한 멤버 목록
         memberId: "멤버ID1",
         priority: 3,
         isOwner: false
       }],
       date: Date,                    // 날짜 객체
       dayOfWeek: 1                   // 1=월요일, 7=일요일
     }
   }

2) memberRequiredSlots: 멤버별 필요 슬롯 수
   {
     "멤버ID1": 18,                    // 주당 3시간 * 6슬롯 = 18슬롯
     "멤버ID2": 24                     // 주당 3시간 * 6슬롯 + 이월 1시간 * 6슬롯 = 24슬롯
   }

3) conflicts: 충돌 배열
   [{
     slotKey: "2025-09-16-09:00",
     availableMembers: ["멤버ID1", "멤버ID2"],
     priority: 3
   }]


================================================================================
4. 단계별 상세 설명
================================================================================

[Phase 0: 입력 검증 및 초기화]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: index.js (56-148줄)

1. 입력 검증
   - members 배열 확인
   - owner 객체 및 _id 확인
   - 빈 배열일 경우 빠른 종료

2. 다중 주 분기
   - numWeeks > 1이면 multiWeekSchedulingService로 이동
   - 단일 주는 메인 로직 진행

3. 초기화
   - nonOwnerMembers: 방장 제외 멤버 필터링
   - memberRequiredSlots: 멤버별 필요 슬롯 계산
     공식: (minHoursPerWeek * numWeeks + carryOver) * SLOTS_PER_HOUR
           = (3 * 1 + 0) * 6 = 18슬롯 (기본)
   - assignments: 멤버별 배정 객체 초기화

4. 기존 슬롯 로드
   - roomTimeSlots가 있으면 assignments에 로드


[Phase 1: 타임테이블 생성]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: services/timetableCreationService.js
함수: createTimetableFromPersonalSchedules()

Step 1: 방장 가용 슬롯 수집 (helpers/timetableHelper.js)
  ① defaultSchedule 처리
     - 주간 반복 일정: dayOfWeek별로 모든 날짜에 추가
     - 특정 날짜 일정: specificDate만 추가
     - 30분 단위로 슬롯 생성 (09:00, 09:30, 10:00, ...)

  ② scheduleExceptions 처리 (챗봇으로 추가된 시간)
     - specificDate만 처리
     - ISO DateTime에서 HH:MM 추출

  ③ personalTimes 제거 (방장의 개인시간)
     - 반복 일정: days 배열의 요일에 모두 제거
     - 특정 날짜: specificDate만 제거

  ④ ownerBlockedTimes 제거 (방 설정의 금지시간)
     - 매일 반복 (점심시간 등)

  → ownerAvailableSlots Set 생성

Step 2: 멤버 가용 슬롯 추가
  각 멤버마다:
  ① defaultSchedule 처리
     - 방장 가용 시간대와 겹치는 것만 추가
     - 주말 제외
     - timetable[key].available에 추가

  ② scheduleExceptions 처리 (챗봇으로 추가된 시간)

  ③ personalTimes 제거 (멤버의 개인시간)
     - timetable[key].available에서 해당 멤버 제거

Step 3: from_today 모드 처리 (선택)
  - assignmentMode === 'from_today'이면
  - clientToday 날짜 이후만 필터링

→ 최종 timetable 객체 완성


[Phase 2: 충돌 식별]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: services/conflictIdentificationService.js
함수: identifyConflictsBeforeAssignment()

1. 각 슬롯마다:
   - available 배열에서 방장 제외
   - 2명 이상 && 같은 우선순위 → 충돌

2. 멤버별 가용 슬롯 수 계산
   - memberAvailableSlots[memberId] = 사용 가능한 슬롯 수

3. 충돌 정보 반환
   {
     conflicts: [{slotKey, availableMembers, priority}],
     memberAvailableSlots: {멤버ID: 슬롯수}
   }


[Phase 3: 배정 실행 - 일반 모드]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: services/slotAssignmentService.js
함수: assignByTimeOrder()

** 최신 배정 전략 (시간 순서 우선) **

1단계: 선택지 적은 멤버 우선 배정

  ① 멤버 정렬 기준
     a) 우선순위 높은 순 (priority)
     b) 배정 모드별 정렬
        - first_come_first_served: joinedAt 빠른 순
        - normal/from_today: 가용 슬롯 적은 순

  ② 각 멤버에 대해:
     - 모든 가능한 연속 블록 찾기
     - 블록 정렬 우선순위:
       1순위: 필요량 충족 블록 (분할 최소화)
       2순위: 긴 블록
       3순위: 시간 순서 (이른 시간부터)
     - 최적 블록 배정

  ③ 배정 시:
     - 연속된 슬롯 우선 (areConsecutiveSlots 확인)
     - assignSlot() 함수로 타임테이블 업데이트
     - assignments 객체 업데이트

2단계: 남은 슬롯 추가 배정

  ① 아직 부족한 멤버 찾기
     - 우선순위 높은 순
     - 배정된 시간 적은 순

  ② 각 멤버에 대해:
     - 가능한 모든 블록 찾기
     - 긴 블록부터 배정
     - 필요량 충족할 때까지 반복


[Phase 4: 배정 실행 - 대중교통 모드]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: services/publicTransportAssignmentService.js
함수: assignByPublicTransport()

** Google Maps API 기반 거리 순서 배정 **

1. 요일별로 처리

2. 각 요일마다:
   ① 시작 위치: 방장 위치

   ② 가장 가까운 학생 찾기 (helpers/assignmentHelper.js)
      - calculateTravelTime(): Google Maps Distance Matrix API 호출
        * 입력: 출발지 좌표, 목적지 좌표, 이동수단(public/driving/walking)
        * 출력: 이동 시간 (분)

      - sortMembersByDistance(): 후보 멤버들을 거리순 정렬

      - findNearestMemberWithSufficientTime(): 조건 충족하는 멤버 찾기
        * 조건1: 이동시간 + 수업시간 ≤ 선호시간 종료
        * 조건2: 예외시간(personalTimes) 회피
        * 예외시간 충돌 시 → 예외시간 이후로 자동 이동

   ③ 배정
      - 30분 단위로 슬롯 배정
      - 현재 위치를 배정된 학생 위치로 업데이트
      - currentEndTime 업데이트

   ④ 필요량 충족 시 목록에서 제거

   ⑤ 반복 (더 이상 조건 충족하는 학생이 없을 때까지)

3. 다음 요일로 이동


[Phase 5: 캐리오버 처리]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: index.js (_carryOverAssignments 메서드)

1. carryOver가 있는 멤버 찾기

2. 각 멤버마다:
   ① 빈 슬롯 찾기 (아직 배정되지 않은 슬롯)
   ② 1시간 블록 단위로 배정
      - 연속된 2개 슬롯 확인 (areConsecutiveSlots)
      - 필요량 충족할 때까지 배정

   ③ 2주 연속 미배정 확인
      - carryOverHistory에서 최근 2주 내 이월 횟수 확인
      - 2회 이상이면 needsIntervention = true


[Phase 6: 결과 생성]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: helpers/memberHelper.js

1. unassignedMembersInfo 생성
   - 필요량 미충족 멤버 목록
   - 부족 시간 계산

2. carryOverAssignments 생성
   - 다음 주로 이월할 정보
   - 연속 이월 횟수 포함

3. 최종 결과 반환


[다중 주 배정]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: services/multiWeekSchedulingService.js
함수: runMultiWeekSchedule()

1. 각 주마다 반복 (0 ~ numWeeks-1)

2. 주별 옵션 생성
   - numWeeks = 1로 설정
   - currentWeek, fullRangeStart, fullRangeEnd 설정

3. 단일 주 배정 실행
   - runSingleWeekSchedule() 호출

4. 결과 병합
   - assignments 병합
   - slots 누적

5. 최종 결과 반환


================================================================================
5. 배정 전략 (일반 모드 vs 대중교통 모드)
================================================================================

[일반 모드 (Normal Mode)]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
transportMode = 'normal'

전략: 시간 순서 우선 배정
핵심: 선택지 적은 멤버부터, 이른 시간부터, 연속 블록 우선

배정 순서:
  1. 멤버 정렬
     - 우선순위 높은 순
     - 가용 슬롯 적은 순 (선택지 적은 멤버 우선)

  2. 각 멤버마다
     - 가능한 모든 블록 찾기
     - 필요량 충족 블록 우선
     - 긴 블록 우선
     - 시간 순서 (이른 시간부터)

  3. 최적 블록 배정

장점:
  ✓ 시간 분할 최소화 (연속 블록 우선)
  ✓ 공평성 확보 (선택지 적은 멤버 우선)
  ✓ 예측 가능성 (이른 시간부터)

단점:
  ✗ 이동 거리 고려 안 함
  ✗ 실제 이동 시간 반영 안 함


[대중교통 모드 (Public Transport Mode)]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
transportMode = 'public' | 'driving' | 'walking'

전략: 거리 순서 우선 배정
핵심: 가장 가까운 학생부터, 이동시간 + 수업시간 고려

배정 순서:
  1. 요일별 처리

  2. 각 요일마다
     ① 시작 위치: 방장 위치
     ② Google Maps API로 모든 후보 학생까지 이동시간 계산
     ③ 거리 순으로 정렬
     ④ 가장 가까운 학생부터 확인
        - 조건: 이동시간 + 수업시간 ≤ 선호시간 종료
        - 예외시간 충돌 시 예외시간 이후로 자동 이동
     ⑤ 조건 충족하는 학생에게 배정
     ⑥ 현재 위치를 배정된 학생 위치로 업데이트
     ⑦ 반복

장점:
  ✓ 이동 시간 최소화
  ✓ 실제 이동 가능성 고려
  ✓ 예외시간(점심 등) 자동 회피

단점:
  ✗ Google Maps API 호출 필요 (비용)
  ✗ 네트워크 의존성
  ✗ 처리 시간 증가


[선착순 모드 (First Come First Served)]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
assignmentMode = 'first_come_first_served'

전략: 가입일 빠른 순서대로 배정
특징: 일반 모드와 동일하나 멤버 정렬 기준만 변경
  - joinedAt 빠른 순


[오늘 기준 모드 (From Today)]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
assignmentMode = 'from_today'

전략: 과거 날짜 제외하고 배정
특징: 타임테이블 생성 후 clientToday 이후 슬롯만 필터링
  - filterFutureDates() 호출


================================================================================
6. 우선순위 계산 방식
================================================================================

[우선순위 레벨]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: constants/priorityConstants.js

PRIORITY_LEVELS:
  1 = 최하 우선순위
  2 = 낮은 우선순위
  3 = 중간 우선순위 (기본값)
  4 = 높은 우선순위
  5 = 최고 우선순위


[우선순위 적용 지점]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. 타임테이블 생성 시
   - 각 슬롯의 available 배열에 저장
   - {memberId, priority, isOwner}
   - defaultSchedule의 priority 또는 멤버 기본 priority 사용

2. 충돌 식별 시
   - 같은 우선순위 멤버끼리만 충돌로 간주
   - 최고 우선순위 멤버가 1명이면 자동 배정

3. 배정 실행 시
   - 우선순위 높은 멤버부터 배정
   - sortMembersByPriority() 또는 sortMembersByMode() 사용


[우선순위 가져오기]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: helpers/memberHelper.js
함수: getMemberPriority()

우선순위 결정 순서:
  1. Room-level priority (멤버.priority)
  2. User-level priority (멤버.user.priority)
  3. DEFAULT_PRIORITY (3)


[점수 계산 (현재 미사용)]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: services/scoringService.js
함수: findBestSlotForMember()

* 현재 시간 순서 배정으로 대체되어 사용되지 않음 *

점수 계산 공식:
  baseScore = 1000

  - 경쟁자 수 패널티: -10 * contenders
  - 우선순위 보너스: +50 * (priority - 기준)
  - 연속성 보너스: +200 (이전 슬롯이 같은 멤버)
  - 근접성 보너스: 최대 +100 (평균 시간에 가까울수록)
  - 집중시간 보너스: +150 (focusTimeType에 맞으면)


================================================================================
7. 충돌 해결 방식
================================================================================

[충돌 정의]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: services/conflictIdentificationService.js

충돌 조건:
  1. 같은 슬롯을 2명 이상이 원함
  2. 최고 우선순위가 같음

예시:
  슬롯 "2025-09-16-09:00"
  available: [
    {memberId: "A", priority: 3},
    {memberId: "B", priority: 3},
    {memberId: "C", priority: 2}
  ]
  → A와 B가 충돌 (priority 3이 최고, 2명)
  → C는 충돌 아님 (priority 2로 낮음)


[충돌 해결 방식]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

** 현재 구현: 자동 회피 **

충돌 슬롯은 배정 단계에서 건너뛰기
  - conflictKeys Set 생성
  - 배정 시 충돌 슬롯인지 확인
  - 충돌 슬롯이면 배정 안 함

결과:
  - 충돌 멤버들은 다른 시간대에 배정됨
  - 선택지 적은 멤버가 우선 배정되므로 공평성 확보


** 과거 구현 (현재 비활성화): 협의 시스템 **

파일: Phase 2, 3이 주석 처리됨 (index.js 174-197줄)

Phase 2: 논쟁 없는 슬롯 배정
  - 단독으로 사용 가능한 슬롯 우선 배정
  - 충돌 슬롯이 아닌 시간대만 배정

Phase 3: 반복적 배정
  - 최고 우선순위가 유일한 슬롯 배정
  - 협의 멤버끼리 다른 요일에만 배정

Phase 4: 방장 슬롯 가져가기 (미사용)
  - 방장은 자동배정에 참여하지 않음

Phase 5: 방장 양보 충돌 해결 (비활성화)
  - 방장이 사용 가능한 시간대를 조원에게 양보


[충돌 병합]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: helpers/conflictMerger.js
함수: mergeConsecutiveConflicts()

연속된 충돌 슬롯을 블록으로 병합
  입력: conflicts 배열
  출력: 병합된 블록 배열

  조건:
    - 같은 날짜
    - 시간이 연속 (30분 차이)
    - 같은 멤버 조합

  예시:
    충돌 1: 09:00-09:30 [A, B]
    충돌 2: 09:30-10:00 [A, B]
    → 병합: 09:00-10:00 [A, B] (1시간 블록)


================================================================================
8. 실제 예시 시나리오 (3가지)
================================================================================

[시나리오 1: 일반 모드 - 3명 배정]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

입력:
  members: [학생A, 학생B, 학생C]
  owner: 방장
  options:
    minHoursPerWeek: 3 (각 학생당 주 3시간)
    numWeeks: 1
    transportMode: 'normal'

멤버 정보:
  방장:
    defaultSchedule: [
      {dayOfWeek: 1, startTime: "09:00", endTime: "18:00", priority: 3}
    ]
    personalTimes: [
      {startTime: "12:00", endTime: "13:00", days: [1,2,3,4,5]}  // 점심시간
    ]

  학생A:
    defaultSchedule: [
      {dayOfWeek: 1, startTime: "09:00", endTime: "15:00", priority: 3}
    ]
    carryOver: 0
    필요 슬롯: 18 (3시간 * 6슬롯)

  학생B:
    defaultSchedule: [
      {dayOfWeek: 1, startTime: "11:00", endTime: "18:00", priority: 3}
    ]
    carryOver: 0
    필요 슬롯: 18

  학생C:
    defaultSchedule: [
      {dayOfWeek: 1, startTime: "09:00", endTime: "18:00", priority: 4}  // 높은 우선순위
    ]
    personalTimes: [
      {startTime: "14:00", endTime: "15:00", days: [1]}  // 개인시간
    ]
    carryOver: 0
    필요 슬롯: 18


처리 과정:

Step 1: 타임테이블 생성
  월요일 09:00-18:00 (방장 가능 시간)
  - 점심시간 12:00-13:00 제거

  생성된 슬롯:
    09:00-09:30: [A(3), C(4)]
    09:30-10:00: [A(3), C(4)]
    10:00-10:30: [A(3), C(4)]
    10:30-11:00: [A(3), C(4)]
    11:00-11:30: [A(3), B(3), C(4)]
    11:30-12:00: [A(3), B(3), C(4)]
    13:00-13:30: [A(3), B(3), C(4)]
    13:30-14:00: [A(3), B(3), C(4)]
    14:00-14:30: [B(3)]            // C의 개인시간으로 C 제외
    14:30-15:00: [B(3)]            // A의 선호시간 종료, C의 개인시간
    15:00-15:30: [B(3), C(4)]
    15:30-16:00: [B(3), C(4)]
    16:00-16:30: [B(3), C(4)]
    16:30-17:00: [B(3), C(4)]
    17:00-17:30: [B(3), C(4)]
    17:30-18:00: [B(3), C(4)]

Step 2: 충돌 식별
  충돌 슬롯:
    11:00-11:30: [A(3), B(3), C(4)] → C가 최고 우선순위(4) 유일 → 충돌 아님
    11:30-12:00: [A(3), B(3), C(4)] → C가 최고 우선순위(4) 유일 → 충돌 아님
    13:00-13:30: [A(3), B(3), C(4)] → C가 최고 우선순위(4) 유일 → 충돌 아님
    13:30-14:00: [A(3), B(3), C(4)] → C가 최고 우선순위(4) 유일 → 충돌 아님

  충돌 없음! (우선순위가 다르면 충돌 아님)

Step 3: 배정 실행 (시간 순서 우선)

  멤버 정렬:
    1. C (priority 4, 가용 16슬롯)
    2. A (priority 3, 가용 10슬롯)  // 선택지 적음 우선
    3. B (priority 3, 가용 14슬롯)

  C 배정 (필요: 18슬롯):
    블록 찾기:
      - 09:00-12:00 (6슬롯) - 연속
      - 13:00-14:00 (2슬롯) - 연속
      - 15:00-18:00 (6슬롯) - 연속

    최적 블록: 09:00-12:00 (6슬롯, 이른 시간, 긴 블록)
    배정: 09:00-12:00 (6슬롯)
    남은 필요: 12슬롯

    다음 블록: 13:00-14:00 (2슬롯)
    배정: 13:00-14:00 (2슬롯)
    남은 필요: 10슬롯

    다음 블록: 15:00-18:00 (6슬롯, 필요 10슬롯)
    배정: 15:00-18:00 (6슬롯)
    남은 필요: 4슬롯

    → 추가 배정 필요 (2단계에서 처리)

  A 배정 (필요: 18슬롯):
    가용 슬롯: 없음 (C가 모두 가져감)
    → 이월

  B 배정 (필요: 18슬롯):
    블록 찾기:
      - 14:00-15:00 (2슬롯) - 연속

    배정: 14:00-15:00 (2슬롯)
    남은 필요: 16슬롯
    → 이월

Step 4: 캐리오버 처리
  학생A: 18슬롯 부족 → 다음 주로 이월
  학생B: 16슬롯 부족 → 다음 주로 이월
  학생C: 4슬롯 부족 → 다음 주로 이월


최종 결과:

  assignments: {
    "학생A": {
      assignedHours: 0,
      requiredSlots: 18,
      slots: []
    },
    "학생B": {
      assignedHours: 2,
      requiredSlots: 18,
      slots: [
        {date: 2025-09-15, startTime: "14:00", endTime: "14:30"},
        {date: 2025-09-15, startTime: "14:30", endTime: "15:00"}
      ]
    },
    "학생C": {
      assignedHours: 14,
      requiredSlots: 18,
      slots: [
        {date: 2025-09-15, startTime: "09:00", endTime: "09:30"},
        {date: 2025-09-15, startTime: "09:30", endTime: "10:00"},
        ... (총 14개)
      ]
    }
  },

  carryOverAssignments: [
    {memberId: "학생A", neededHours: 9, priority: 3, consecutiveCarryOvers: 0},
    {memberId: "학생B", neededHours: 8, priority: 3, consecutiveCarryOvers: 0},
    {memberId: "학생C", neededHours: 2, priority: 4, consecutiveCarryOvers: 0}
  ]


[시나리오 2: 대중교통 모드 - 거리 기반 배정]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

입력:
  members: [학생A, 학생B]
  owner: 방장
  options:
    minHoursPerWeek: 3
    numWeeks: 1
    transportMode: 'public'
    minClassDurationMinutes: 60

멤버 정보:
  방장:
    addressLat: 37.5665
    addressLng: 126.9780
    address: "서울시 종로구"
    defaultSchedule: [
      {dayOfWeek: 1, startTime: "09:00", endTime: "18:00", priority: 3}
    ]

  학생A:
    addressLat: 37.5700
    addressLng: 126.9800
    address: "서울시 중구"
    defaultSchedule: [
      {dayOfWeek: 1, startTime: "09:00", endTime: "18:00", priority: 3}
    ]
    personalTimes: [
      {startTime: "12:00", endTime: "13:00", days: [1]}  // 점심시간
    ]
    필요 슬롯: 18

  학생B:
    addressLat: 37.4800
    addressLng: 126.9500
    address: "서울시 관악구"
    defaultSchedule: [
      {dayOfWeek: 1, startTime: "09:00", endTime: "18:00", priority: 3}
    ]
    필요 슬롯: 18


처리 과정:

Step 1: 타임테이블 생성
  월요일 09:00-18:00
  슬롯 생성 (30분 단위)

Step 2: 대중교통 모드 배정 시작

  현재 위치: 방장 위치 (종로구)
  현재 종료 시간: null → 09:00부터 시작

  1차 배정:
    후보: [학생A, 학생B]

    Google Maps API 호출:
      - 종로구 → 중구: 15분 (학생A)
      - 종로구 → 관악구: 45분 (학생B)

    거리순 정렬: [학생A(15분), 학생B(45분)]

    학생A 조건 확인:
      - 현재 종료: 09:00
      - 이동시간: 15분
      - 도착시간: 09:15
      - 수업시간: 60분
      - 수업 종료: 10:15
      - 선호시간 종료: 18:00
      - 조건: 10:15 ≤ 18:00 → OK
      - 예외시간: 12:00-13:00
      - 충돌 확인: 09:15-10:15는 예외시간 전 → OK

    학생A 배정:
      - 시작: 09:00 (선호시간 시작)
      - 종료: 10:00 (60분 수업)
      - 슬롯: 09:00-09:30, 09:30-10:00 (2슬롯)
      - 대기시간: 0분

    현재 위치 업데이트: 중구
    현재 종료 시간: 10:00

  2차 배정:
    후보: [학생A(필요 16슬롯), 학생B(필요 18슬롯)]
    현재 위치: 중구
    현재 종료: 10:00

    Google Maps API 호출:
      - 중구 → 중구: 0분 (학생A)
      - 중구 → 관악구: 50분 (학생B)

    거리순 정렬: [학생A(0분), 학생B(50분)]

    학생A 조건 확인:
      - 도착시간: 10:00
      - 수업 종료: 11:00
      - 예외시간: 12:00-13:00
      - 충돌 확인: 10:00-11:00는 예외시간 전 → OK

    학생A 배정:
      - 시작: 10:00
      - 종료: 11:00
      - 슬롯: 10:00-10:30, 10:30-11:00 (2슬롯)

    현재 위치: 중구
    현재 종료: 11:00

  3차 배정:
    학생A 조건 확인:
      - 도착시간: 11:00
      - 수업 종료: 12:00
      - 예외시간: 12:00-13:00
      - 충돌 확인: 11:00-12:00는 예외시간 직전 → OK

    학생A 배정:
      - 시작: 11:00
      - 종료: 12:00
      - 슬롯: 11:00-11:30, 11:30-12:00 (2슬롯)

    현재 위치: 중구
    현재 종료: 12:00

  4차 배정:
    학생A 조건 확인:
      - 도착시간: 12:00
      - 수업 종료: 13:00
      - 예외시간: 12:00-13:00
      - 충돌! → 예외시간 이후로 이동
      - 예외시간 종료: 13:00
      - 새 시작: 13:00
      - 새 종료: 14:00
      - 대기시간: 60분
      - 조건: 14:00 ≤ 18:00 → OK

    학생A 배정:
      - 시작: 13:00 (예외시간 이후)
      - 종료: 14:00
      - 슬롯: 13:00-13:30, 13:30-14:00 (2슬롯)
      - 대기시간: 60분

    현재 위치: 중구
    현재 종료: 14:00

  ... 이런 식으로 계속 배정

  학생A 완료 후:
    학생B 배정 시작

    Google Maps API 호출:
      - 중구(마지막 위치) → 관악구: 50분

    조건 확인 및 배정...


최종 결과:
  - 학생A: 이동시간 최소화 (0분 또는 15분)
  - 학생A: 예외시간 자동 회피 (12:00-13:00)
  - 학생B: 이동시간 고려하여 배정


[시나리오 3: 이월 관리 - 2주 연속 미배정]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

입력:
  members: [학생A]
  owner: 방장
  options:
    minHoursPerWeek: 3
    numWeeks: 1

멤버 정보:
  학생A:
    carryOver: 3 (이전 주 미배정 3시간)
    carryOverHistory: [
      {timestamp: "2025-09-08T00:00:00Z", hours: 3}  // 1주 전
    ]
    defaultSchedule: [
      {dayOfWeek: 1, startTime: "09:00", endTime: "10:00", priority: 3}
    ]
    필요 슬롯: 36 (3시간 * 6슬롯 + 3시간 * 6슬롯 = 36슬롯)


처리 과정:

Step 1: 타임테이블 생성
  월요일 09:00-10:00만 가능 (2슬롯)

Step 2: 배정 실행
  학생A:
    필요: 36슬롯
    가용: 2슬롯
    배정: 09:00-10:00 (2슬롯)
    부족: 34슬롯

Step 3: 캐리오버 처리
  학생A:
    carryOver가 있음 → 우선권 부여
    빈 슬롯 찾기 → 없음
    연속 이월 횟수 확인:
      - carryOverHistory에서 최근 2주 내 이월: 1회
      - 이번 주 이월 추가 → 2회
      - 2회 >= 2 (CARRY_OVER_THRESHOLD_WEEKS)
      - needsIntervention = true
      - interventionReason = "2주 연속 시간 미배정 (부족: 17시간)"


최종 결과:

  assignments: {
    "학생A": {
      assignedHours: 2,
      requiredSlots: 36,
      slots: [
        {date: 2025-09-15, startTime: "09:00", endTime: "09:30"},
        {date: 2025-09-15, startTime: "09:30", endTime: "10:00"}
      ],
      needsIntervention: true,
      interventionReason: "2주 연속 시간 미배정 (부족: 17시간)"
    }
  },

  carryOverAssignments: [
    {
      memberId: "학생A",
      neededHours: 17,
      priority: 3,
      consecutiveCarryOvers: 2  // 2주 연속 이월
    }
  ],

  unassignedMembersInfo: [
    {
      memberId: "학생A",
      neededHours: 17,
      needsIntervention: true,
      interventionReason: "2주 연속 시간 미배정 (부족: 17시간)"
    }
  ]

→ 방장이 개입하여 수동으로 시간 조정 필요


================================================================================
9. LLM(AI) 사용 여부 분석
================================================================================

[결론: LLM/AI 사용 없음]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

이 자동배정 알고리즘은 순수 규칙 기반(Rule-based) 알고리즘으로,
LLM이나 머신러닝 모델을 사용하지 않습니다.


[근거]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. 외부 API 사용 확인
   ✓ Google Maps Distance Matrix API: 거리 계산용
   ✗ OpenAI API 없음
   ✗ Claude API 없음
   ✗ 기타 LLM API 없음

2. 코드 분석
   - 모든 로직이 명시적 조건문으로 구현
   - if/else, for/while 루프만 사용
   - 점수 계산도 수학 공식 기반
   - 확률적 요소 없음

3. 의존성 확인 (package.json에서 확인 필요)
   - googleapis 패키지만 사용 (Google Maps용)
   - openai, anthropic, langchain 등 LLM 관련 패키지 없음

4. 알고리즘 특징
   - 결정론적 (Deterministic): 같은 입력 → 같은 출력
   - 투명성: 모든 결정 과정 추적 가능
   - 예측 가능성: 규칙에 따라 동작


[알고리즘 분류]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

카테고리: 제약 만족 문제 (Constraint Satisfaction Problem)
전략: 탐욕 알고리즘 (Greedy Algorithm)
최적화: 휴리스틱 기반 (Heuristic-based)

세부 기법:
  - 우선순위 기반 배정
  - 시간 순서 배정 (Time-ordered Assignment)
  - 거리 기반 배정 (Distance-based Assignment)
  - 라운드 로빈 (Round-robin)


[AI가 아닌 이유]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✗ 학습 과정 없음
  - 과거 데이터로부터 패턴 학습 안 함
  - 파라미터 최적화 안 함

✗ 모델 없음
  - Neural Network 없음
  - Decision Tree 없음
  - 통계 모델 없음

✗ 예측 없음
  - 미래 행동 예측 안 함
  - 확률 기반 의사결정 안 함

✓ 규칙 기반
  - 모든 로직이 명시적 규칙
  - 개발자가 정의한 알고리즘 따름


[Google Maps API는 AI인가?]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Google Maps Distance Matrix API 사용:
  - 용도: 두 지점 간 이동 시간 계산
  - 내부 구현: Google의 경로 탐색 알고리즘 (Dijkstra, A* 등)
  - AI 여부: 경로 최적화에 일부 AI 사용 가능하나,
            이 알고리즘은 단순히 결과값만 사용
  - 결론: 이 알고리즘 자체는 AI 아님 (외부 서비스 활용)


================================================================================
10. 주요 함수 목록 및 역할
================================================================================

[메인 진입점]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: index.js

runAutoSchedule(members, owner, roomTimeSlots, options, deferredAssignments)
  역할: 자동 스케줄링 메인 진입점
  입력: 멤버, 방장, 기존 슬롯, 옵션, 지연 배정
  출력: {assignments, carryOverAssignments, unassignedMembersInfo}
  호출: 모든 서브 모듈 조율

getMemberPriority(member)
  역할: 멤버 우선순위 반환
  입력: 멤버 객체
  출력: 1-5 (우선순위)


[타임테이블 생성]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: services/timetableCreationService.js

createTimetableFromPersonalSchedules(members, owner, startDate, numWeeks, roomSettings, fullRangeStart, fullRangeEnd)
  역할: 개인 시간표 기반 타임테이블 생성
  입력: 멤버, 방장, 날짜 범위, 방 설정
  출력: timetable 객체
  주요 로직:
    - 방장 가용 시간 수집
    - 멤버별 가용 시간 추가
    - 개인시간 제거
    - 금지시간 제거

filterFutureDates(timetable, todayString)
  역할: 오늘 이후 날짜만 필터링
  입력: 전체 타임테이블, 오늘 날짜
  출력: 필터링된 타임테이블


[충돌 식별]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: services/conflictIdentificationService.js

identifyConflictsBeforeAssignment(timetable, ownerId, memberRequiredSlots)
  역할: 배정 전 충돌 식별
  입력: 타임테이블, 방장 ID, 필요 슬롯
  출력: {conflicts, memberAvailableSlots}
  로직:
    - 2명 이상 + 같은 우선순위 → 충돌
    - 멤버별 가용 슬롯 수 계산

calculateMemberAvailableSlots(timetable, ownerId)
  역할: 멤버별 가용 슬롯 수 계산
  입력: 타임테이블, 방장 ID
  출력: {멤버ID: 슬롯수}

checkSlotConflict(slot, ownerId)
  역할: 특정 슬롯의 충돌 확인
  입력: 슬롯 객체, 방장 ID
  출력: 충돌 정보 또는 null


[슬롯 배정 - 일반 모드]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: services/slotAssignmentService.js

assignByTimeOrder(timetable, assignments, memberRequiredSlots, ownerId, members, assignmentMode)
  역할: 시간 순서 우선 배정
  입력: 타임테이블, 배정 객체, 필요 슬롯, 멤버, 배정 모드
  출력: 없음 (assignments 직접 수정)
  로직:
    1단계: 선택지 적은 멤버 우선 배정
    2단계: 남은 슬롯 추가 배정
  전략:
    - 연속 블록 우선
    - 필요량 충족 블록 우선
    - 이른 시간부터

assignUndisputedSlots(timetable, assignments, priority, memberRequiredSlots, conflictingSlots)
  역할: 논쟁 없는 슬롯 배정 (현재 비활성화)
  입력: 타임테이블, 배정 객체, 우선순위, 충돌 슬롯
  출력: 없음
  로직:
    - 단독 사용 가능한 슬롯 우선
    - 라운드 로빈 방식

iterativeAssignment(timetable, assignments, priority, memberRequiredSlots, members, ownerPreferences, conflictingSlots, ownerId)
  역할: 반복적 배정 (현재 비활성화)
  입력: 타임테이블, 배정 객체, 멤버, 선호 설정, 충돌 슬롯
  출력: 없음
  로직:
    - 최고 우선순위 유일한 슬롯 배정
    - 변화 없을 때까지 반복


[슬롯 배정 - 대중교통 모드]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: services/publicTransportAssignmentService.js

assignByPublicTransport(timetable, assignments, memberRequiredSlots, ownerId, members, options)
  역할: 대중교통 모드로 순차 배정
  입력: 타임테이블, 배정 객체, 멤버, 옵션
  출력: 없음 (async)
  로직:
    - 요일별 처리
    - 가장 가까운 학생부터 배정
    - 이동시간 + 수업시간 고려
    - 예외시간 자동 회피

assignTimeSlot(timetable, assignments, memberId, dayOfWeek, startTime, endTime, daySlotKeys)
  역할: 시간 슬롯 배정 (30분 단위)
  입력: 타임테이블, 멤버 ID, 시작/종료 시간
  출력: 배정된 슬롯 수 (async)


[배정 헬퍼]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: helpers/assignmentHelper.js

initializeMemberAssignments(members, memberRequiredSlots)
  역할: 멤버별 assignments 초기화
  입력: 멤버 배열, 필요 슬롯
  출력: assignments 객체

calculateMemberRequiredSlots(members, minHoursPerWeek, actualWeeksInRange)
  역할: 멤버별 필요 슬롯 계산
  입력: 멤버 배열, 주당 최소 시간, 주 수
  출력: {멤버ID: 필요 슬롯 수}
  공식: (minHoursPerWeek * weeks + carryOver) * SLOTS_PER_HOUR

assignSlot(timetable, assignments, key, memberId)
  역할: 타임테이블에 슬롯 배정
  입력: 타임테이블, 배정 객체, 슬롯 키, 멤버 ID
  출력: 없음
  효과:
    - timetable[key].assignedTo = memberId
    - assignments[memberId].assignedHours += 1
    - assignments[memberId].slots.push(...)

isMemberFullyAssigned(assignments, memberId, memberRequiredSlots)
  역할: 멤버가 필요량 충족했는지 확인
  입력: 배정 객체, 멤버 ID, 필요 슬롯
  출력: boolean

getUnsatisfiedMembers(assignments, memberRequiredSlots, excludeOwnerId)
  역할: 미충족 멤버 목록 반환
  입력: 배정 객체, 필요 슬롯, 제외 ID
  출력: [멤버 ID 배열]

loadExistingSlots(roomTimeSlots, assignments, ownerId)
  역할: 기존 슬롯을 assignments에 로드
  입력: 방 타임슬롯 배열, 배정 객체, 방장 ID
  출력: 없음 (assignments 직접 수정)

calculateTravelTime(origin, destination, transportMode)
  역할: Google Maps API로 이동 시간 계산
  입력: 출발지 좌표, 목적지 좌표, 이동수단
  출력: 이동 시간 (분) - async
  API: Google Maps Distance Matrix API

sortMembersByDistance(currentLocation, candidateMembers, transportMode)
  역할: 후보 멤버들을 거리순 정렬
  입력: 현재 위치, 후보 멤버, 이동수단
  출력: [{member, travelTimeMinutes}] - async

findNearestMemberWithSufficientTime(params)
  역할: 가장 가까우면서 시간 충족하는 학생 찾기
  입력: {currentLocation, currentEndTime, candidateMembers, currentDay, classDurationMinutes, transportMode}
  출력: {member, slot, travelTimeMinutes} 또는 null - async
  로직:
    - 거리순 정렬
    - 이동시간 + 수업시간 ≤ 선호시간 확인
    - 예외시간 충돌 시 자동 이동


[멤버 헬퍼]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: helpers/memberHelper.js

getMemberPriority(member)
  역할: 멤버 우선순위 가져오기
  입력: 멤버 객체
  출력: 1-5 (우선순위)
  순서:
    1. member.priority
    2. member.user.priority
    3. DEFAULT_PRIORITY (3)

extractMemberId(member)
  역할: 멤버 ID 추출
  입력: 멤버 객체
  출력: 멤버 ID 문자열

findMemberById(members, memberId)
  역할: 멤버 배열에서 특정 ID 찾기
  입력: 멤버 배열, 멤버 ID
  출력: 멤버 객체 또는 null

filterNonOwnerMembers(members, ownerId)
  역할: 방장 제외 멤버 필터링
  입력: 멤버 배열, 방장 ID
  출력: 방장 제외 멤버 배열

sortMembersByPriority(members)
  역할: 멤버 배열을 우선순위로 정렬
  입력: 멤버 배열
  출력: 정렬된 멤버 배열 (높은 순)

getMemberNeededSlots(member, memberRequiredSlots, assignments)
  역할: 멤버의 필요 슬롯 계산
  입력: 멤버, 필요 슬롯, 배정 객체
  출력: 필요 슬롯 수

createUnassignedMembersInfo(assignments, memberRequiredSlots, ownerId, members)
  역할: 미배정 멤버 정보 생성
  입력: 배정 객체, 필요 슬롯, 방장 ID, 멤버
  출력: 미배정 멤버 정보 배열

createCarryOverAssignments(assignments, memberRequiredSlots, ownerId, members, startDate)
  역할: 캐리오버 배정 생성
  입력: 배정 객체, 필요 슬롯, 방장 ID, 멤버, 시작 날짜
  출력: 캐리오버 배정 배열


[충돌 헬퍼]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: helpers/conflictMerger.js

mergeConsecutiveConflicts(conflicts, timetable)
  역할: 연속된 충돌 슬롯들을 블록으로 병합
  입력: 충돌 배열, 타임테이블
  출력: 병합된 충돌 블록 배열
  조건:
    - 같은 날짜
    - 시간이 연속
    - 같은 멤버 조합

calculateBlockDuration(block)
  역할: 충돌 블록의 총 시간(분) 계산
  입력: 충돌 블록
  출력: 총 분

calculateBlockSlotCount(block)
  역할: 충돌 블록의 슬롯 수 계산
  입력: 충돌 블록
  출력: 슬롯 수 (30분 단위)

filterUnsatisfiedConflictingMembers(conflictingMembers, assignments, memberRequiredSlots)
  역할: 할당량 채운 멤버 필터링
  입력: 충돌 멤버, 배정 객체, 필요 슬롯
  출력: 아직 할당 필요한 멤버 배열


[이월 헬퍼]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: helpers/carryOverHelper.js

calculateCarryOverHours(assignments, memberRequiredSlots)
  역할: 이월 필요량 계산
  입력: 배정 객체, 필요 슬롯
  출력: {멤버ID: 이월 시간}

getConsecutiveCarryOvers(member)
  역할: 연속 이월 횟수 확인
  입력: 멤버 객체
  출력: 최근 2주 내 연속 이월 횟수

needsIntervention(member)
  역할: 개입이 필요한지 확인
  입력: 멤버 객체
  출력: boolean (2주 이상 연속 이월)

processDeferredAssignments(timetable, assignments, deferredAssignments, assignSlotFn)
  역할: 지연 배정 처리
  입력: 타임테이블, 배정 객체, 지연 배정 배열, 배정 함수
  출력: 없음
  로직:
    - 경쟁 적은 슬롯 우선
    - 필요량 충족할 때까지 배정


[타임테이블 헬퍼]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: helpers/timetableHelper.js

createOwnerAvailableSlots(owner, rangeStart, rangeEnd)
  역할: 방장의 가용 슬롯 Set 생성
  입력: 방장 객체, 범위 시작, 범위 끝
  출력: 가용 슬롯 키 Set
  처리:
    - defaultSchedule 처리
    - scheduleExceptions 처리
    - 주말 제외

removeOwnerPersonalTimes(ownerAvailableSlots, owner, rangeStart, rangeEnd)
  역할: 방장의 개인시간으로 슬롯 제거
  입력: 가용 슬롯 Set, 방장, 범위
  출력: 없음 (Set 직접 수정)

removeBlockedTimes(ownerAvailableSlots, blockedTimes, rangeStart, rangeEnd)
  역할: 방 설정의 금지 시간 제거
  입력: 가용 슬롯 Set, 금지 시간, 범위
  출력: 없음 (Set 직접 수정)

addMemberAvailability(slot, memberId, priority, isOwner)
  역할: 슬롯에 멤버 availability 추가
  입력: 슬롯 객체, 멤버 ID, 우선순위, 방장 여부
  출력: 없음

removeMemberFromSlot(timetable, key, memberId)
  역할: 슬롯에서 멤버 제거
  입력: 타임테이블, 슬롯 키, 멤버 ID
  출력: 없음


[다중 주 스케줄링]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: services/multiWeekSchedulingService.js

runMultiWeekSchedule(params, runSingleWeekSchedule)
  역할: 다중 주 스케줄링 실행
  입력: 파라미터, 단일 주 스케줄링 함수
  출력: 스케줄링 결과
  로직:
    - 각 주마다 반복
    - 주별 옵션 생성 (numWeeks=1)
    - 단일 주 배정 실행
    - 결과 병합


[유틸리티 - 시간]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: utils/timeUtils.js

calculateEndTime(startTime)
  역할: 시작 시간 + 30분 = 종료 시간
  입력: "09:00"
  출력: "09:30"

timeToMinutes(timeStr)
  역할: 시간 문자열을 분으로 변환
  입력: "09:30"
  출력: 570 (9*60 + 30)

minutesToTime(minutes)
  역할: 분을 시간 문자열로 변환
  입력: 570
  출력: "09:30"

isInPreferredTime(time, focusTimeType)
  역할: 집중 시간대에 해당하는지 확인
  입력: "09:30", "morning"
  출력: true/false

validateTimeSlotWithTravel(currentEndTime, travelTimeMinutes, classDurationMinutes, preferenceStart, preferenceEnd, personalTimes, dayOfWeek)
  역할: 이동시간 + 수업시간이 선호시간 및 예외시간 고려하여 적합한지 확인
  입력: 현재 종료 시간, 이동 시간, 수업 시간, 선호시간 범위, 개인시간, 요일
  출력: {isValid, slot, reason}
  로직:
    - 도착 시간 = 현재 종료 + 이동 시간
    - 예외시간 충돌 확인
    - 충돌 시 예외시간 이후로 이동
    - 선호시간 초과 확인


[유틸리티 - 슬롯]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: utils/slotUtils.js

generateTimeSlots(startTime, endTime)
  역할: 시간 범위에서 30분 단위 슬롯 배열 생성
  입력: "09:00", "12:00"
  출력: ["09:00", "09:30", "10:00", "10:30", "11:00", "11:30"]

extractDateFromSlotKey(slotKey)
  역할: 슬롯 키에서 날짜 추출
  입력: "2025-09-16-09:00"
  출력: "2025-09-16"

extractTimeFromSlotKey(slotKey)
  역할: 슬롯 키에서 시간 추출
  입력: "2025-09-16-09:00"
  출력: "09:00"

createSlotKey(dateKey, time)
  역할: 슬롯 키 생성
  입력: "2025-09-16", "09:00"
  출력: "2025-09-16-09:00"

areConsecutiveSlots(key1, key2)
  역할: 두 슬롯이 연속인지 확인
  입력: "2025-09-16-09:00", "2025-09-16-09:30"
  출력: true


[유틸리티 - 날짜]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: utils/dateUtils.js

formatDateToString(date)
  역할: Date 객체를 YYYY-MM-DD로 변환
  입력: Date 객체
  출력: "2025-09-16"

getDayNameKo(dayOfWeek)
  역할: 요일 숫자를 한글 요일명으로 변환
  입력: 1
  출력: "월"

isWeekend(date)
  역할: 날짜가 주말인지 확인
  입력: Date 객체
  출력: true/false

calculateEndDate(startDate, numWeeks)
  역할: 스케줄링 기간의 종료일 계산
  입력: Date, 2
  출력: Date (2주 후)


[검증자]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: validators/conflictValidator.js

createConflictKeysSet(conflictingSlots)
  역할: 충돌 슬롯 키 Set 생성
  입력: 충돌 슬롯 배열
  출력: Set(충돌 슬롯 키)

getNonOwnerAvailable(slot, ownerId)
  역할: 슬롯에서 방장 제외한 가용 멤버 추출
  입력: 슬롯 객체, 방장 ID
  출력: 방장 제외 가용 멤버 배열

getMemberConflicts(conflictingSlots, memberId)
  역할: 해당 멤버와 관련된 충돌만 필터링
  입력: 충돌 슬롯 배열, 멤버 ID
  출력: 해당 멤버 관련 충돌 배열


[상수]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
파일: constants/timeConstants.js
  MINUTES_PER_SLOT = 10 (30분 슬롯)
  SLOTS_PER_HOUR = 6 (1시간 = 6슬롯)

파일: constants/schedulingConstants.js
  DEFAULT_REQUIRED_SLOTS = 18 (주당 3시간 * 6슬롯)
  DAY_MAP = {1: 'monday', 2: 'tuesday', ...}
  MAX_ITERATION_ROUNDS = 20

파일: constants/priorityConstants.js
  PRIORITY_LEVELS = {LOWEST: 1, LOW: 2, MEDIUM: 3, HIGH: 4, HIGHEST: 5}
  DEFAULT_PRIORITY = 3


================================================================================
부록: 파일 구조
================================================================================

schedulingAlgorithm/
├── index.js                           # 메인 진입점 (325줄)
├── constants/
│   ├── timeConstants.js              # 시간 관련 상수 (43줄)
│   ├── schedulingConstants.js        # 스케줄링 상수 (97줄)
│   ├── priorityConstants.js          # 우선순위 상수 (35줄)
│   └── errorMessages.js              # 에러 메시지 (34줄)
├── utils/
│   ├── timeUtils.js                  # 시간 유틸리티 (309줄)
│   ├── dateUtils.js                  # 날짜 유틸리티 (170줄)
│   ├── slotUtils.js                  # 슬롯 유틸리티 (206줄)
│   └── arrayUtils.js                 # 배열 유틸리티 (166줄)
├── validators/
│   ├── inputValidator.js             # 입력 검증 (109줄)
│   ├── scheduleValidator.js          # 스케줄 검증 (101줄)
│   └── conflictValidator.js          # 충돌 검증 (136줄)
├── helpers/
│   ├── assignmentHelper.js           # 배정 헬퍼 (378줄)
│   ├── memberHelper.js               # 멤버 헬퍼 (210줄)
│   ├── conflictMerger.js             # 충돌 병합 (128줄)
│   ├── carryOverHelper.js            # 이월 헬퍼 (167줄)
│   └── timetableHelper.js            # 타임테이블 헬퍼 (294줄)
└── services/
    ├── timetableCreationService.js   # 타임테이블 생성 (340줄)
    ├── conflictIdentificationService.js  # 충돌 식별 (140줄)
    ├── slotAssignmentService.js      # 슬롯 배정 (612줄)
    ├── conflictResolutionService.js  # 충돌 해결 (74줄)
    ├── publicTransportAssignmentService.js  # 대중교통 배정 (221줄)
    ├── multiWeekSchedulingService.js # 다중 주 스케줄링 (90줄)
    └── scoringService.js             # 점수 계산 (156줄)

총 24개 파일


================================================================================
문서 종료
================================================================================

본 문서는 자동배정 알고리즘의 전체 구조와 동작 원리를 완전히 분석한 문서입니다.
모든 파일을 빠짐없이 읽고 분석하여 작성되었습니다.

주요 발견 사항:
✓ LLM/AI 사용 없음 - 순수 규칙 기반 알고리즘
✓ 2가지 배정 전략 (일반 모드 / 대중교통 모드)
✓ Google Maps API 사용 (거리 계산용)
✓ 충돌 자동 회피 방식
✓ 이월 관리 및 개입 필요 플래그
✓ 30분 단위 슬롯 관리
✓ 다중 주 배정 지원

알고리즘 분류:
- 제약 만족 문제 (Constraint Satisfaction Problem)
- 탐욕 알고리즘 (Greedy Algorithm)
- 휴리스틱 기반 (Heuristic-based)
