================================================================================
이동시간 요일 재배정 구현 계획서
================================================================================
작성일: 2025-12-19
작성자: AI Assistant
상태: 계획 수립 완료

================================================================================
📋 목차
================================================================================
1. 프로젝트 개요
2. 현재 상황 분석
3. 문제점 정리
4. 해결 방안 비교 (방안 1 vs 방안 2)
5. 선택된 해결 방안 (방안 1)
6. 데이터 구조 분석
7. 코드 구조 분석
8. 상세 구현 계획
9. 단계별 작업 순서
10. 테스트 시나리오
11. 주의사항

================================================================================
1. 프로젝트 개요
================================================================================

📌 목표:
  이동시간을 고려한 스케줄 재계산 시, 배치 불가능한 학생을 다른 요일로 재배정하여
  모든 학생이 선호시간 내에 배정되도록 개선

📌 사용자 워크플로우:
  1. 서버 자동배정 → 초기 배정 (이동시간 미고려)
  2. 방장이 "보기" 버튼 클릭 → 여러 이동 수단 옵션 비교
     - 일반 모드 (이동시간 없음)
     - 대중교통 모드
     - 도보 모드
     - 자전거 모드
     - 자동차 모드
  3. 마음에 드는 옵션 선택
  4. "적용" 버튼 클릭 → 조원들에게 공유
  5. 조원들끼리 마음에 안 드는 시간 협의해서 조정

📌 핵심 요구사항:
  - "보기" 버튼: 시뮬레이션 기능 (여러 옵션 비교 가능)
  - "적용" 버튼: 선택한 옵션을 조원들에게 공유
  - 배정된 학생이 절대 사라지면 안 됨
  - 이동시간 때문에 배치 불가능하면 다른 요일로 재배정
  - 각 학생의 선호시간 내에 배정

================================================================================
2. 현재 상황 분석
================================================================================

✅ 완료된 작업:
  1. 서버 측 자동배정 로직 수정 (대중교통 모드)
     - index.js:272 버그 수정 (roomSettings.blockedTimes로 변경)
     - timeUtils.js validateTimeSlotWithTravel 함수 수정
     - 이동시간 + 수업시간을 하나의 블록으로 검증하도록 변경

  2. 클라이언트 측 이동시간 계산 로직 수정 (보기 버튼)
     - travelScheduleCalculator.js 수정
     - 금지시간 회피 로직: 금지시간 이전 → 금지시간 이후로 조정
     - 17-24시 절대 금지시간 추가 (하드코딩)
     - 17시 이후 배치 불가 처리 추가

현재 동작 방식:
  1. 방장이 이동수단 버튼 클릭 (일반/대중교통/자동차/자전거/도보)
  2. CoordinationTab → handleTravelModeChange 호출
  3. useTravelMode 훅 → travelScheduleCalculator.recalculateScheduleWithTravel 호출
  4. enhancedSchedule 업데이트 (미리보기)
  5. 시간표 화면 갱신
  6. 방장이 "적용" 버튼 클릭
  7. handleConfirmTravelMode → coordinationService.applyTravelMode 호출
  8. 서버에 저장 → 조원들에게 알림

================================================================================
3. 문제점 정리
================================================================================

❌ 발견된 문제:
  - B 학생이 아예 사라짐 (화면에서 배정이 안 보임)
  - 이동시간 때문에 조정된 시간이 선호시간을 벗어나면 배정 자체가 취소됨

구체적 시나리오:

  [확정 버튼 - 서버 원본 데이터]
  - 월요일 A 학생: 09:00-12:00 수업
  - 월요일 B 학생: 13:00-16:00 수업
  - → 겹치지 않음, 모두 정상 표시 ✅

  [보기 버튼 - 이동시간 계산 후]
  - 월요일 A 학생:
    * 원본: 09:00-12:00
    * 점심시간(12-13시) 감지
    * 조정: 13:00-14:10 이동 + 14:10-17:10 수업 ✅

  - 월요일 B 학생:
    * 원본: 13:00-16:00 (선호시간)
    * 이전 학생 종료: 17:10
    * 이동시간: 10분 필요
    * 계산: 17:10-17:20 이동 + 17:20-20:20 수업
    * 17시 이후 체크 발동 → canPlace = false ❌
    * 원본 슬롯(13:00-16:00) 유지 시도
    * **하지만 A 학생(14:10-17:10)과 겹침! (14:10-16:00 시간대)**
    * 화면에서 B 학생 사라짐 ❌

근본 원인:
  1. 시스템 로직: 선호시간 = 유일한 배정 가능 시간
  2. 선호시간 외 = 자동으로 배치 불가
  3. 17-24시 절대 금지시간 하드코딩
  4. 이동시간 포함 시 선호시간 벗어나면 → canPlace = false
  5. 원본 슬롯 유지 시도 → 이전 학생과 겹침 → 화면에서 사라짐

================================================================================
4. 해결 방안 비교 (방안 1 vs 방안 2)
================================================================================

[방안 1: 보기 버튼에서 요일 재배정 (클라이언트)] ⭐ 선택됨

  📋 설명:
    - travelScheduleCalculator.js를 수정하여 클라이언트에서 요일 재배정
    - 이동시간 고려해서 배치 불가능하면 다른 요일로 이동
    - 각 학생의 선호시간 내에서 재배정

  ✅ 장점:
    - 사용자가 직접 확인하고 선택 가능 (미리보기 → 적용)
    - 서버 수정 없이 클라이언트만 수정
    - 빠르게 구현 가능
    - 여러 이동수단 옵션 비교 가능

  ❌ 단점:
    - 매번 "보기/적용" 해야 함

  💡 워크플로우:
    1. 서버 자동배정 → 이동시간 미고려 초기 배정 (A: 월09-12, B: 월13-16)
    2. "보기" 버튼 → 클라이언트에서 이동시간 계산 (A: 월13-17, B: 화13-16)
    3. "적용" 버튼 → 재계산된 시간표를 조원들에게 공유

---

[방안 2: 서버 자동배정 로직 수정 (백엔드)]

  📋 설명:
    - 서버 자동배정 로직을 수정하여 처음부터 이동시간 고려
    - 자동배정 시 이동시간 포함해서 배치
    - 배치 불가능하면 다른 요일로 자동 이동

  ✅ 장점:
    - 완전 자동화, 사용자는 확인만
    - "보기/적용" 버튼 불필요
    - 근본적 해결

  ❌ 단점:
    - 서버 로직 대규모 수정 필요
    - 시간 오래 걸림
    - 사용자가 여러 옵션 비교 불가능
    - 선택권 없음

  💡 워크플로우:
    1. 서버 자동배정 → 이동시간 이미 포함 (A: 월13-17, B: 화13-16)
    2. "확정" 버튼 → 바로 조원들에게 공유

---

[선택 이유]
  ✅ 방안 1 선택
    - 사용자 요구사항: "보기"로 여러 옵션 비교 → "적용"으로 조원들에게 공유
    - 방안 2는 사용자가 선택할 여지가 없음 (자동으로 하나만 결정)
    - 이동 수단별 비교 불가능 (대중교통 vs 도보 vs 자전거 등)
    - 조원들끼리 협의해서 조정하는 프로세스가 중요함

  📅 향후 계획:
    - Phase 1 (지금): 방안 1 구현 (빠르게 동작하는 시스템 구축)
    - Phase 2 (나중): 방안 2 구현 (완전 자동화 옵션 제공)

================================================================================
5. 선택된 해결 방안 (방안 1) 상세
================================================================================

목표 결과:

  [보기 버튼 클릭 시]
  - 월요일 A 학생: 13:00-14:10 이동 + 14:10-17:10 수업 ✅
  - 화요일 B 학생: 방장→B 이동 10분 + 13:00-16:00 수업 ✅
  - → 겹치지 않고, 모두 순차적으로 배치
  - → 각 학생의 선호시간 내에 배정
  - → 배정된 학생이 사라지지 않음

핵심 철학 변경:

  기존 로직:
    - 선호시간 = 절대적인 배정 가능 시간
    - 선호시간 외 = 배치 불가
    - 17-24시 = 절대 금지시간

  새 로직:
    - 선호시간 = 권장 시간 (우선적으로 고려)
    - 선호시간 외에도 배정 가능 (단, 최후의 수단)
    - 17-24시 절대 금지 제거
    - 명시적 금지시간(점심시간 등)만 존중
    - "보기 버튼"은 이미 배정된 학생을 절대 사라지게 하면 안 됨

구현 원칙:

  1. 같은 날짜 내 배치 우선 시도
     - 이전 활동 종료 후 이동시간 + 수업시간 배치
     - 금지시간 회피 (점심시간 등)
     - 선호시간 내 배치 시도

  2. 같은 날짜 불가능 시 다른 요일로 이동
     - 다른 요일들을 순회하면서 배치 가능한 날짜 찾기
     - 선호시간 내에 배치
     - 금지시간 회피

  3. 모든 요일에 배치 불가능한 경우
     - 선호시간 외에도 배치 (경고 표시)
     - 최후의 수단: 겹치더라도 표시 (충돌 경고)

================================================================================
6. 데이터 구조 분석
================================================================================

[User 모델] (server/models/user.js)

  defaultSchedule: [{
    dayOfWeek: Number,     // 0-6 (일요일-토요일)
    startTime: String,     // "HH:MM"
    endTime: String,       // "HH:MM"
    priority: Number,      // 1-3 (1: Low, 2: Medium, 3: High)
    specificDate: String   // "YYYY-MM-DD" (선택사항)
  }]

  예시:
    - 월요일 13:00-16:00 (dayOfWeek: 1, startTime: "13:00", endTime: "16:00")
    - 화요일 09:00-12:00 (dayOfWeek: 2, startTime: "09:00", endTime: "12:00")

---

[Room 모델] (server/models/room.js)

  members: [{
    user: ObjectId,        // User 참조
    color: String,         // "#6B7280"
    priority: Number,      // 1-5
    carryOver: Number      // 이월 시간
  }]

  timeSlots: [{
    day: String,           // 'monday', 'tuesday', ...
    date: Date,            // 실제 날짜
    startTime: String,     // "HH:MM"
    endTime: String,       // "HH:MM"
    subject: String,       // "자동 배정"
    user: ObjectId,        // User 참조
    status: String         // 'confirmed', 'pending', 'conflict'
  }]

  settings.blockedTimes: [{
    name: String,          // "점심시간"
    startTime: String,     // "12:00"
    endTime: String        // "13:00"
  }]

---

[현재 코드에서 사용하는 데이터]

  currentRoom: {
    _id: String,
    owner: { _id, firstName, lastName, addressLat, addressLng },
    members: [{ user: { _id, firstName, lastName, addressLat, addressLng }, color }],
    timeSlots: [{ day, date, startTime, endTime, subject, user }],
    settings: {
      blockedTimes: [{ name, startTime, endTime }],
      startHour: 9,
      endHour: 18
    }
  }

---

[필요한 추가 데이터]

  각 학생의 선호시간 정보:
    - members 배열의 각 user에서 defaultSchedule 가져오기
    - 서버 API 호출 또는 이미 populate된 데이터 활용

  구조:
    memberPreferences: {
      [userId]: {
        monday: [{ startTime: "09:00", endTime: "12:00" }, ...],
        tuesday: [...],
        wednesday: [...],
        thursday: [...],
        friday: [...]
      }
    }

================================================================================
7. 코드 구조 분석
================================================================================

[파일 구조]

  client/src/
    components/
      tabs/CoordinationTab/
        index.js                           # 메인 컨테이너
        components/TimetableControls.js    # 시간표 컨트롤 (이동수단 버튼 포함)
      coordination/
        TravelModeButtons.js               # 이동수단 선택 버튼 ("적용" 버튼 포함)
    hooks/
      useTravelMode.js                     # 이동시간 계산 로직
    services/
      travelScheduleCalculator.js          # ⭐ 수정 대상
      travelModeService.js                 # Google Maps API 호출
    utils/
      timetableHelpers.js                  # 시간표 병합/분할 유틸

  server/
    models/
      room.js                              # Room 모델
      user.js                              # User 모델
    services/
      schedulingAlgorithm/                 # 자동배정 로직 (Phase 2에서 수정)

---

[현재 코드 흐름]

  1. CoordinationTab/index.js
     - handleTravelModeChange(newMode) 호출
     - useTravelMode 훅 사용

  2. hooks/useTravelMode.js
     - handleModeChange 함수
     - travelScheduleCalculator.recalculateScheduleWithTravel 호출
     - enhancedSchedule 업데이트

  3. services/travelScheduleCalculator.js ⭐ 수정 대상
     - recalculateScheduleWithTravel(currentRoom, travelMode)
     - 병합된 슬롯들을 순회하면서:
       * 이동시간 계산 (travelModeService)
       * 금지시간 회피
       * 시간 조정
       * canPlace 체크
       * allResultSlots에 추가
     - { timeSlots, travelSlots, travelMode } 반환

  4. TravelModeButtons.js
     - "적용" 버튼 클릭 → onConfirm 호출

  5. CoordinationTab/index.js
     - handleConfirmTravelMode
     - coordinationService.applyTravelMode(roomId, mode, scheduleData)
     - 서버에 저장 → 조원들에게 알림

---

[수정 대상 파일]

  ⭐ client/src/services/travelScheduleCalculator.js
    - recalculateScheduleWithTravel 함수 대폭 수정
    - 요일 재배정 로직 추가
    - 선호시간 체크 로직 추가
    - 17시 절대 금지 제거

================================================================================
8. 상세 구현 계획
================================================================================

[Phase 1: 데이터 준비]

  1. 학생별 선호시간 정보 가져오기

     입력: currentRoom.members
     출력: memberPreferences 객체

     로직:
       - members 배열 순회
       - 각 member.user._id로 선호시간 가져오기
       - defaultSchedule을 요일별로 그룹화
       - 데이터가 없으면 기본값 사용 (09:00-17:00)

     함수명: buildMemberPreferences(currentRoom)

     반환값:
       {
         "userId1": {
           monday: [{ startMinutes: 540, endMinutes: 720 }],    // 09:00-12:00
           tuesday: [{ startMinutes: 780, endMinutes: 960 }],   // 13:00-16:00
           ...
         },
         "userId2": { ... }
       }

---

[Phase 2: 17시 절대 금지시간 제거]

  파일: travelScheduleCalculator.js
  위치: 384-390줄

  변경 전:
    ```javascript
    const blockedTimes = currentRoom.settings?.blockedTimes || [];
    const absoluteBlockedTime = {
        name: '17-24시 절대 금지시간',
        startTime: '17:00',
        endTime: '24:00'
    };
    const allBlockedTimes = [...blockedTimes, absoluteBlockedTime];
    ```

  변경 후:
    ```javascript
    // 명시적으로 지정한 금지시간만 사용 (점심시간 등)
    const allBlockedTimes = currentRoom.settings?.blockedTimes || [];
    ```

---

[Phase 3: 17시 이후 배치 불가 로직 제거]

  파일: travelScheduleCalculator.js
  위치: 420-427줄

  변경 전:
    ```javascript
    if (adjustedStartTime >= 17 * 60 || adjustedEndTime > 17 * 60) {
        console.warn(`⚠️ [배치 불가] 17시 이후로는 배정 불가능`);
        canPlace = false;
        break;
    }
    ```

  변경 후:
    ```javascript
    // 17시 이후 체크 제거 - 선호시간 외에도 배치 허용
    ```

---

[Phase 4: 선호시간 체크 로직 추가]

  새 함수: isWithinPreferredTime(userId, dayOfWeek, startMinutes, endMinutes, memberPreferences)

  입력:
    - userId: 학생 ID
    - dayOfWeek: 0-6 (일요일-토요일)
    - startMinutes: 시작 시간 (분)
    - endMinutes: 종료 시간 (분)
    - memberPreferences: 학생별 선호시간 객체

  출력:
    - true: 선호시간 내
    - false: 선호시간 외

  로직:
    ```javascript
    const dayName = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][dayOfWeek];
    const userPrefs = memberPreferences[userId.toString()];

    if (!userPrefs || !userPrefs[dayName] || userPrefs[dayName].length === 0) {
      return false; // 선호시간 없음
    }

    // 모든 선호시간 슬롯 중 하나라도 완전히 포함되면 true
    for (const pref of userPrefs[dayName]) {
      if (startMinutes >= pref.startMinutes && endMinutes <= pref.endMinutes) {
        return true;
      }
    }

    return false;
    ```

---

[Phase 5: 요일 재배정 로직 추가]

  새 함수: findAvailableSlot(mergedSlot, memberPreferences, allBlockedTimes, assignedSlots)

  입력:
    - mergedSlot: 원본 슬롯 정보
    - memberPreferences: 학생별 선호시간
    - allBlockedTimes: 금지시간 목록
    - assignedSlots: 이미 배정된 슬롯들 (겹침 체크용)

  출력:
    {
      success: true/false,
      date: Date,              // 배정 가능한 날짜
      dayOfWeek: Number,       // 0-6
      travelStartMinutes: Number,
      travelEndMinutes: Number,
      activityStartMinutes: Number,
      activityEndMinutes: Number,
      isPreferred: true/false  // 선호시간 내인지
    }

  로직:
    1. 현재 날짜의 현재 요일부터 시작
    2. 각 요일별로:
       a. 해당 요일의 선호시간 슬롯들 가져오기
       b. 각 선호시간 슬롯에 배치 시도:
          - 이동시간 + 수업시간 계산
          - 금지시간과 겹치지 않는지 체크
          - 이미 배정된 슬롯과 겹치지 않는지 체크
          - 가능하면 반환
    3. 모든 선호시간에 배치 불가능하면:
       - 선호시간 외 시간대에도 배치 시도
       - 09:00-24:00 범위에서 가능한 시간 찾기
    4. 모든 요일에 배치 불가능하면:
       - success: false 반환

  예시:
    ```javascript
    // 월요일부터 금요일까지 순회
    for (let dayOffset = 0; dayOffset < 5; dayOffset++) {
      const targetDate = new Date(currentDate);
      targetDate.setDate(targetDate.getDate() + dayOffset);
      const dayOfWeek = targetDate.getDay();

      // 선호시간 내 배치 시도
      const preferredSlots = memberPreferences[userId][dayNames[dayOfWeek]] || [];
      for (const prefSlot of preferredSlots) {
        // 배치 가능한지 체크
        if (canPlaceAt(prefSlot, ...)) {
          return { success: true, date: targetDate, ... };
        }
      }
    }
    ```

---

[Phase 6: recalculateScheduleWithTravel 함수 수정]

  주요 변경사항:
    1. 함수 시작 시 memberPreferences 생성
    2. 날짜별로 assignedSlots 추적 (겹침 방지)
    3. 각 슬롯 처리 시:
       - 현재 날짜에 배치 시도
       - 불가능하면 findAvailableSlot 호출
       - 다른 요일로 재배정
    4. canPlace 로직 개선:
       - 명시적 금지시간만 체크
       - 선호시간 체크 추가
       - 겹침 체크 강화

  수정된 로직:
    ```javascript
    async recalculateScheduleWithTravel(currentRoom, travelMode = 'normal') {
      // ... 기존 코드 ...

      // 1. 학생별 선호시간 정보 생성
      const memberPreferences = this.buildMemberPreferences(currentRoom);

      // 2. 날짜별 배정된 슬롯 추적
      const assignedSlotsByDate = {}; // { "2025-12-03": [{ startMinutes, endMinutes, userId }] }

      for (const mergedSlot of sortedMergedSlots) {
        const slotDate = new Date(mergedSlot.date).toISOString().split('T')[0];

        // ... 이동시간 계산 ...

        // 3. 현재 날짜에 배치 시도
        let placement = this.tryPlaceOnDate(
          mergedSlot,
          slotDate,
          travelDurationMinutes,
          activityDurationMinutes,
          previousActivityEndMinutes,
          allBlockedTimes,
          assignedSlotsByDate,
          memberPreferences
        );

        // 4. 불가능하면 다른 요일로 재배정
        if (!placement.success) {
          console.log(`⚠️ [현재 날짜 배치 불가] 다른 요일 검색 시작`);
          placement = this.findAvailableSlot(
            mergedSlot,
            memberPreferences,
            allBlockedTimes,
            assignedSlotsByDate,
            travelDurationMinutes,
            activityDurationMinutes
          );
        }

        // 5. 배치 성공하면 슬롯 추가
        if (placement.success) {
          // travelBlock 생성
          // activityBlock 생성
          // allResultSlots에 추가
          // assignedSlotsByDate에 기록

          if (!placement.isPreferred) {
            console.warn(`⚠️ [선호시간 외 배치] ${memberLocation.name}: ${placement.date}`);
          }
        } else {
          // 최후의 수단: 원본 슬롯 유지 + 경고
          console.error(`❌ [배치 실패] ${memberLocation.name}: 모든 요일에 배치 불가능`);
          allResultSlots.push(...this.unmergeBlock(mergedSlot));
        }

        // 위치 업데이트
        previousLocation = memberLocation;
      }

      return { timeSlots: allResultSlots, travelSlots: travelSlotsArray, travelMode };
    }
    ```

---

[Phase 7: 겹침 방지 로직 강화]

  함수: checkOverlap(date, startMinutes, endMinutes, userId, assignedSlotsByDate)

  입력:
    - date: 날짜 ("YYYY-MM-DD")
    - startMinutes: 시작 시간 (분)
    - endMinutes: 종료 시간 (분)
    - userId: 학생 ID
    - assignedSlotsByDate: 날짜별 배정된 슬롯

  출력:
    - true: 겹침
    - false: 겹치지 않음

  로직:
    ```javascript
    const slotsOnDate = assignedSlotsByDate[date] || [];

    for (const slot of slotsOnDate) {
      // 시간이 겹치는지 체크
      if (startMinutes < slot.endMinutes && endMinutes > slot.startMinutes) {
        return true; // 겹침
      }
    }

    return false; // 겹치지 않음
    ```

================================================================================
9. 단계별 작업 순서
================================================================================

[Step 1] 보조 함수 작성
  □ buildMemberPreferences(currentRoom)
  □ isWithinPreferredTime(...)
  □ checkOverlap(...)
  □ checkBlockedTime(...)

[Step 2] 17시 절대 금지시간 제거
  □ 384-390줄 수정
  □ 420-427줄 삭제

[Step 3] 현재 날짜 배치 시도 함수 작성
  □ tryPlaceOnDate(...)
    - 이동시간 + 수업시간 계산
    - 금지시간 회피
    - 겹침 체크
    - 선호시간 체크

[Step 4] 요일 재배정 함수 작성
  □ findAvailableSlot(...)
    - 월-금 순회
    - 선호시간 우선 시도
    - 선호시간 외도 시도

[Step 5] recalculateScheduleWithTravel 함수 수정
  □ memberPreferences 생성
  □ assignedSlotsByDate 추적
  □ tryPlaceOnDate 호출
  □ findAvailableSlot 호출
  □ 결과 처리

[Step 6] 로깅 및 디버깅
  □ console.log 추가
  □ 배치 과정 추적
  □ 선호시간 외 경고

[Step 7] 테스트
  □ 기본 케이스 테스트
  □ 요일 재배정 테스트
  □ 선호시간 외 배치 테스트
  □ 금지시간 회피 테스트
  □ 겹침 방지 테스트

================================================================================
10. 테스트 시나리오
================================================================================

[테스트 1: 기본 케이스 - 같은 날짜 내 배치]
  입력:
    - A 학생: 월 09:00-12:00 원본, 선호시간: 월 09:00-17:00
    - 이동시간: 70분
    - 금지시간: 12:00-13:00

  예상 결과:
    - A 학생: 월 13:00-14:10 이동 + 14:10-17:10 수업
    - 선호시간 내 배치 ✅
    - 금지시간 회피 ✅

---

[테스트 2: 요일 재배정 - 다른 날짜로 이동]
  입력:
    - A 학생: 월 09:00-12:00 원본
    - B 학생: 월 13:00-16:00 원본, 선호시간: 화 13:00-16:00
    - A 종료: 17:10
    - B 이동시간: 10분

  예상 결과:
    - A 학생: 월 13:00-14:10 이동 + 14:10-17:10 수업
    - B 학생: 화 13:00-13:10 이동 + 13:10-16:10 수업 ✅
    - B가 화요일로 재배정됨 ✅
    - 선호시간 내 배치 ✅

---

[테스트 3: 선호시간 외 배치]
  입력:
    - 모든 요일의 선호시간이 꽉 찬 경우

  예상 결과:
    - 선호시간 외 시간대에 배치
    - 경고 로그 출력 ⚠️
    - 화면에 "선호시간 외" 표시

---

[테스트 4: 금지시간 회피]
  입력:
    - C 학생: 월 11:00-14:00 수업
    - 금지시간: 12:00-13:00
    - 이동시간: 30분

  예상 결과:
    - C 학생: 월 13:00-13:30 이동 + 13:30-16:30 수업
    - 금지시간 이후로 조정 ✅

---

[테스트 5: 겹침 방지]
  입력:
    - 같은 날짜에 여러 학생 배정

  예상 결과:
    - 모든 학생이 순차적으로 배치
    - 겹치는 시간대 없음 ✅

================================================================================
11. 주의사항
================================================================================

⚠️ 데이터 무결성:
  - 선호시간이 없는 학생 처리 (기본값 사용)
  - userId가 없는 슬롯 처리 (원본 유지)
  - memberLocation이 없는 경우 처리 (원본 유지)

⚠️ 성능:
  - 학생 수가 많을 때 요일 재배정 성능 고려
  - 불필요한 API 호출 방지 (Google Maps API 캐싱)
  - 무한 루프 방지 (최대 시도 횟수 제한)

⚠️ UI/UX:
  - 선호시간 외 배치 시 시각적 구분 (색상, 아이콘)
  - "선호시간 외" 경고 메시지 표시
  - 요일 변경 시 사용자에게 알림

⚠️ 백엔드 일관성:
  - 보기 버튼(프론트엔드)과 자동배정(백엔드)의 로직 차이 인지
  - 추후 백엔드 통합 필요 (Phase 2)

⚠️ 에러 처리:
  - 이동시간 계산 실패 시 처리
  - 선호시간 데이터 누락 시 처리
  - 모든 요일에 배치 불가능한 경우 처리

================================================================================
END OF DOCUMENT
================================================================================
